/*
  This is the binding file for the unix module and all of it's
  sub-modules. This is a large and complicated binding with hundreds
  of functions, variables and constants from the basic Unix/C api
  wrapped into Anna equivalents.

  The Anna binding generator is written in Anna and uses many of the
  functions of the unix module, which creates a chicken-and-egg
  problem.

  This is solved by using an older version of the unix module to run
  the binding generator, though this can sometimes lead to a wedged
  build if the compiler fails while trying to build a new unix.so.  If
  that happens, try running «git checkout lib/unix.c; make
  lib/unix.so».
 */

include(
    "<sys/types.h>", "<sys/stat.h>", "<unistd.h>", "<fcntl.h>",
    "<sys/time.h>", "<sys/resource.h>", "<signal.h>", "<sys/wait.h>", 
    "<grp.h>", "<stdint.h>", "<poll.h>", "<sys/select.h>", "<locale.h>", 
    "<termios.h>", "<sys/signalfd.h>",
    );

attribute(
    doc(
	"The unix module is the parent module for various low level wrappers for basic Unix functionality.", 
	"Anna currently has a very sparse standard library, which often necessitates the use of these low level libraries, but when available, a more programmer friendly high level library should be used. The documentation for these modules is very sparse - the same documentation is also available e.g. as Unix man pages.", 
	"The unix module is still rater incomplete. There are many, many functions that are currently missing. The ones that are there have inconsistent naming policies with regard to capitalization, abbreviations, etc. The exact policy for naming, etc. in this module will evolve over time, which can result in future incompatibilities.",
	));

io
{

    attribute(
	doc(
	    "The unix.io module contains low level wrappers for basic unix functionality revolving around input and output.", 
	    "Unix input/output centers around file descriptors. File descriptors are small, positive integers that can represent open files, directories, pipes or even network sockets.",
	    ));

    openMode
    {
	attribute(doc("Flags determining the mode for unix.io.open"));
	const Int readOnly (name(O_RDONLY), doc("Open file in read-only mode."));
	const Int writeOnly (name(O_WRONLY), doc("Open file in write-only mode."));
	const Int readWrite (name(O_RDWR), doc("Open file in read-write mode."));

	const Int append (name(O_APPEND), doc("The file is opened in append mode."));
	const Int async (name(O_ASYNC), doc("Enable signal-driven I/O."));
	const Int create (name(O_CREAT), doc("If the file does not exist it will be created."));
	const Int closeOnExec (name(O_CLOEXEC), doc("Enable the close-on-exec flag for the new file descriptor."));
	const Int direct (name(O_DIRECT), doc("Try to minimize cache effects of the I/O to and from this file."));
	const Int directory (name(O_DIRECTORY), doc("If pathname is not a directory, cause the open to fail."));
	const Int exclusive (name(O_EXCL), doc("Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail."));
	const Int largeFile (name(O_LARGEFILE), doc("(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened."));
	const Int noAccessTime (name(O_NOATIME), doc("Do not update the file last access time (st_atime in the inode) when the file is read()."));
	const Int noControllingTTY (name(O_NOCTTY), doc("If pathname refers to a terminal device - it will not become the process's controlling terminal even if the process does not have one."));
	const Int noFollow (name(O_NOFOLLOW), doc("If pathname is a symbolic link, then the open fails."));
	const Int nonBlock (name(O_NONBLOCK), doc("When possible, the file is opened in nonblocking mode."));
	const Int synchronous (name(O_SYNC), doc("The file is opened for synchronous I/O."));
	const Int truncate (name(O_TRUNC), doc("f the file already exists and is a regular file and the open mode allows writing (i.e., is writeOnly or readWrite) it will be truncated to length 0."));
    }

    statMode
    {
	attribute(doc("Flags used for identifying file status together with a unix.io.Stat object."));
	const Int regular (name(S_IFREG), doc("Regular file"));
	const Int socket (name(S_IFSOCK), doc("Socket"));
	const Int link (name(S_IFLNK), doc("Symbolic link."));
	const Int block (name(S_IFBLK), doc("Block device."));
	const Int directory (name(S_IFDIR), doc("Directory."));
	const Int character (name(S_IFCHR), doc("Character device."));
	const Int fifo (name(S_IFIFO), doc("FIFO."));
    
	const Int suid (name(S_ISUID), doc("Set UID bit."));
	const Int sgid (name(S_ISGID), doc("Set-group-ID bit."));
	const Int sticky (name(S_ISVTX), doc("Sticky bit."));
    
	const Int userAll (name(S_IRWXU), doc("Mask for all file owner permissions."));
	const Int userRead (name(S_IRUSR), doc("File owner read permission."));
	const Int userwrite (name(S_IWUSR), doc("File owner write permission."));
	const Int userExecute (name(S_IXUSR), doc("File owner execute permission."));
    
	const Int groupAll (name(S_IRWXG), doc("Mask for all group permissions."));
	const Int groupRead (name(S_IRGRP), doc("Group has read permission."));
	const Int groupwrite (name(S_IWGRP), doc("Group has write permission."));
	const Int groupExecute (name(S_IXGRP), doc("Group has execute permission."));
    
	const Int otherAll (name(S_IRWXO), doc("Mask for permissions for others (not in group)."));
	const Int otherRead (name(S_IROTH), doc("Others have read permission."));
	const Int otherwrite (name(S_IWOTH), doc("Others have write permission."));
	const Int otherExecute (name(S_IXOTH), doc("Others have execute permission."));
    }

    def Int open(String name, Int flags, Int mode) (doc("Open a file descriptor.", "Equivalent to the C open function."));
    def Int creat(String name, Int mode) (doc("Open a file descriptor.", "Equivalent to the C creat function."), alias(create));
    def Int read(Int fd, Buffer buffer(ensureCapacity(count)), Int count) (doc("Read from a file descriptor.", "Equivalent to the C read function."));
    def Int write(Int fd, Buffer buffer(ensureCapacity(count)), Int count) (doc("Write to a file descriptor.", "Equivalent to the C write function."));
    def Bool close(Int fd) (doc("Close a file descriptor.", "Equivalent to the C close function."));

    cStruct Stat (name(stat), doc("A structure representing the status of a file.", "This is a straight conversion of the C struct stat."))
    {
	const Int dev (name(st_dev), doc("ID of device containing file"));
	const Int ino (name(st_ino), doc("Inode number"));
	const Int mode (name(st_mode), doc("File protection mask"));
	const Int nlink (name(st_nlink), doc("Number of hard links."));
	const Int uid (name(st_uid), doc("User ID of owner."));
	const Int gid (name(st_gid), doc("Group ID of owner."));
	const Int rdev (name(st_rdev), doc("Device ID."));
	const Int size (name(st_size), doc("Total size in bytes."));
	const Int blksize (name(st_blksize), doc("Block size for file system IO."));
	const Int blocks (name(st_blocks), doc("Number of 512 byte blocks allocated."));
	const Int atime (name(st_atime), doc("Time of latest acccess."));
	const Int mtime (name(st_mtime), doc("Time of latest modification."));
	const Int ctime (name(st_ctime), doc("Time of latest change."));
    }

    def Bool stat(String path, Stat buf) (doc("Check the status of file with the specified path. Equivalanet to the C stat function."));
    def Bool lstat(String path, Stat buf) (doc("Check the status of file with the specified path, without following symlinks. Equivalanet to the C lstat function."));
    def Bool fstat(Int fd, Stat buf) (doc("Check the status of file with the specified file descriptor. Equivalanet to the C fstat function."));

    def Bool mkdir(String path, Int mode) (doc("Create a new driectory with the specified path. Equivalanet to the C mkdir function."));

    const standardInput (doc("File descriptor for standard input.")) = 0;
    const standardOutput (doc("File descriptor for standard output.")) = 1;
    const standardError(doc("File descriptor for error output")) = 2;

    def Bool getcwd(Buffer buf(ensureCapacity(size)), Int size) (doc("Get current working directory."));
    def Bool chdir(String path) (doc("Change working directory."));
    def Bool chroot(String path) (doc("Change root directory."));
    def Bool fchdir(Int fd) (doc("Change working directory."));

    cStruct FLock (name(flock), doc("File lock information"))
    {
	const Int type (name(l_type), doc("Type of lock: F_RDLCK, F_WRLCK, F_UNLCK."));
	const Int whence (name(l_whence), doc("How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END."));
	const Int start (name(l_start), doc("Starting offset for lock"));
	const Int len (name(l_len), doc("Number of bytes to lock"));
	const Int pid (name(l_pid), doc("PID of process blocking our lock (F_GETLK only)"));
    }

    fcntlMode
    {
	attribute(doc("Flags specifying file descriptor manipulations for unix.io.fcntl"));
	const Int dupFd (name(F_DUPFD), doc("Duplicate file descriptor."));
	// ...
    }

    seekMode
    {
	attribute(doc("Different seek modes for use with the unix.io.seek function"));

	const Int set (name(SEEK_SET), doc("Seek to absolute file offset."));
	const Int cur (name(SEEK_CUR), doc("Seek to file offset relative current position."));
	const Int end (name(SEEK_END), doc("Seek to file offset relative to end of file."));
    }

    def Int fcntlVoid(Int fd, Int cmd) (name(fcntl), alias(fcntl), doc("Manipulate file descriptor."));
    def Int fcntlInt(Int fd, Int cmd, Int arg) (name(fcntl), alias(fcntl), doc("Manipulate file descriptor."));
    def Int fcntlFLock(Int fd, Int cmd, FLock arg) (name(fcntl), alias(fcntl), doc("Manipulate file descriptor."));

    def Int dup(Int fd) (doc("Duplicate a file descriptor."));
    def Int dup2(Int oldfd, Int newfd) (alias(dup), doc("Duplicate a file descriptor."));

    def Int chown(String path, Int owner, Int group) (doc("Change file owner and group."));
    def Int fchown(Int fd, Int owner, Int group) (doc("Change file owner and group."));
    def Int lchown(String path, Int owner, Int group) (doc("Change file owner and group."));

    def Int chmod(String path, Int mode) (doc("Change permissions of a file."));
    def Int fchmod(Int fd, Int mode) (doc("Change permissions of a file."));

    def Int symlink(String oldpath, String newpath) (doc("Create a symbolic link to a file."));
    def Int link(String oldpath, String newpath) (doc("Create anew name for a file."));
    def Int unlink(String path) (doc("Remove a name and possibly a file."));
    def Int rmdir(String path) (doc("Remove a directory."));

    def Int rename(String oldpath, String newpath) (doc("Rename a file."));

    def Int pipe(MutableList«Int» fd (ensureCapacity(2))) (doc("Create a pipe.", "The input and output ends of the pipe are stored in the first two elements of the list fd. If fd is not large enough to hold two elements, it will be enlarged."));

    def UInt64 lseek(Int fd, UInt64 offset, Int whence) (doc("Reposition read/write file offset.")); 

    def Void sync() (doc("Flush file system buffers."));
    def Int fsync(Int fd) (doc("Synchronize a file's in-core state with storage device."));
    def Int fdatasync(Int fd) (doc("Synchronize a file's in-core state with storage device."));

    def Int umask(Int mask) (doc("Set a new value for file mode creation mask and return the old value."));    

    verbatim("
#define ANNA_FD_CLR(set, fd) FD_CLR(fd, set)
#define ANNA_FD_ISSET(set, fd) FD_ISSET(fd, set)
#define ANNA_FD_SET(set, fd) FD_SET(fd, set)

static int anna_fd_set_value(fd_set *set, int fd, int val)
{
    if(val)
    {
        FD_SET(fd, set);
    }
    else
    {
        FD_CLR(fd, set);
    }
    return val;
}
");

    cType FdSet (name(fd_set), doc("A set of file descriptors. Used by unix.io.select."))
    {
	def Void __init__() (name(FD_ZERO), doc("Create an empty new file descriptor set."));
	def Void remove(Int fd) (name(ANNA_FD_CLR), doc("Remove the specified file descriptor from the set."));
	def Int __in__(Int fd) (name(ANNA_FD_ISSET), doc("Check if the specified file descriptor is in the set."));
	def Int __get__(Int fd) (name(ANNA_FD_ISSET), doc("Check if the specified file descriptor is in the set."));
	def Bool __set__(Int fd, Bool value (nullable)) (name(anna_fd_set_value), doc("If value is non-null, add the specified file descriptor to the set. Otherwise, remove it."));
	def Void add(Int fd) (name(ANNA_FD_SET), doc("Add the specified file descriptor to the set."));
	def Void clear() (name(FD_ZERO), doc("Remove all file descriptors from this set."));
    }
    
//    def Int select(Int nfds, FdSet readfds, FdSet writefds, FdSet exceptfds, TimeVal timeout);
    
}

proc
{

    attribute(doc("The unix.proc module contains low level wrappers for basic unix functionality revolving around processes and signals."));

    signal
    {
	attribute(doc("All known signals"));

	const Int hup (name(SIGHUP), doc("The HUP signal"));
	const Int int (name(SIGINT), doc("The INT signal"));
	const Int quit (name(SIGQUIT), doc("The QUIT signal"));
	const Int ill (name(SIGILL), doc("The ILL signal"));
	const Int abrt (name(SIGABRT), doc("The ABRT signal"));
	const Int fpe (name(SIGFPE), doc("The FPE signal"));
	const Int kill (name(SIGKILL), doc("The KILL signal"));
	const Int segv (name(SIGSEGV), doc("The SEGV signal"));
	const Int pipe (name(SIGPIPE), doc("The PIPE signal"));
	const Int alrm (name(SIGALRM), doc("The ALRM signal"));
	const Int term (name(SIGTERM), doc("The TERM signal"));
	const Int usr1 (name(SIGUSR1), doc("The USR1 signal"));
	const Int usr2 (name(SIGUSR2), doc("The USR2 signal"));
	const Int chld (name(SIGCHLD), doc("The CHLD signal"));
	const Int cont (name(SIGCONT), doc("The CONT signal"));
	const Int stop (name(SIGSTOP), doc("The STOP signal"));
	const Int tstp (name(SIGTSTP), doc("The TSTP signal"));
	const Int ttin (name(SIGTTIN), doc("The TTIN signal"));
	const Int ttou (name(SIGTTOU), doc("The TTOU signal"));
	const Int bus (name(SIGBUS), doc("The BUS signal"));
	const Int poll (name(SIGPOLL), doc("The POLL signal"));
	const Int prof (name(SIGPROF), doc("The PROF signal"));
	const Int sys (name(SIGSYS), doc("The SYS signal"));
	const Int trap (name(SIGTRAP), doc("The TRAP signal"));
	const Int urg (name(SIGURG), doc("The URG signal"));
	const Int vtalrm (name(SIGVTALRM), doc("The VTALRM signal"));
	const Int xcpu (name(SIGXCPU), doc("The XCPU signal"));
	const Int xfsz (name(SIGXFSZ), doc("The XFSZ signal"));
	const Int iot (name(SIGIOT), doc("The IOT signal"));
//	const Int emt (name(SIGEMT), doc("The EMT signal"));
	const Int stkflt (name(SIGSTKFLT), doc("The STKFLT signal"));
	const Int io (name(SIGIO), doc("The IO signal"));
	const Int cld (name(SIGCLD), doc("The CLD signal"));
	const Int pwr (name(SIGPWR), doc("The PWR signal"));
//	const Int info (name(SIGINFO), doc("The INFO signal"));
//	const Int lost (name(SIGLOST), doc("The LOST signal"));
	const Int winch (name(SIGWINCH), doc("The WINCH signal"));
	const Int unused (name(SIGUNUSED), doc("The UNUSED signal"));
    }

    def Int exec(String filename, List«String» argv, List«String» envp) (name(execve), doc("Execute the specified program."));
    def Void exit(Int status) (doc("Terminate the calling process."));
    def Int fork() (doc("Create a child process."));
    def Int kill(Int pid, Int sig) (doc("Send a signal to a process."));

    def Int getsid(Int pid) (doc("Get session ID."));
    def Int setsid() (doc("Set session ID."));

    def Int getpid() (doc("Get process ID."));
    def Int getppid() (doc("Get parent process ID."));

    def Int wait(MutableList«Int» status (ensureCapacity(1))) (doc("Wait for a process to change state.")); 
    def Int waitpid(Int pid, MutableList«Int» status (ensureCapacity(1)), Int options) (doc("Wait for a process to change state."));

    verbatim("
static int anna_signalset_set(sigset_t *set, int signal, int value)
{
    if(value)
    {
        sigaddset(set, signal);
    }
    else
    {
        sigdelset(set, signal);
    }
    return value;
}
");

    cType SignalSet (name(sigset_t), doc("A set of signals. Used by the unix.proc.signalfd and unix.proc.sigprocmask functions."))
    {
	def Void __init__() (name(sigemptyset), doc("Create an empty new set"));
	def Int clear() (name(sigemptyset), doc("Remove all signals from the set"));
	def Int all() (name(sigfillset), doc("Add all signals to the set"));
	def Int add(Int signal) (name(sigaddset), doc("Add the specified signal to the set"));
	def Int remove(Int signal) (name(sigdelset), doc("Remove the specified signal from the set."));
	def Bool __in__(Int signal) (name(sigismember), doc("Check if the specified signal is in the set"));
	def Bool __get__(Int signal) (name(sigismember), doc("Check if the specified signal is in the set"));
	def Bool __set__(Int signal, Bool value (nullable)) (name(anna_signalset_set), doc("If value is non-null, add the specified signal to the set. Otherwise, remove it."));
    }

    def Int signalfd(Int fd, SignalSet mask, Int flags) (doc("Create a file descriptor for accepting signals."));

    cStruct SignalInfoFd (name(signalfd_siginfo), doc("A structure describing a recieved signal."))
    {
	var Int signal (name(ssi_signo), doc("Signal number."));
	var Int code (name(ssi_code), doc("Signal code."));
	var Int pid (name(ssi_pid), doc("PID of sender"));
	var Int uid (name(ssi_uid), doc("Real UID of sender"));
	var Int fd (name(ssi_fd), doc("File descriptor for io signal."));
	var Int tid (name(ssi_tid), doc("Kernel timer id for signals relating to Posix timers"));
	var Int band (name(ssi_band), doc("Band event for io signal"));
    }
 
    signalfdFlag
    {
	attribute(doc("Flags determining the mode for unix.proc.signalfd"));

	const Int nonBlock (name(SFD_NONBLOCK), doc("The resulting file descriptor is non-blocking"));
	const Int closeOnExec (name(SFD_CLOEXEC, doc("Close the resulting file descriptor on exec")));
    }
   
    sigprocmaskFlag
    {
	attribute(doc("Flags determining the mode for unix.iosigprocmask"));

	const Int block (name(SIG_BLOCK), doc("Block all the specified signals in addition to signals currently blocked."));
	const Int unblock (name(SIG_UNBLOCK), doc("Stop blocking the specified signals."));
	const Int setMask (name(SIG_SETMASK), doc("Set the exact new signal block mask."));
    }
    
    def Int sigprocmask(Int how, SignalSet set (nullable), SignalSet old (nullable)) (doc("Examine and change what signals are currently blocked by this process."));

    verbatim("
int anna_read_signal(int fd, struct signalfd_siginfo *info)
{
    return read(fd, info, sizeof(struct signalfd_siginfo)) <= 0;
}
");

    def Bool readSignal(Int fd, SignalInfoFd info) (name(anna_read_signal), doc("Read one signal information structure form the specified file descriptor."));    
}

user
{
    attribute(doc("The unix.user module contains low level wrappers for basic unix functionality revolving around users and groups."));

    def Int getuid() (doc("Get the real user ID of the calling process."));
    def Int geteuid() (doc("Get the effective user ID of the calling process."));
    def Int getgid() (doc("Get the real group ID of the calling process."));
    def Int getegid() (doc("Get the effective group ID of the calling process."));

    def Int setuid(Int uid) (doc("Set the effective user ID of the calling process. If the calling user is root, the real user ID is also set."));
    def Int seteuid(Int uid) (doc("Set the effective user ID of the calling process."));
    def Int setegid(Int uid) (doc("Set the effective group ID of the calling process."));
    def Int setgid(Int uid) (doc("Set the effective group ID of the calling process. If the calling user is root, the real group ID is also set."));

    def Int setpgid(Int pid, Int pgid) (doc("Set process group."));
    def Int getpgid(Int pid) (doc("Get process group."));

    def Int getgroups(Int size, MutableList«Int» list (ensureCapacity(size))) (doc("Get list of supplamentary group IDs."));
    def Int setgroups(Int size, MutableList«Int» list (ensureCapacity(size))) (doc("Set list of supplamentary group IDs."));
}

rLimit
{
    
    attribute(doc("The unix.rLimit module contains low level wrappers for basic unix functionality revolving around system resource limits."));

    rLimitMode
    {
        attribute(doc("The different limits that can be queried with getRLimit and stRLimit."));
	const Int as (name(RLIMIT_AS), doc("The AS limit"));
	const Int core (name(RLIMIT_CORE), doc("The CORE limit"));
	const Int cpu (name(RLIMIT_CPU), doc("The CPU limit"));
	const Int data (name(RLIMIT_DATA), doc("The DATA limit"));
	const Int fsize (name(RLIMIT_FSIZE), doc("The FSIZE limit"));
	const Int memlock (name(RLIMIT_MEMLOCK), doc("The MEMLOCK limit"));
	const Int msgqueue (name(RLIMIT_MSGQUEUE), doc("The MSGQUEUE limit"));
	const Int nice (name(RLIMIT_NICE), doc("The NICE limit"));
	const Int nofile (name(RLIMIT_NOFILE), doc("The NOFILE limit"));
	const Int nproc (name(RLIMIT_NPROC), doc("The NPROC limit"));
	const Int rss (name(RLIMIT_RSS), doc("The RSS limit"));
	const Int rtprio (name(RLIMIT_RTPRIO), doc("The RTPRIO limit"));
//	const Int rttime (name(RLIMIT_RTTIME), doc("The RTTIME limit"));
	const Int sigpending (name(RLIMIT_SIGPENDING),doc("The SIGPENDING limit"));
	const Int stack (name(RLIMIT_STACK), doc("The STACK limit"));
    }

    cStruct RLimit (name(rlimit), doc("A structure representing the current and maximum value of a system resource usage limit."))
    {
	const Int cur (name(rlim_cur), doc("Currently enforced limit (soft limit)"));
	const Int max (name(rlim_max), doc("Maximum value of limit (hard limit)"));
    }
    
    def Int getRLimit(Int resource, RLimit rlim) (name(getrlimit), doc("Get resource limit."));
    def Int setRLimit(Int resource, RLimit rlim) (name(setrlimit), doc("Set resource limit."));

}

env
{
    attribute(doc("The unix.env module contains low level wrappers for basic unix functionality revolving around environment variables."));

    def String getenv(String name) (doc("Return the current value of the given environment variable. Equivalanet to the C getenv function."));
    def Int setenv(String name, String value, Int overwrite) (doc("Assign a new value to the environment variable with the given name. Equivalanet to the C setenv function."));
    def Int unsetenv(String name) (doc("Delete the specified environment variable. Equivalanet to the C unsetenv function."));
    def Int clearenv() (doc("Removes all environemnt variables. Equivalanet to the C clearenv function."));
    /*
      Todo:
      
      const List«String» environ;
      
     */
}

sleep
{

    attribute(doc("The unix.sleep module contains low level wrappers for basic unix functionality revolving around pausing the execution of processes."));

    def Int sleep(Int seconds) (doc("Sleep for the specified number of seconds"));
}

time
{

    attribute(doc("The unix.time module contains low level wrappers for basic unix functionality revolving around timekeeping."));

    cStruct TimeVal (name(timeval), doc("A data structure representing a point in time as the amount of time that has elapsed since the epoch."))
    {
	var Int sec (name(tv_sec), doc("Seconds"));
	var Int usec (name(tv_usec), doc("Microseconds."));
    }
    
    cStruct TimeZone (name(timezone), doc("A deprecated data structure that used to be used for representing a time zone."))
    {
    }
    
    def Bool gettimeofday(TimeVal tv, TimeZone tz)  (doc("Gets the current system time. Equivalanet to the C gettimeofday function."));
}

locale
{
    attribute(doc("The unix.locale module contains low level wrappers for basic unix functionality revolving around localization."));

    localeMode
    {
	attribute(doc("Different locale parts."));

	const Int all (name(LC_ALL), doc("All of the locale."));
	const Int collate (name(LC_COLLATE), doc("Regular expression matching (it determines the meaning of range expressions and equivalence classes) and string collation."));
	const Int cType (name(LC_CTYPE), doc("Regular expression matching, character classification, conversion, case-sensitive comparison, and wide character functions."));
	const Int messages (name(LC_MESSAGES), doc("Localizable natural-language messages."));
	const Int monetary (name(LC_MONETARY), doc("Monetary formating."));
	const Int numeric (name(LC_NUMERIC), doc("Numeric formating, such as decimal point and thousands separator."));
	const Int time (name(LC_TIME), doc("Date and time formating."));
    }
    def String setLocale(Int cateory, String locale (nullable)) (name(setlocale), doc("Set the specified local category to the specified value"));
    
    cStructPointer LocaleConv (name(lconv), doc("Detailed local information regarding numeric formating."))
    {
	const String decimalPoint (name(decimal_point), doc("Decimal-point separator used for non-monetary quantities."));
	const String thousandsSeparator (name(thousands_sep), doc("Separators used to delimit groups of digits to the left of the decimal point for non-monetary quantities."));	
	const String grouping (doc("The amount of digits that form each of the groups to be separated by thousandsSeparator separator for non-monetary quantities."));
	const String internationalCurrencySymbol (name(int_curr_symbol), doc("International currency symbol."));
	const String currencySymbol (name(currency_symbol), doc("Local currency symbol."));

	const String monetaryDecimalPoint (name(mon_decimal_point), doc("Decimal-point separator used for monetary quantities."));
	const String monetaryThousandsSeparator (name(mon_thousands_sep), doc("Separators used to delimit groups of digits to the left of the decimal point for monetary quantities."));
	const String monetaryGrouping (name(mon_grouping), doc("The amount of digits that form each of the groups to be separated by monetaryThousandsSeparator separator for monetary quantities."));
	const String positiveSign (name(positive_sign), doc("Sign for positive values"));
	const String negativeSign (name(negative_sign), doc("Sign for negative values"));

	const Int internationalFracDigits (name(int_frac_digits), doc("International fractional digits."));
	const Int fracDigits (name(frac_digits), doc("Local fractional digits."));
	const Bool positiveCurrencySymbolPrecedes (name(p_cs_precedes), doc("1 if currencySymbol precedes a positive value, null if succeeds."));
	const Bool negativeCurrencySymbolPrecedes (name(n_cs_precedes), doc("1 if currencySymbol precedes a negative value, null if succeeds."));
	const Bool positiveSeparateBySpace (name(p_sep_by_space), doc("1 if a space separates currency_symbol from a positive value, null otherwise."));
	const Bool negativeSeparateBySpace (name(n_sep_by_space), doc("1 if a space separates currency_symbol from a negative value, null otherwise."));
	const Int positiveSignPosition (name(p_sign_posn), doc("
Positive and negative sign positions:
<ul>
<li>0: Parentheses surround the quantity and currency_symbol.</li>
<li>1: The sign string precedes the quantity and currency_symbol.</li>
<li>2: The sign string succeeds the quantity and currency_symbol.</li>
<li>3: The sign string immediately precedes the currency_symbol.</li>
<li>4: The sign string immediately succeeds the currency_symbol.</li>
</ul>
"));
	const Int negativeSignPosition (name(n_sign_posn), doc("
Positive and negative sign positions:
<ul>
<li>0: Parentheses surround the quantity and currency_symbol.</li>
<li>1: The sign string precedes the quantity and currency_symbol.</li>
<li>2: The sign string succeeds the quantity and currency_symbol.</li>
<li>3: The sign string immediately precedes the currency_symbol.</li>
<li>4: The sign string immediately succeeds the currency_symbol.</li>
</ul>
"));
    }
    
    def LocaleConv localeConv() (name(localeconv), doc("Get current numeric formatting information."));
    
}

term
{
    attribute(doc("The unix.term module contains low level wrappers for basic unix functionality revolving around terminal handling."));

    flag
    {
        attribute(doc("The different modes of a Termios structure."));
	const Int canonical (name(ICANON), doc("Read one character at a time."));
	const Int echo (name(ECHO), doc("Echo characters to the screen."));
    }
    
    action
    {
        attribute(doc("The different action modes used by unix.term.setAttr."));
	const Int now (name(TCSANOW), doc("Take the specified action now,"));
	const Int drain (name(TCSADRAIN), doc("Empty output buffer and apply specified action."));
	const Int flush (name(TCSAFLUSH), doc("Apply specified action once outout in buffer has been written."));
    }

    cStruct Termios (name(termios), doc("A structure representing the state of a terminal."))
    {
	var Int iflag (name(c_iflag), doc("Input modes"));
	var Int oflag (name(c_oflag), doc("Output modes"));
	var Int cflag (name(c_cflag), doc("Control modes"));
	var Int lflag (name(c_lflag), doc("Local modes"));
    }

    def Bool getAttr(Int fd, Termios ios) (name(tcgetattr), doc("Get the current state of a terminal."));
    def Bool setAttr(Int fd, Int actions, Termios ios) (name(tcsetattr), doc("Set the current state of the terminal."));

}

error
{
    attribute(doc("The unix.error module contains low level wrappers around C functions that revolve around error handling."));
    def String errorString(Int error) (name(strerror), doc("Returns a string that describes the error code passed in the argument. Equivalent to the C strerror function."));
    var Int errno (doc("The latest C library error to occur"));

    status
    {
	attribute(doc("All known error statuses"));
	const Int tooBig (name(E2BIG), doc("Argument list too long."));
	const Int access (name(EACCES), doc("Permission denied."));
	const Int addressInUse (name(EADDRINUSE), doc("Address already in use."));
	const Int addressNotAvailable (name(EADDRNOTAVAIL), doc("Address not available."));
	const Int addressFamilyNotSupported (name(EAFNOSUPPORT), doc("Address family not supported."));
	const Int again (name(EAGAIN), doc("Resource temporarily unavailable (may be the same value as wouldBlock)."));
	const Int alreadyInProgress (name(EALREADY), doc("Connection already in progress."));
	const Int badExchange (name(EBADE), doc("Invalid exchange."));
	const Int badFileDescriptor (name(EBADF), doc("Bad file descriptor."));
	const Int badFileDescriptorState (name(EBADFD), doc("File descriptor in bad state."));    
	const Int badRequest (name(EBADR), doc("Invalid request descriptor."));
	const Int badRequestCode (name(EBADRQC), doc("Invalid request code."));
	const Int badSlot (name(EBADSLT), doc("Invalid slot."));
	const Int deviceBusy (name(EBUSY), doc("Device or resource busy."));
	const Int canceled (name(ECANCELED), doc("Operation canceled."));
	const Int noChild (name(ECHILD), doc("No child processes."));
	const Int channelRange (name(ECHRNG), doc("Channel number out of range."));
	const Int communicationError (name(ECOMM), doc("Communication error on send."));
	const Int connectionAborted (name(ECONNABORTED), doc("Connection aborted."));
	const Int connectionRefused (name(ECONNREFUSED), doc("Connection refused."));
	const Int connectionReset (name(ECONNRESET), doc("Connection reset."));
	const Int deadlock (name(EDEADLK), doc("Resource deadlock avoided."));
	const Int destinationRequired (name(EDESTADDRREQ), doc("Destination address required."));
	const Int domain (name(EDOM), doc("Mathematics argument out of domain of function."));
	const Int diskQuota (name(EDQUOT), doc("Disk quota exceeded."));
	const Int exist (name(EEXIST), doc("File exists."));
	const Int fault (name(EFAULT), doc("Bad address."));
	const Int fileTooBig (name(EFBIG), doc("File too large."));
	const Int hostDown (name(EHOSTDOWN), doc("Host is down."));
	const Int hostUnreachable (name(EHOSTUNREACH), doc("Host is unreachable."));
	const Int identifierRemoved (name(EIDRM), doc("Identifier removed."));
	const Int illegalByteSequence (name(EILSEQ), doc("Illegal byte sequence."));
	const Int inProgress (name(EINPROGRESS), doc("Operation in progress."));
	const Int interrupted (name(EINTR), doc("Interrupted function call."));
	const Int invalid (name(EINVAL), doc("Invalid argument."));
	const Int ioError (name(EIO), doc("Input/output error."));
	const Int connected? (name(EISCONN), doc("Socket is connected."));
	const Int directory? (name(EISDIR), doc("Is a directory."));
	const Int named? (name(EISNAM), doc("Is a named type file."));
	const Int keyExpired (name(EKEYEXPIRED), doc("Key has expired."));
	const Int keyRejected (name(EKEYREJECTED), doc("Key was rejected by service."));
	const Int keyRevoked (name(EKEYREVOKED), doc("Key has been revoked."));
	const Int level2Halted (name(EL2HLT), doc("Level 2 halted."));
	const Int level2NotSynced (name(EL2NSYNC), doc("Level 2 not synchronized."));
	const Int level3Halted (name(EL3HLT), doc("Level 3 halted."));
	const Int level3Reset (name(EL3RST), doc("Level 3 reset."));
	const Int libraryAccess (name(ELIBACC), doc("Cannot access a needed shared library."));
	const Int libraryBad (name(ELIBBAD), doc("Accessing a corrupted shared library."));
	const Int libraryMax (name(ELIBMAX), doc("Attempting to link in too many shared libraries."));
	const Int libraryCorrupt (name(ELIBSCN), doc("lib section in a.out corrupted."));
	const Int libraryExec (name(ELIBEXEC), doc("Cannot exec a shared library directly."));
	const Int loop (name(ELOOP), doc("Too many levels of symbolic links"));
	const Int mediumType (name(EMEDIUMTYPE), doc("Wrong medium type."));
	const Int maxFile (name(EMFILE), doc("Too many open files."));
	const Int maxLink (name(EMLINK), doc("Too many links."));
	const Int messageSize (name(EMSGSIZE), doc("Message too long."));
	const Int multihop (name(EMULTIHOP), doc("Multihop attempted."));
	const Int nameTooLong (name(ENAMETOOLONG), doc("Filename too long."));
	const Int netDown (name(ENETDOWN), doc("Network is down."));
	const Int netReset (name(ENETRESET), doc("Connection aborted by network."));
	const Int netUnreachable (name(ENETUNREACH), doc("Network unreachable."));
	const Int maxFileInSystem (name(ENFILE), doc("Too many open files in system."));
	const Int noBufferSpace (name(ENOBUFS), doc("No buffer space available."));
	const Int noData (name(ENODATA), doc("No message is available on the STREAM head read queue."));
	const Int noDevice (name(ENODEV), doc("No such device."));
	const Int noEntry (name(ENOENT), doc("No such file or directory."));
	const Int noExec (name(ENOEXEC), doc("Exec format error."));
	const Int noKey (name(ENOKEY), doc("Required key not available."));
	const Int noLock (name(ENOLCK), doc("No locks available."));
	const Int noLink (name(ENOLINK), doc("Link has been severed."));
	const Int noMedium (name(ENOMEDIUM), doc("No medium found."));
	const Int noMemory (name(ENOMEM), doc("Not enough space."));
	const Int noMessage (name(ENOMSG), doc("No message of the desired type."));
	const Int noNet (name(ENONET), doc("Machine is not on the network."));
	const Int noPackage (name(ENOPKG), doc("Package not installed."));
	const Int noProtocol (name(ENOPROTOOPT), doc("Protocol not available."));
	const Int noSpace (name(ENOSPC), doc("No space left on device."));
	const Int noStream (name(ENOSR), doc("No STREAM resources."));
	const Int notStream (name(ENOSTR), doc("Not a STREAM."));
	const Int notImplemented (name(ENOSYS), doc("Function not implemented."));
	const Int notBlock (name(ENOTBLK), doc("Block device required."));
	const Int notConnected (name(ENOTCONN), doc("The socket is not connected."));
	const Int notDirectory (name(ENOTDIR), doc("Not a directory."));
	const Int notEmpty (name(ENOTEMPTY), doc("Directory not empty."));
	const Int notSocket (name(ENOTSOCK), doc("Not a socket."));
	const Int notSupported (name(ENOTSUP), doc("Operation not supported."));
	const Int notTty (name(ENOTTY), doc("Inappropriate I/O control operation."));
	const Int notUnique (name(ENOTUNIQ), doc("Name not unique on network."));
	const Int noDeviceOrAddress (name(ENXIO), doc("No such device or address."));
	const Int operationNotSupported (name(EOPNOTSUPP), doc("Operation not supported on socket."));
	const Int overflow (name(EOVERFLOW), doc("Value too large to be stored in data type."));
	const Int permission (name(EPERM), doc("Operation not permitted."));
	const Int protocolFamilyNotSupported (name(EPFNOSUPPORT), doc("Protocol family not supported."));
	const Int pipe (name(EPIPE), doc("Broken pipe."));
	const Int protocolError (name(EPROTO), doc("Protocol error."));
	const Int protocolNotSupported (name(EPROTONOSUPPORT), doc("Protocol not supported."));
	const Int protocolType (name(EPROTOTYPE), doc("Protocol wrong type for socket."));
	const Int range (name(ERANGE), doc("Result too large."));
	const Int remoteAddressChanged (name(EREMCHG), doc("Remote address changed."));
	const Int remote (name(EREMOTE), doc("Object is remote."));
	const Int remoteIo (name(EREMOTEIO), doc("Remote I/O error."));
	const Int restart (name(ERESTART), doc("Interrupted system call should be restarted."));
	const Int readOnly (name(EROFS), doc("Read-only file system."));
	const Int shutdown (name(ESHUTDOWN), doc("Cannot send after transport endpoint shutdown."));
	const Int seekPipe (name(ESPIPE), doc("Invalid seek."));
	const Int socketNotSupported (name(ESOCKTNOSUPPORT), doc("Socket type not supported.")); 
	const Int noSuchProcess (name(ESRCH), doc("No such process."));
	const Int stale (name(ESTALE), doc("Stale file handle. This error can occur for NFS and for other file systems."));
	const Int streamPipe (name(ESTRPIPE), doc("Streams pipe error."));
	const Int timer (name(ETIME), doc("Timer expired."));
	const Int timeout (name(ETIMEDOUT), doc("Connection timed out."));
	const Int textBusy (name(ETXTBSY), doc("Text file busy."));
	const Int unclean (name(EUCLEAN), doc("Structure needs cleaning."));
	const Int unattached (name(EUNATCH), doc("Protocol driver not attached."));
	const Int users (name(EUSERS), doc("Too many users."));
	const Int wouldBlock (name(EWOULDBLOCK), doc("Operation would block (may be same value as again)."));
	const Int improperLink (name(EXDEV), doc("Improper link."));
	const Int exchangeFull (name(EXFULL), doc("Exchange full."));
    }
}

/*
net
{
    attribute(doc("The unix.net module contains low level wrappers for basic unix functionality revolving around network communication."));

    verbatim("
static struct addrinfo *anna_getaddrinfo(const char *node, const char *service, struct addrinfo *hints)
{
    struct addrinfo = 
    int res = 
}

static void anna_addrinfo_del(anna_object_t *victim)
{
    freeaddrinfo(anna_entry_get(victim, ANNA_MID_CSTRUCT_PAYLOAD));
}
");
        
    AddressInfoFlags
    {
	var Int v4Mapped (name(AI_V4MAPPED));
	var Int addressConfig (name(AI_ADDRCONFIG));
    }

    cStructPointer AddressInfo (name(addrinfo), finalizer(anna_addrinfo_del))
    {
	var Int flags (name(ai_flags), doc("Bitwise or of flags from AddressInfoFlags."));
	var Int family (name(ai_family), doc("The desired address family for the returned addresses."));
	var Int socktype (name(ai_socktype), doc("The preferred socket type, for example SOCK_STREAM or SOCK_DGRAM."));
	var Int protocol (name(ai_protocol), doc("The protocol for the returned socket addresses."));
	var Int addrlen (name(ai_addrlen), doc("Length of the socket address"));
//	var SockAddr addr (name(ai_addr), doc(""));
	var String canonname (name(ai_canonname), doc("The official name of the host."));
//	var AddrInfo next (name(ai_next), doc(""));
    }

    def AddressInfo getAddressInfo(String node, String service, AddressInfo hints);

}
*/

include(
    "<sys/types.h>", "<sys/stat.h>", "<unistd.h>", "<fcntl.h>",
    "<sys/time.h>", "<sys/resource.h>", "<signal.h>", "<sys/wait.h>", 
    "<grp.h>", "<stdint.h>", "<poll.h>", "<sys/select.h>");

io
{

    openMode
    {
	const Int readOnly (name(O_RDONLY), doc("Open file in read-only mode."));
	const Int writeOnly (name(O_WRONLY), doc("Open file in write-only mode."));
	const Int readWrite (name(O_RDWR), doc("Open file in read-write mode."));

	const Int append (name(O_APPEND), doc("The file is opened in append mode."));
	const Int async (name(O_ASYNC), doc("Enable signal-driven I/O."));
	const Int create (name(O_CREAT), doc("If the file does not exist it will be created."));
	const Int closeOnExec (name(O_CLOEXEC), doc("Enable the close-on-exec flag for the new file descriptor."));
	const Int direct (name(O_DIRECT), doc("Try to minimize cache effects of the I/O to and from this file."));
	const Int directory (name(O_DIRECTORY), doc("If pathname is not a directory, cause the open to fail."));
	const Int exclusive (name(O_EXCL), doc("Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail."));
	const Int largeFile (name(O_LARGEFILE), doc("(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened."));
	const Int noAccessTime (name(O_NOATIME), doc("Do not update the file last access time (st_atime in the inode) when the file is read()."));
	const Int noControllingTTY (name(O_NOCTTY), doc("If pathname refers to a terminal device - it will not become the process's controlling terminal even if the process does not have one."));
	const Int noFollow (name(O_NOFOLLOW), doc("If pathname is a symbolic link, then the open fails."));
	const Int nonBlock (name(O_NONBLOCK), doc("When possible, the file is opened in nonblocking mode."));
	const Int synchronous (name(O_SYNC), doc("The file is opened for synchronous I/O."));
	const Int truncate (name(O_TRUNC), doc("f the file already exists and is a regular file and the open mode allows writing (i.e., is writeOnly or readWrite) it will be truncated to length 0."));
    }

    statMode
    {
	const Int regular (name(S_IFREG), doc("Regular file"));
	const Int socket (name(S_IFSOCK), doc("Socket"));
	const Int link (name(S_IFLNK), doc("Symbolic link."));
	const Int block (name(S_IFBLK), doc("Block device."));
	const Int directory (name(S_IFDIR), doc("Directory."));
	const Int character (name(S_IFCHR), doc("Character device."));
	const Int fifo (name(S_IFIFO), doc("FIFO."));
    
	const Int suid (name(S_ISUID), doc("Set UID bit."));
	const Int sgid (name(S_ISGID), doc("Set-group-ID bit."));
	const Int sticky (name(S_ISVTX), doc("Sticky bit."));
    
	const Int userAll (name(S_IRWXU), doc("Mask for all file owner permissions."));
	const Int userRead (name(S_IRUSR), doc("File owner read permission."));
	const Int userwrite (name(S_IWUSR), doc("File owner write permission."));
	const Int userExecute (name(S_IXUSR), doc("File owner execute permission."));
    
	const Int groupAll (name(S_IRWXG), doc("Mask for all group permissions."));
	const Int groupRead (name(S_IRGRP), doc("Group has read permission."));
	const Int groupwrite (name(S_IWGRP), doc("Group has write permission."));
	const Int groupExecute (name(S_IXGRP), doc("Group has execute permission."));
    
	const Int otherAll (name(S_IRWXO), doc("Mask for permissions for others (not in group)."));
	const Int otherRead (name(S_IROTH), doc("Others have read permission."));
	const Int otherwrite (name(S_IWOTH), doc("Others have write permission."));
	const Int otherExecute (name(S_IXOTH), doc("Others have execute permission."));
    }

    def Int open(String name, Int flags, Int mode) (doc("Open a file descriptor. Equivalent to the C open function."));
    def Int creat(String name, Int mode) (doc("Open a file descriptor. Equivalent to the C creat function."), alias(create));
    def Int read(Int fd, Buffer buffer(ensureCapacity(count)), Int count) (doc("Read from a file descriptor. Equivalent to the C read function."));
    def Int write(Int fd, Buffer buffer(ensureCapacity(count)), Int count) (doc("Write to a file descriptor. Equivalent to the C write function."));
    def Bool close(Int fd) (doc("Close a file descriptor. Equivalent to the C close function."));

    cStruct Stat (name(stat))
    {
	const Int dev (name(st_dev), doc("ID of device containing file"));
	const Int ino (name(st_ino), doc("Inode number"));
	const Int mode (name(st_mode), doc("File protection mask"));
	const Int nlink (name(st_nlink), doc("Number of hard links."));
	const Int uid (name(st_uid), doc("User ID of owner."));
	const Int gid (name(st_gid), doc("Group ID of owner."));
	const Int rdev (name(st_rdev), doc("Device ID."));
	const Int size (name(st_size), doc("Total size in bytes."));
	const Int blksize (name(st_blksize), doc("Block size for file system IO."));
	const Int blocks (name(st_blocks), doc("Number of 512 byte blocks allocated."));
	const Int atime (name(st_atime), doc("Time of latest acccess."));
	const Int mtime (name(st_mtime), doc("Time of latest modification."));
	const Int ctime (name(st_ctime), doc("Time of latest change."));
    }

    def Bool stat(String path, Stat buf) (doc("Check the status of file with the specified path. Equivalanet to the C stat function."));
    def Bool lstat(String path, Stat buf) (doc("Check the status of file with the specified path, without following symlinks. Equivalanet to the C lstat function."));
    def Bool fstat(Int fd, Stat buf) (doc("Check the status of file with the specified file descriptor. Equivalanet to the C fstat function."));

    def Bool mkdir(String path, Int mode) (doc("Create a new driectory with the specified path. Equivalanet to the C mkdir function."));

    const standardInput (doc("File descriptor for standard input.")) = 0;
    const standardOutput (doc("File descriptor for standard output.")) = 1;
    const standardError(doc("File descriptor for error output")) = 2;

    def Bool getcwd(Buffer buf(ensureCapacity(size)), Int size);
    def Bool chdir(String path);
    def Bool chroot(String path);
    def Bool fchdir(Int fd);

    cStruct FLock (name(flock))
    {
	const Int type (name(l_type), doc("Type of lock: F_RDLCK, F_WRLCK, F_UNLCK."));
	const Int whence (name(l_whence), doc("How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END."));
	const Int start (name(l_start), doc("Starting offset for lock"));
	const Int len (name(l_len), doc("Number of bytes to lock"));
	const Int pid (name(l_pid), doc("PID of process blocking our lock (F_GETLK only)"));
    }

    fcntlMode
    {
	const Int dupFd (name(F_DUPFD));
	// ...
    }

    seekMode
    {
	const Int set (name(SEEK_SET));
	const Int cur (name(SEEK_CUR));
	const Int end (name(SEEK_END));
    }

    def Int fcntl(Int fd, Int cmd);
    def Int fcntlInt(Int fd, Int cmd, Int arg) (name(fcntl), alias(fcntl));
    def Int fcntlFLock(Int fd, Int cmd, FLock arg) (name(fcntl), alias(fcntl));

    def Int dup(Int fd);
    def Int dup2(Int oldfd, Int newfd) (alias(dup));

    def Int chown(String path, Int owner, Int group);
    def Int fchown(Int fd, Int owner, Int group);
    def Int lchown(String path, Int owner, Int group);

    def Int chmod(String path, Int mode);
    def Int fchmod(Int fd, Int mode);

    def Int symlink(String oldpath, String newpath);
    def Int link(String oldpath, String newpath);
    def Int unlink(String path);
    def Int rmdir(String path);    

    def Int rename(String oldpath, String newpath);

    def Int pipe(MutableList«Int» fd (ensureCapacity(2)));

    def UInt64 lseek(Int fd, UInt64 offset, Int whence); 

    def Void sync();
    def Int fsync(Int fd);
    def Int fdatasync(Int fd);

    def Int umask(Int mask);    

    verbatim("
#define ANNA_FD_CLR(set, fd) FD_CLR(fd, set)
#define ANNA_FD_ISSET(set, fd) FD_ISSET(fd, set)
#define ANNA_FD_SET(set, fd) FD_SET(fd, set)
");

    cType FdSet (name(fd_set))
    {
	def Void clear(Int fd) (name(ANNA_FD_CLR));
	def Int set?(Int fd) (name(ANNA_FD_ISSET));
	def Void set(Int fd) (name(ANNA_FD_SET));
	def Void zero() (name(FD_ZERO));
    }
    
//    def Int select(Int nfds, FdSet readfds, FdSet writefds, FdSet exceptfds, TimeVal timeout);
    
}

proc
{
    signal
    {
	const Int hup (name(SIGHUP), doc("The HUP signal"));
	const Int int (name(SIGINT), doc("The INT signal"));
	const Int quit (name(SIGQUIT), doc("The QUIT signal"));
	const Int ill (name(SIGILL), doc("The ILL signal"));
	const Int abrt (name(SIGABRT), doc("The ABRT signal"));
	const Int fpe (name(SIGFPE), doc("The FPE signal"));
	const Int kill (name(SIGKILL), doc("The KILL signal"));
	const Int segv (name(SIGSEGV), doc("The SEGV signal"));
	const Int pipe (name(SIGPIPE), doc("The PIPE signal"));
	const Int alrm (name(SIGALRM), doc("The ALRM signal"));
	const Int term (name(SIGTERM), doc("The TERM signal"));
	const Int usr1 (name(SIGUSR1), doc("The USR1 signal"));
	const Int usr2 (name(SIGUSR2), doc("The USR2 signal"));
	const Int chld (name(SIGCHLD), doc("The CHLD signal"));
	const Int cont (name(SIGCONT), doc("The CONT signal"));
	const Int stop (name(SIGSTOP), doc("The STOP signal"));
	const Int tstp (name(SIGTSTP), doc("The TSTP signal"));
	const Int ttin (name(SIGTTIN), doc("The TTIN signal"));
	const Int ttou (name(SIGTTOU), doc("The TTOU signal"));
	const Int bus (name(SIGBUS), doc("The BUS signal"));
	const Int poll (name(SIGPOLL), doc("The POLL signal"));
	const Int prof (name(SIGPROF), doc("The PROF signal"));
	const Int sys (name(SIGSYS), doc("The SYS signal"));
	const Int trap (name(SIGTRAP), doc("The TRAP signal"));
	const Int urg (name(SIGURG), doc("The URG signal"));
	const Int vtalrm (name(SIGVTALRM), doc("The VTALRM signal"));
	const Int xcpu (name(SIGXCPU), doc("The XCPU signal"));
	const Int xfsz (name(SIGXFSZ), doc("The XFSZ signal"));
	const Int iot (name(SIGIOT), doc("The IOT signal"));
//	const Int emt (name(SIGEMT), doc("The EMT signal"));
	const Int stkflt (name(SIGSTKFLT), doc("The STKFLT signal"));
	const Int io (name(SIGIO), doc("The IO signal"));
	const Int cld (name(SIGCLD), doc("The CLD signal"));
	const Int pwr (name(SIGPWR), doc("The PWR signal"));
//	const Int info (name(SIGINFO), doc("The INFO signal"));
//	const Int lost (name(SIGLOST), doc("The LOST signal"));
	const Int winch (name(SIGWINCH), doc("The WINCH signal"));
	const Int unused (name(SIGUNUSED), doc("The UNUSED signal"));
    }

    def Int exec(String filename, List«String» argv, List«String» envp) (name(execve));
    def Void exit(Int status);
    def Int fork();
    def Int kill(Int pid, Int sig);

    def Int getsid(Int pid);
    def Int setsid();

    def Int getpid();
    def Int getppid();

    def Int wait(MutableList«Int» status (ensureCapacity(1))); 
    def Int waitpid(Int pid, MutableList«Int» status (ensureCapacity(1)), Int options);

}

user
{
    def Int getuid();
    def Int geteuid();
    def Int getgid();
    def Int getegid();

    def Int setuid(Int uid);
    def Int seteuid(Int uid);
    def Int setegid(Int uid);
    def Int setgid(Int uid);

    def Int setpgid(Int pid, Int pgid);
    def Int getpgid(Int pid);

    def Int getgroups(Int size, MutableList«Int» list (ensureCapacity(size)));
    def Int setgroups(Int size, MutableList«Int» list (ensureCapacity(size)));
}

rLimit
{
    
    rLimitMode
    {
	const Int as (name(RLIMIT_AS), doc("The AS limit"));
	const Int core (name(RLIMIT_CORE), doc("The CORE limit"));
	const Int cpu (name(RLIMIT_CPU), doc("The CPU limit"));
	const Int data (name(RLIMIT_DATA), doc("The DATA limit"));
	const Int fsize (name(RLIMIT_FSIZE), doc("The FSIZE limit"));
	const Int memlock (name(RLIMIT_MEMLOCK), doc("The MEMLOCK limit"));
	const Int msgqueue (name(RLIMIT_MSGQUEUE), doc("The MSGQUEUE limit"));
	const Int nice (name(RLIMIT_NICE), doc("The NICE limit"));
	const Int nofile (name(RLIMIT_NOFILE), doc("The NOFILE limit"));
	const Int nproc (name(RLIMIT_NPROC), doc("The NPROC limit"));
	const Int rss (name(RLIMIT_RSS), doc("The RSS limit"));
	const Int rtprio (name(RLIMIT_RTPRIO), doc("The RTPRIO limit"));
//	const Int rttime (name(RLIMIT_RTTIME), doc("The RTTIME limit"));
	const Int sigpending (name(RLIMIT_SIGPENDING),doc("The SIGPENDING limit"));
	const Int stack (name(RLIMIT_STACK), doc("The STACK limit"));
    }

    cStruct RLimit (name(rlimit), doc("A structure representing the current and maximum value of a system resource usage limit."))
    {
	const Int cur (name(rlim_cur), doc("Currently enforced limit (soft limit)"));
	const Int max (name(rlim_max), doc("Maximum value of limit (hard limit)"));
    }

    def Int getRLimit(Int resource, RLimit rlim) (name(getrlimit));
    def Int setRLimit(Int resource, RLimit rlim) (name(setrlimit));

}

env
{
    def String getenv(String name) (doc("Return the current value of the given environment variable. Equivalanet to the C getenv function."));
    def Int setenv(String name, String value, Int overwrite) (doc("Assign a new value to the environment variable with the given name. Equivalanet to the C setenv function."));
    def Int unsetenv(String name) (doc("Delete the specified environment variable. Equivalanet to the C unsetenv function."));
    def Int clearenv() (doc("Removes all environemnt variables. Equivalanet to the C clearenv function."));
    /*
      Todo:

    const List«String» environ;
      
     */
}

sleep
{
    def Int sleep(Int seconds) (doc("Sleep for the specified number of seconds"));
}

time
{
    cStruct TimeVal (name(timeval), doc("A data structure representing a point in time as the amount of time that has elapsed since the epoch."))
    {
	var Int sec (name(tv_sec), doc("Seconds"));
	var Int usec (name(tv_usec), doc("Microseconds."));
    }
    
    cStruct TimeZone (name(timezone), doc("A deprecated data structure that used to be used for representing a time zone."))
    {
    }
    
    def Bool gettimeofday(TimeVal tv, TimeZone tz)  (doc("Gets the current system time. Equivalanet to the C gettimeofday function."));
}


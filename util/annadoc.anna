#! /usr/bin/env anna
use(io);
use(reflection);

expand(template);

var io.File baseDir;
var Int verbose;

def main()
(  
    doc("This it the documentation extractor for the anna language.",
	"It works by iterating over all loaded modules and extracting the doc attribute from all functions, types and members, and formatting them into html documents.",
	"Future work should include prettier styling, search functionality, handling of internal members including the option to hide internal members."))
{
    baseDir = io.File("documentation/api");
    verbose = system.argument[1] == "-v";
    doc := DocumentationExtractor();
    doc.document(global);
    print(
	"Documented % namespaces with % members, out of which % (% %%) were documented\n" % [
	    doc.moduleTot, doc.memberTot, doc.memberTot-doc.memberMissing, 
	    Int::convert(100 * (1 -(Float::convert(doc.memberMissing) / doc.memberTot)))]);  
    io.File("documentation/index.html").writeFile(template("util/document/index.html"));
}

def toggleCodePopup(String name, String text )
{
    return "<a href='javascript: void(0);' onclick='javascript:anna.togglePopup(\"#anna-%-toggle\");'>%</a>" % [name, text];
}

def codePopup(String name, String filename)
{
    return "
	  <div class='anna-code-popup' id='anna-%-toggle' style='display: none;'>
	    <div class='anna-code-popup-inner'>
              <span class='anna-code-popup-close'>X</span>
              <h3>Source code for %</h3>
	      <pre class='anna-code'>%</pre>
	    </div>
	  </div>
" % [name, filename, html.escape(File(filename).readFile())];

}

class DocumentationData
(doc("Data about a specific type that should be documented."))
{
    // The type to document
    var Type object; 
    // The parent item of this item
    var DocumentationData parent; 
    // Set to true once documentation for this item has been written to disk
    var Int done; 

    def __init__(Type object, DocumentationData parent)
    {
	this.object = object;
	this.parent = parent;
	done = ?;
    }

    def String link(DocumentationData from) 
    (doc("Create a link suitable for a html anchor tag from some other document to the document for this type"))
    {
	if(!from)
	{
	    return ?;
	}
        res := "".thaw;
	(0..from.steps).each(i){ res ~= "../" }
	return res ~ path() ~ ".html";
    }

    def String linkPath(DocumentationData from = ?)
    (doc("Create a html anchor from some other document to this document"))
    {
        prev := (parent.linkPath(from or this) ~ ".") or "";
	return prev ~ if(from) {
	    "<a href='%'>%</a>" % [link(from), object.name];
	} else {
	    "<em>%</em>" % [object.name]
	}
    }

    def String path()
	(doc("The search path for this document"))
    {
	return ((parent.path() ~ "/") or "") ~ object.name;
    }

    def File file() (property)
    {
	directory ~ (object.name ~ ".html");
    }

    def File directory() (property)
    {
	if(parent) {parent.directory ~ parent.object.name} else {baseDir}
    }
    
    def Int steps() (property)
    {
	return (parent.steps + 1) or 0;
    }
    
}

class DocumentationExtractor
(
    doc("
A tool for extracting the documentation from modules and generating an
HTML manual based on it. Currently very incomplete, and needs
significant additions to the reflection API before it can be
completed, but is a nice proof of concept and exercises various less
often used code paths, which makes it useful for regression testing.")
)
{

    var HashMap«Type, DocumentationData» path;
    var Int memberMissing;
    var Int memberTot;
    var Int moduleMissing;
    var Int moduleTot;

    def __init__()
    {
	baseDir.makeDirectory();
	path = HashMap«Type, DocumentationData»();
	memberMissing = memberTot = moduleMissing = moduleTot = 0;
    }
    
    def extractDocumentation(parser.Call attr)
    (
	internal
    )
    {
        res := "".thaw;
	attr.each(at)
	{
	    if(at.callTo?("doc"))
	    {
		switch((at as parser.Call)[0])
		{
		    case(str as parser.StringLiteral)
		    {
			res ~= str.payload;
			res ~= "<p>";
		    }
		}
	    }
	}
	if(res.count > 0){res}else{?}
    }
    
    def String getLink(Type from, Type to)
    {
       "<a href='%'>%</a>" % [path[to].link(path[from]), to.name];
    }

    def String getSignature(reflection.Member mem)
    {
        fun := mem.value(?) as Function;
	if(fun)
	{
	  argv := ", ".join(
	      fun.inputType.map(idx, t)
	      {
		  "%(type) %(name)%(default)" % ["type": getLink(mem.memberOf, t), "name": fun.inputName[idx], "default": (if(fun.defaultValue[idx]){" = " ~ fun.defaultValue[idx]}else{""})]
	      });
	    "def % <em>%</em> (%);" % [getLink(mem.memberOf, fun.outputType), fun.name, argv];
	} else {
	    "var % <em>%</em>;" % [getLink(mem.memberOf, mem.type), mem.name];
	}
    }

    def documentMember(reflection.Member mem)
    {
	memberTot++;
        doc := extractDocumentation(mem.attribute) or extractDocumentation((mem.value(?) as Function).attribute) or "";
	if(doc == "")
	{
	    verbose and print("Missing documentation for member %.%\n" % [mem.memberOf.name, mem.name]);
	    memberMissing++;
	}

	"
<a name='%'>%</a>
<br>
%

" % [mem.name, getSignature(mem), doc];
    }
    
    def document(Object module)
    {
	lookup(module.__type__, ?);
	this.writeFile(module.__type__);
    }

    def Object lookup(Type module, Type parent)
    {
	if(module in path)
	{
	    return;
	}
        parentData := path[parent];

	path[module] = DocumentationData(module, parentData);
	path[module].directory.makeDirectory();

	module.member.each(mem)
	{
	    if(mem.isStatic)
	    {
  	        val := mem.value(?);
		if(val.__type__.isModule)
		{
		    lookup(module: val.__type__, parent: module);
		}
		if(val as Type and module.isModule)
		{
		    lookup(module: val as Type, parent: module);
		}
	    }
	}
    }

    def Object writeFile(Type module)
    {
	moduleTot++;
	if(!(module in path)){ return }
        data := path[module];
	if(data.done){return}
	data.done=1;
        memb := module.member;
	if(module.isModule)
	{
  	    objMemb := «String, Member»[];
	    Object.member.each(mem){objMemb[mem.name] = mem}
	    memb = memb.filter(mem){!(mem.name in objMemb)}
	}
        smemb := memb.sort(def Int(Object first, Object second){(first as Member).name.__cmp__((second as Member).name)}).map(memb){memb as Member};
	
        submodule := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.isStatic and val.__type__.isModule;
	}
        subtype := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.isStatic and (val as Type);
	}
        subother := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.isStatic and (!(val.__type__.isModule) and !(val as Type) and (mem.type != Null));
	}
        basePath := "/".join((0..data.steps+1).map(i){".."}) ~ "/";
	data.file.writeFile(template("util/document/module.html"));
	
	submodule.each(mem)
	{
	    val := mem.value(?);
	    writeFile(val.__type__);
	}
	subtype.each(mem)
	{
	    val := mem.value(?);
	    writeFile(val as Type);
	}
    }
}


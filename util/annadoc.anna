#! /usr/bin/env anna
use(io);
use(reflection);

expand(template);

var io.File baseDir;
var Int verbose;
var HashMap«String, Operator» operatorLookup;

def main()
(  
    doc("This it the documentation extractor for the anna language.",
	"It works by iterating over all loaded modules and extracting the doc attribute from all functions, types and members, and formatting them into html documents.",
	"Future work should include prettier styling, search functionality, handling of internal members including the option to hide internal members."))
{
    operatorLookup = [
	"__get__": Operator("[]", "Get elements of collection"),
	"__set__": Operator("[]", "Set elements of collection"),
	"__add__": Operator("+", "Addition"),
	"__sub__": Operator("-", "Subtraction"),
	"__mul__": Operator("*", "Multiplication"),
	"__div__": Operator("/", "Division"),
	"__neg__": Operator("-", "Negation"),
	"__format__": Operator("%", "Formating"),
	"__in__": Operator("in", "Check if element is in collection"),
	"__join__": Operator("~", "Join two collections into one"),
	"__appendAssign__": Operator("~=", "Append one collection into another"),
	"__increaseAssign__": Operator("+=", "Increase"),
	"__decreaseAssign__": Operator("-=", "Decrease"),
	"__nextAssign__": Operator("++", "Move to next element"),
	"__prevAssign__": Operator("--", "Move to previous element"),
	"__not__": Operator("!", "Boolean negation"),
	];
    
    baseDir = io.File("documentation/api");
    verbose = system.argument[1] == "-v";
    doc := DocumentationExtractor();
    doc.document(global);
    print(
	"Documented % namespaces with % members, out of which % (% %%) were documented" % [
	    doc.moduleTot, doc.memberTot, doc.memberTot-doc.memberMissing, 
	    Int::convert(100 * (1 -(Float::convert(doc.memberMissing) / doc.memberTot)))]);  
    io.File("documentation/index.html").writeFile(template("util/document/index.html"));
}

def toggleCodePopup(String name, String text )
{
    return "<a href='javascript: void(0);' onclick='javascript:anna.togglePopup(\"#anna-%-toggle\");'>%</a>" % [name, text];
}

def codePopup(String name, String filename)
{
    return "
	  <div class='anna-code-popup' id='anna-%-toggle' style='display: none;'>
	    <div class='anna-code-popup-inner'>
              <span class='anna-code-popup-close'>X</span>
              <h3>Source code for %</h3>
	      <pre class='anna-code'>%</pre>
	    </div>
	  </div>
" % [name, filename, html.escape(File(filename).readFile())];

}

class DocumentationData
(doc("Data about a specific type that should be documented."))
{
    // The type to document
    var Type object; 
    // The parent item of this item
    var DocumentationData parent; 
    // Set to true once documentation for this item has been written to disk
    var Int done; 

    def __init__(Type object, DocumentationData parent)
    {
	this.object = object;
	this.parent = parent;
	done = ?;
    }

    def String link(DocumentationData from) 
    (doc("Create a link suitable for a html anchor tag from some other document to the document for this type"))
    {
	if(!from)
	{
	    return ?;
	}
        res := "".thaw;
	(0..from.steps).each(i){ res ~= "../" }
	return res ~ path() ~ ".html";
    }

    def String linkPath(DocumentationData from = ?)
    (doc("Create a html anchor from some other document to this document"))
    {
        prev := (parent.linkPath(from or this) ~ ".") or "";
	return prev ~ if(from) {
	    "<a href='%'>%</a>" % [link(from), object.name];
	} else {
	    "<em>%</em>" % [object.name]
	}
    }

    def String path()
	(doc("The search path for this document"))
    {
	return ((parent.path() ~ "/") or "") ~ object.name;
    }

    def File file() (property)
    {
	directory ~ (object.name ~ ".html");
    }

    def File directory() (property)
    {
	if(parent) {parent.directory ~ parent.object.name} else {baseDir}
    }
    
    def Int steps() (property)
    {
	return (parent.steps + 1) or 0;
    }
    
}

struct Operator
{

    var String name;
    var String description;

    def documentMember(reflection.Member mem)
    {
	return "This method is usually called as the % operator." % [name];
    }
    
}

class DocumentationExtractor
(
    doc("
A tool for extracting the documentation from modules and generating an
HTML manual based on it. Currently very incomplete, and needs
significant additions to the reflection API before it can be
completed, but is a nice proof of concept and exercises various less
often used code paths, which makes it useful for regression testing.")
)
{

    var HashMap«Type, DocumentationData» path;
    var Int memberMissing;
    var Int memberTot;
    var Int moduleMissing;
    var Int moduleTot;

    def __init__()
    {
	baseDir.makeDirectory();
	path = HashMap«Type, DocumentationData»();
	memberMissing = memberTot = moduleMissing = moduleTot = 0;
    }
    
    def extractDocumentation(parser.Call attrList, Object brief = ?)
    (
	internal
    )
    {
        res := "".thaw;
	attrList.each(attr)
	{
	    if(attr.callTo?("doc"))
	    {
		(attr as parser.Call).each(docItem)
		{
		    switch(docItem)
		    {
			case(str as parser.StringLiteral)
			{
			    if(brief)
			    {
				return str.payload;
			    }
			    res ~= "<p>%</p>\n\n" % [str.payload];
			}
		    }
		}
	    }
	}
	if(res.count > 0){res}else{?}
    }
    
    def String getLink(Type from, Type to)
    {
       "<a href='%'>%</a>" % [path[to].link(path[from]), to.name];
    }

    def String getAttribute(reflection.Member mem)
    {
        res := [];

	if(mem.internal?)
	{
	    res.push("internal");
	}

	if(mem.bound?)
	{
	    res.push("bound");
	}
	else
	{
	    if(mem.static?)
	    {
		res.push("static");
	    }
	}
	
	res.empty? and (return "");
	return " (" ~ ", ".join(res) ~ ")";
    }

    def String getSignature(reflection.Member mem)
    {
        fun := mem.value(?) as Function;
	"" ~ (if(fun)
	{
	    variadicIndex := fun.variadic? and fun.inputType.count-1;
	    variadicNamedIndex := fun.variadicNamed? and (fun.inputType.count-1);
	    if(variadicIndex)
	    {
		variadicNamedIndex--;
	    }
	    argv := ", ".join(
		fun.inputType.map(idx, t)
		{
		    variadicStr := "";
		    if(idx == variadicIndex)
		    {
			variadicStr ~= "...";
		    }		    
		    if(idx == variadicNamedIndex)
		    {
			getMemb := t.member.find(memb){memb.name=="__get__"} as Method;
			t = getMemb.function.outputType;
			variadicStr ~= ":";
		    }
		    
		    "%(type) %(name)%(variadic)%(default)" % 
		    [
			"type": getLink(mem.memberOf, t), 
			"name": fun.inputName[idx],
			"default": (if(fun.defaultValue[idx]){" = " ~ fun.defaultValue[idx]}else{""}),
			"variadic": variadicStr,
			];
		});
	    "def % <em>%</em> (%)" % [getLink(mem.memberOf, fun.outputType), fun.name, argv];
	} else {
	    "var % <em>%</em>" % [getLink(mem.memberOf, mem.type), mem.name];
	}) ~ getAttribute(mem) ~ ";"
    }

    def headerForModule(Object module)
    {
	return (" - " ~ (extractDocumentation(module.__type__.attribute, 1))) or "";
    }

    def headerForType(Type type)
    {
	return (" - " ~ (extractDocumentation(type.attribute, 1))) or "";
    }

    def headerForMember(reflection.Member mem)
    {
	return (" - " ~ (extractDocumentation(mem.attribute, 1) or extractDocumentation((mem.value(?) as Function).attribute, 1))) or "";
    }

    def documentMember(reflection.Member mem)
    {
	memberTot++;
        doc := extractDocumentation(mem.attribute) or extractDocumentation((mem.value(?) as Function).attribute) or "";
	if(doc == "")
	{
	    verbose and print("Missing documentation for member %.%" % [mem.memberOf.name, mem.name]);
	    memberMissing++;
	}
        htmlClass := if(mem.internal?){"class='anna-internal'"} else {""};
	"
<span %>
<hr>
<a name='%'>%</a>
<br>
%
</span>
" % [htmlClass, mem.name, getSignature(mem), doc];
    }
    
    def documentFunction(reflection.Member mem)
    {
	memberTot++;

	        doc := extractDocumentation(mem.attribute) or extractDocumentation((mem.value(?) as Function).attribute) or "";

	opDoc := "".thaw;
	alias := annaUtil.findAttribute(
	    mem.attribute or (mem.value(?) as Function).attribute, "alias");

	(alias.map(a){a.toString()}.thaw ~ [mem.name]).each(name)
	{
	    if(name in operatorLookup)
	    {
		opDoc ~= "<p>";
		opDoc ~= operatorLookup[name].documentMember(mem);
		opDoc ~= "</p>";
	    }	    
	}

	if(doc == "")
	{
	    verbose and print("Missing documentation for member %.%" % [mem.memberOf.name, mem.name]);
	    memberMissing++;
	}
        htmlClass := if(mem.internal?){"class='anna-internal'"} else {""};
	"
<span %>
<hr>
<a name='%'>%</a>
<br>
%
%
</span>
" % «String»[htmlClass, mem.name, getSignature(mem), opDoc, doc];
    }
    
    def document(Object module)
    {
	lookup(module.__type__, ?);
	this.writeFile(module.__type__);
    }

    def Object lookup(Type module, Type parent)
    {
	if(module in path)
	{
	    return;
	}
        parentData := path[parent];

	path[module] = DocumentationData(module, parentData);
	path[module].directory.makeDirectory();

	module.member.each(mem)
	{
	    if(mem.static?)
	    {
  	        val := mem.value(?);
		if(val.__type__.module?)
		{
		    lookup(module: val.__type__, parent: module);
		}
		if(val as Type and module.module?)
		{
		    lookup(module: val as Type, parent: module);
		}
	    }
	}
    }

    def Object writeFile(Type module)
    {
	moduleTot++;
	if(!(module in path)){ return }
        data := path[module];
	if(data.done){return}
	data.done=1;
        memb := module.member;
	if(module.module?)
	{
  	    objMemb := «String, Member»[];
	    Object.member.each(mem){objMemb[mem.name] = mem}
	    memb = memb.filter(mem){!(mem.name in objMemb)}
	}
        smemb := memb.sort(def Int(Object first, Object second){(first as Member).name.__cmp__((second as Member).name)}).map(memb){memb as Member};
	
        submodule := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.static? and val.__type__.module?;
	}
        subtype := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.static? and (val as Type);
	}

	subfun := smemb.filter(mem)
	{
	    val := mem.value(?);
	    (mem as Method) or (val as Function);
	}

	opMap := «String, MutableList«Member»»[];
	subfun.each(mem)
	{
	    val := mem.value(?);

	    alias := annaUtil.findAttribute(
		((mem as Method) or (val as Function)).attribute,
		"alias");
	    (alias.map(a){a.toString()}.thaw ~ [mem.name]).each(name)
	    {
		if(name in operatorLookup)
		{
		    if(!(name in opMap)){
			opMap[name] = [mem];
		    }
		    else
		    {
			opMap[name].push(mem);
		    }
		}
	    }
	}
	subop := opMap.map(key, el){key | el}.sort(def Int(Object first, Object second){(first as Pair).first.__cmp__((second as Pair).first)}).map(memb){memb as Pair«String, MutableList«Member»»};

        subother := smemb.filter(mem)
	{
	    val := mem.value(?);
	    !(val.__type__.module?) and !(val as Type) and (mem.type != Null) and !(mem as Method) and !(val as Function);
	}

	

        basePath := "/".join((0..data.steps+1).map(i){".."}) ~ "/";
	data.file.writeFile(template("util/document/module.html"));
	
	submodule.each(mem)
	{
	    val := mem.value(?);
	    writeFile(val.__type__);
	}
	subtype.each(mem)
	{
	    val := mem.value(?);
	    writeFile(val as Type);
	}
    }
}


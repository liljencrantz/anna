#! /usr/bin/env anna
use(io)
use(reflection)

expand(template)

var io.File baseDir
var Int verbose
var HashMap«String, Operator» operatorLookup
var HashMap«String, MutableList«String»» keywordLookup
var HashMap«String, MutableList«String»» wordLookup

def compress(HashMap«String,HashMap«String, MutableList«String»»» src) {
    itemLookup :== «String, Int»[]
    itemCode :== «String»[]
    idx := 0
    lines :== «String»[]
    res := "".thaw

    src.each(name, map) {
	map.each(key, value) {
	    line := json.to(key).thaw
	    line ~= ": ["
	    links := «String»[]
	    value.each(link){
		if (!(link in itemLookup)){
		    itemLookup[link] = idx
		    itemCode.push(json.to(link))
		    idx++
		}
		links.push(/="v[%()]"=/ % [itemLookup[link]])
	    }
	    line ~= ",".join(links)
	    line ~= "]"
	    lines.push(line)
	}
	res ~= "%() = {\n\t" % [name]
	res ~= ",\n\t".join(lines)
	res ~= "};\n"
    }

    return /="
var v = [
	%()];
%()
delete v;
"=/ % [",\n\t".join(itemCode), res]
}

def main() (  
    doc(
	"This it the documentation extractor for the anna language."
	"It works by iterating over all loaded modules and extracting the doc attribute from all functions, types and members, and formatting them into html documents."
	)){
    operatorLookup = [
	"__get__": Operator("[]", "Get elements of collection")
	"__set__": Operator("[]", "Set elements of collection")
	"__add__": Operator("+", "Addition")
	"__sub__": Operator("-", "Subtraction")
	"__mul__": Operator("*", "Multiplication")
	"__div__": Operator("/", "Division")
	"__neg__": Operator("-", "Negation")
	"__format__": Operator("%", "Formating")
	"__in__": Operator("in", "Check if element is in collection")
	"__join__": Operator("~", "Join two collections into one")
	"__appendAssign__": Operator("~=", "Append one collection into another")
	"__increaseAssign__": Operator("+=", "Increase")
	"__decreaseAssign__": Operator("-=", "Decrease")
	"__nextAssign__": Operator("++", "Move to next element")
	"__prevAssign__": Operator("--", "Move to previous element")
	"__not__": Operator("!", "Boolean negation")
	]

    keywordLookup = «String, MutableList«String»»[]
    wordLookup = «String, MutableList«String»»[]
    
    baseDir = io.File("documentation/api")
    verbose = system.argument[1] == "-v"
    doc := DocumentationExtractor()
    doc.document(global)
    print(
	"Documented %() namespaces with %() members, out of which %() (%() %) were documented" % [
	    doc.moduleTot, doc.memberTot, doc.memberTot-doc.memberMissing, 
	    Int::convert(100 * (1 -(Float::convert(doc.memberMissing) / doc.memberTot)))])  
    io.File("documentation/index.html").writeFile(template("util/documentation/index.html"))

    wordListHeader :== "// This file was autogenerated by the annadoc utility.
// It is used by the search box."
    wordListBody :== compress([
	"anna.keywordList": keywordLookup
	"anna.wordList": filterWordLookup(wordLookup)])
    io.File("documentation/js/wordList.js").writeFile(wordListHeader ~ wordListBody)
}

def filterWordLookup(HashMap«String, MutableList«String»» input){
    res := «String, MutableList«String»»[]
    input.each(key, value) {
	if(value.count < 40) {
	    res[key] = value
	}
    }
    return res
}

def toggleCodePopup(String name, String text ){
    return "<a href='javascript: void(0);' onclick='javascript:anna.togglePopup(\"#anna-%()-toggle\");'>%()</a>" % [name, text]
}

def codePopup(String name, String filename){
    return "
	  <div class='anna-code-popup' id='anna-%()-toggle' style='display: none'>
	    <div class='anna-code-popup-inner'>
              <span class='anna-code-popup-close'>X</span>
              <h3>Source code for %()</h3>
	      <pre class='anna-code'>%()</pre>
	    </div>
	  </div>
" % [name, filename, html.escape(File(filename).readFile())]

}

class DocumentationData (
    doc("Data about a specific type that should be documented.")){
    // The type to document
    var Type object 
    // The parent item of this item
    var DocumentationData parent 
    // Set to true once documentation for this item has been written to disk
    var Int done 

    def __init__(Type object, DocumentationData parent){
	this.object = object
	this.parent = parent
	done = ?
    }

    def String link(DocumentationData from)  (doc("Create a link suitable for a html anchor tag from some other document to the document for this type")){
	if(!from){
	    return ?
	}
        res := "".thaw
	(0..from.steps).each(i){ res ~= "../" }
	return res ~ path() ~ ".html"
    }

    def String linkConnector(){
	if(object.module?) {"."} else { "::" }
    }

    def String linkPath(DocumentationData from = ?, Int last = 1) (doc("Create a html anchor from some other document to this document")){

        prev :== (parent.linkPath(from or this, ?) ~ parent.linkConnector()) or ""
	classString := if(last){" class='anna-link-main'"} else {""}
	return prev ~ if(from) {
	    "<a href='%()'%()>%()</a>" % [link(from), classString, object.name]
	} else {
	    "<em%()>%()</em>" % [classString, object.name]
	}
    }

    def String path() (doc("The search path for this document")){
	return ((parent.path() ~ "/") or "") ~ object.name
    }

    def File file() (property){
	directory ~ (object.name ~ ".html")
    }

    def File directory() (property){
	if(parent) {parent.directory ~ parent.object.name} else {baseDir}
    }
    
    def Int steps() (property){
	return (parent.steps + 1) or 0
    }

    def __cmp__(Any other){
	return object.name.__cmp__((other as DocumentationData).object.name)
    }
    
}

struct Operator{

    var String name
    var String description

    def documentMember(reflection.Member mem){
	return "This method is usually called as the %() operator." % [name]
    }
    
}

class DocumentationExtractor (
    doc("
A tool for extracting the documentation from modules and generating an
HTML manual based on it. Currently very incomplete, and needs
significant additions to the reflection API before it can be
completed, but is a nice proof of concept and exercises various less
often used code paths, which makes it useful for regression testing.")
){

    var HashMap«Type, DocumentationData» path
    var Int memberMissing
    var Int memberTot
    var Int moduleMissing
    var Int moduleTot

    def __init__(){
	baseDir.makeDirectory()
	path = HashMap«Type, DocumentationData»()
	memberMissing = memberTot = moduleMissing = moduleTot = 0
    }
    
    def extractDocumentation(parser.Call attrList, Any brief = ?) (
	internal
    ){
        res := "".thaw
	attrList.each(attr){
	    if(attr.callTo?("doc")){
		(attr as parser.Call).each(docItem){
		    switch(docItem){
			case(str as parser.StringLiteral){
			    if(brief){
				return str.payload
			    }
			    res ~= "<p>%()</p>\n\n" % [str.payload]
			}
		    }
		}
	    }
	}
	if(res.count > 0){res} else {?}
    }

    def filterHtml(String input) {
      res := "".thaw
      isTag := ? as Int
      input.each(ch) {
	  if(isTag) {
	      if(ch == '>') {
		  isTag = ?
	      }
	  } else {
	      if(ch == '<') {
		  isTag = 1
	      } else {
		  res ~= ch
	      }
	  }	  
      }
      return res	
    }
    
    def split(String input) {
        res := «String»[]
        item := "".thaw
	input.each(ch) {
	    if(ch.alnum?) {
		item ~= ch
	    } else {
		res ~= [item.lower]
		item = "".thaw
	    }
	}
	res ~= [item.lower]
	return res.filter(el){
	    el.count > 2
	}
    }
    
    def String getLink(Type from, Type to){
	href := path[to].link(path[from])
	return if(href) {
	    "<a href='%()'>%()</a>" % [path[to].link(path[from]), html.escape(to.name)]
	} else {
	    html.escape(to.name)
	}
    }

    def String getAttribute(reflection.Member mem){
        res := []

	if(mem.internal?){
	    res.push("internal")
	}

	if(mem.bound?){
	    res.push("bound")
	} else {
	    if(mem.static?){
		res.push("static")
	    }
	}

	alias := annaUtil.findAttribute(
	    mem.attribute or (mem.value(?) as Function).attribute, "alias")
	res ~= alias.map(name) { "alias(%())" % [name]}
	res.empty? and (return "")
	return " (" ~ ", ".join(res) ~ ")"
    }

    def String getSignature(reflection.Member mem){
        fun := mem.value(?) as Function
	"" ~ (if(fun){
	    variadicIndex := fun.variadic? and fun.inputType.count-1
	    variadicNamedIndex := fun.variadicNamed? and (fun.inputType.count-1)
	    if(variadicIndex){
		variadicNamedIndex--
	    }
	    argv := ", ".join(
		fun.inputType.map(idx, t){
		    variadicStr := ""
		    if(idx == variadicIndex){
			variadicStr ~= "..."
		    }		    
		    if(idx == variadicNamedIndex){
		        getMemb := (t.member.find(memb){memb.name=="__get__"}) as Method
			t = getMemb.function.outputType
			variadicStr ~= ":"
		    }
		    
		    "%(type) %(name)%(variadic)%(default)" % [
			"type": getLink(mem.memberOf, t), 
			"name": fun.inputName[idx],
			"default": (if(fun.defaultValue[idx]){" = " ~ fun.defaultValue[idx]} else {""}),
			"variadic": variadicStr,
			]
		})
	    if(fun.macro?){
		"macro %() <em>%()</em> (%())" % [getLink(mem.memberOf, fun.outputType), fun.name, argv]
	    } else {
		"def %() <em>%()</em> (%())" % [getLink(mem.memberOf, fun.outputType), fun.name, argv]
	    }
	} else {
		  "%() %() <em>%()</em>" % [(if(mem.mutable?){"var"} else {"const"}), getLink(mem.memberOf, mem.type), mem.name]
	}) ~ getAttribute(mem) ~ ""
    }

    def headerForModule(Any module){
	return (" - " ~ (extractDocumentation(type(module).attribute, 1))) or ""
    }

    def headerForType(Type type){
	return (" - " ~ (extractDocumentation(type.attribute, 1))) or ""
    }

    def headerForMember(reflection.Member mem){
	return (" - " ~ (extractDocumentation(mem.attribute, 1) or extractDocumentation((mem.value(?) as Function).attribute, 1))) or ""
    }

    def documentMember(reflection.Member mem){
	memberTot++
        doc := extractDocumentation(mem.attribute) or extractDocumentation((mem.value(?) as Function).attribute) or ""
	if(doc == "" and mem.name[0] != '!'){
	    verbose and print("Missing documentation for member %().%()" % [mem.memberOf.name, mem.name])
	    memberMissing++
	}
        htmlClass := if(mem.internal?){"class='anna-internal'"} else {""}
	"
<span %()>
<hr>
<a name='%()'></a>%()
<br>
%()
</span>
" % [htmlClass, mem.name, getSignature(mem), doc]
    }
    
    def documentFunction(reflection.Member mem){
	memberTot++

        doc := extractDocumentation(mem.attribute) or extractDocumentation((mem.value(?) as Function).attribute) or ""

	opDoc := "".thaw
	alias := annaUtil.findAttribute(
	    mem.attribute or (mem.value(?) as Function).attribute, "alias")

	(alias.map(a){a.toString()}.thaw ~ [mem.name]).each(name){
	    if(name in operatorLookup){
		opDoc ~= "<p>"
		opDoc ~= operatorLookup[name].documentMember(mem)
		opDoc ~= "</p>"
	    }	    
	}
	if(doc == "" and mem.name[0] != '!'){
	    verbose and print("Missing documentation for function %().%()" % [mem.memberOf.name, mem.name])
	    memberMissing++
	}

	aliasDoc := ""
	if(!alias.empty?){
	    aliasDoc = "<code>%()</code> can also be called using any of the following aliases: %()." % [mem.name, ", ".join(alias.map(a){"<code>" ~ a ~ "</code>"})]
	}

        htmlClass := if(mem.internal?){"class='anna-internal'"} else {""}
	"
<span %()>
<hr>
<a name='%()'></a>%()
<p>
%()
%()
%()
</span>
" % «String»[htmlClass, mem.name, getSignature(mem), aliasDoc, opDoc, doc]
    }
    
    def document(Any module){
	lookup(type(module), ?)
	this.writeFile(type(module))
    }

    def lookupPath(Type module, Member member) {
	value :== (member.static? and (member.value(?)))
	if((value as Type) or member.type.module?) {
	    path[module].link(path[type(global)])[0..-5] ~ "/" ~ member.name ~ ".html"
	} else {
	    path[module].link(path[type(global)]) ~ "#" ~ member.name
	}
    }

    def Any lookup(Type module, Type parent){
	if(module in path){
	    return
	}
        parentData :== path[parent]

	path[module] = DocumentationData(module, parentData)
	path[module].directory.makeDirectory()

	module.member.each(mem){
	    attr :== mem.attribute or (mem.value(?) as Function).attribute
	    alias :== annaUtil.findAttribute(attr, "alias")
	    memLookupPath :== lookupPath(module, mem)
	    (alias.map(a){a.toString()}.thaw ~ [mem.name]).each(casedName){
	        name :== casedName.lower
		if(!(name in keywordLookup)){
		    keywordLookup[name] = «String»[]
		}
		keywordLookup[name].push(memLookupPath)
	    }

	    doc :== extractDocumentation(attr)
	    docWords :== split(filterHtml(doc))
	    
	    docWords.each(word) {
		if(!(word in wordLookup)){
		    wordLookup[word] = «String»[]
		}
		if (!(memLookupPath in wordLookup[word])) {
		    wordLookup[word].push(memLookupPath)
		}
	    }
	    
	    
	    if(mem.static?){
  	        val :== mem.value(?)
		if(type(val).module?){
		    lookup(module: type(val), parent: module)
		}
		if(val as Type){
		    lookup(module: val as Type, parent: module)
		}
	    }
	}
    }

    def Any writeFile(Type module){
	moduleTot++
	if(!(module in path)){ return }
        data :== path[module]
	if(data.done){return}
	data.done=1
        memb := module.member

	compat := ""
	if(module.module?){
  	    objMemb :== «String, Member»[]
	    Any.member.each(mem){objMemb[mem.name] = mem}
	    memb = memb.filter(mem){!(mem.name in objMemb)}
	} else {
	    def formatCompatList(List«DocumentationData» compat){
		sorted := algo.qsortComp(compat.thaw)
		return "<span class='anna-compat'>%()</span>" % [", ".join(sorted.map(dd){dd.linkPath(data)})]
	    }
	    
	    sub :== path.map(dd){dd}.filter(dd){dd.object.abides(module) and !(dd.object in [Null, module])}
	    paren :== path.map(dd){dd}.filter(dd){module.abides(dd.object) and !(dd.object in [Null, module])}
	    if(!sub.empty?){
		
		compat ~= "<h3><a name='module-child'>Types that can mask as this type</a></h3>\n"
		compat ~= formatCompatList(sub)
	    }
	    if(!paren.empty?){
		
		compat ~= "<h3><a name='module-child'>Types that this module can mask as</a></h3>\n"
		compat ~= formatCompatList(paren)
	    }
	}

        smemb :== algo.qsort(
	    memb.thaw, 
	    fieldComparator(Member::name))
	
        submodule :== smemb.filter(mem){
	    val :== mem.value(?)
	    mem.static? and type(val).module?
	}
        subtype :== smemb.filter(mem){
	    val :== mem.value(?)
	    mem.static? and (val as Type)
	}

	subfun :== smemb.filter(mem){
	    val :== mem.value(?)
	    (mem as Method) or (val as Function)
	}

	opMap :== «String, MutableList«Member»»[]
	funMap :== «String, MutableList«Member»»[]
	subfun.each(mem){
	    val :== mem.value(?)

	    alias :== annaUtil.findAttribute(
		mem.attribute or (mem.value(?) as Function).attribute, "alias")


	    (alias.map(a){a.toString()}.thaw ~ [mem.name]).each(name){
		if(name in operatorLookup){
		    if(!(name in opMap)){
			opMap[name] = [mem]
		    } else {
			opMap[name].push(mem)
		    }
		}
		
		if(!(name in funMap)){
		    funMap[name] = [mem]
		} else {
		    funMap[name].push(mem)
		}
	    }
	}
	subop :== algo.qsort(
	    opMap.map(key, el){key | el}, 
	    fieldComparator(Pair«String, MutableList«Member»»::first))

	subfun2 :== algo.qsort(
	    funMap.map(key, el){key | el},
	    fieldComparator(Pair«String, MutableList«Member»»::first))

        subother :== smemb.filter(mem){
	    val :== mem.value(?)
	    !(type(val).module?) and !(val as Type) and (mem.type != Null) and !(mem as Method) and !(val as Function)
	}

	

        basePath :== "/".join((0..data.steps+1).map(i){".."}) ~ "/"
	data.file.writeFile(template("util/documentation/module.html"))
	
	submodule.each(mem){
	    val :== mem.value(?)
	    writeFile(type(val))
	}
	subtype.each(mem){
	    val :== mem.value(?)
	    writeFile(val as Type)
	}
    }
}


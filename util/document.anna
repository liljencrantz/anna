use(io);
use(reflection);

expand(template);

var io.File baseDir;

type DocumentationData
{
    var Type object;
    var DocumentationData parent;
    var Int done;

    def __init__(Type object, DocumentationData parent)
    {
	this.object = object;
	this.parent = parent;
	done = ?;
    }

    def String link(DocumentationData from)
    {
	if(!from)
	{
	    return ?;
	}
        res := "".thaw;
	(0..from.steps).each(i){ res ~= "../" }
	return res ~ path() ~ ".html";
    }

    def String linkPath(DocumentationData from = ?)
    {
        prev := (parent.linkPath(from or this) ~ ".") or "";
	return prev ~ if(from) {
	    "<a href='%'>%</a>" % [link(from), object.name];
	} else {
	    "<em>%</em>" % [object.name]
	}
    }

    def String path()
    {
	return ((parent.path() ~ "/") or "") ~ object.name;
    }

    def File fileGetter()
    {
	directory ~ (object.name ~ ".html");
    }
    var File file (property(fileGetter));

    def File directoryGetter()
    {
	if(parent) {parent.directory ~ parent.object.name} else {baseDir}
    }
    var File directory (property(directoryGetter));
    
    def Int stepsGetter()
    {
	return (parent.steps + 1) or 0;
    }
    var Int steps (property(stepsGetter));
    
}

type DocumentationExtractor
(
    document("
A tool for extracting the documentation from modules and generating an
HTML manual based on it. Currently very incomplete, and needs
significant additions to the reflection API before it can be
completed, but is a nice proof of concept and exercises various less
often used code paths, which makes it useful for regression testing.")
)
{

    var HashMap«Type, DocumentationData» path;
    var Int memberMissing;
    var Int memberTot;
    var Int moduleMissing;
    var Int moduleTot;

    def __init__()
    {
	baseDir.makeDirectory();
	path = HashMap«Type, String»();
	memberMissing = memberTot = moduleMissing = moduleTot = 0;
    }
    
    def extractDocumentation(parser.Call attr)
    (
	internal
    )
    {
        res := "".thaw;
	attr.each(at)
	{
	    if(at.isCallTo("documentation"))
	    {
		switch((at as parser.Call)[0])
		{
		    case(str as parser.StringLiteral)
		    {
			res ~= str.payload;
			res ~= "<p>";
		    }
		}
	    }
	}
	if(res.count > 0){res}else{?}
    }
    
    def String getLink(Type from, Type to)
    {
       "<a href='%'>%</a>" % [path[to].link(path[from]), to.name];
    }

    def String getSignature(reflection.Member mem)
    {
        fun := mem.value(?) as Function;
	if(fun)
	{
	  argv := ", ".join(
	      fun.inputType.map(idx, t)
	      {
		  "%(type) %(name)%(default)" % ["type": getLink(mem.memberOf, t), "name": fun.inputName[idx], "default": if(fun.defaultValue[idx]){" = " ~ fun.defaultValue[idx]}else{""}]
	      });
	    "def % <em>%</em> (%);" % [getLink(mem.memberOf, fun.outputType), fun.name, argv];
	} else {
	    "var % <em>%</em>;" % [getLink(mem.memberOf, mem.type), mem.name];
	}
    }

    def documentMember(reflection.Member mem)
    {
	memberTot++;
        doc := extractDocumentation(mem.attribute) or extractDocumentation((mem.value(?) as Function).attribute) or "";
	if(doc == "")
	{
	    print("Missing documentation for member %.%\n" % [mem.memberOf.name, mem.name]);
	    memberMissing++;
	}

	"
<a name='%'>%</a>
<br>
%

" % [mem.name, getSignature(mem), doc];
    }
    
    def document(Object module)
    {
	lookup(module.__type__, ?);
	this.writeFile(module.__type__);
    }

    def lookup(Type module, Object parent)
    {
	if(module in path)
	{
	    return;
	}
        parentData := path[parent];

	path[module] = DocumentationData(module, parentData);
	path[module].directory.makeDirectory();

	module.member.each(mem)
	{
	    if(mem.isStatic)
	    {
  	        val := mem.value(?);
		if(val.__type__.isModule)
		{
		    lookup(module: val.__type__, parent: module);
		}
		if(val as Type and module.isModule)
		{
		    lookup(module: val as Type, parent: module);
		}
	    }
	}
    }

    def writeFile(Type module)
    {
	moduleTot++;
	if(!(module in path)){ return }
        data := path[module];
	if(data.done){return}
	data.done=1;

        submodule := module.member.filter(mem)
	{
	    val := mem.value(?);
	    mem.isStatic and val.__type__.isModule;
	}
        subtype := module.member.filter(mem)
	{
	    val := mem.value(?);
	    mem.isStatic and (val as Type);
	}
        subother := module.member.filter(mem)
	{
	    val := mem.value(?);
	    mem.isStatic and (!(val.__type__.isModule) and !(val as Type) and (mem.type != Null));
	}

	data.file.writeFile(template("util/document/module.html"));

	module.member.each(mem)
	{
	    if(mem.isStatic)
	    {
  	        val := mem.value(?);
		if(val.__type__.isModule)
		{
		    writeFile(val.__type__);
		}
		if(val as Type)
		{
		    writeFile(val as Type);
		}
	    }
	}
    }
}

def main()
{
    baseDir = io.File("documentation");
    doc := DocumentationExtractor();
    doc.document(global);
    File("documentation/js").makeDirectory();
    File("util/document(jquery.js").copyTo(File("documentation/js/jquery.js"));
    print(
	"Documented % namespaces with % members, out of which % (% %%) where documented\n" % [
	    doc.moduleTot, doc.memberTot, doc.memberTot-doc.memberMissing, 
	    Int::convert(100 * (1 -(Float::convert(doc.memberMissing) / doc.memberTot)))]);  
}

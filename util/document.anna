use(io);
expand(template);

type DocumentationExtractor
(
    document("
A tool for extracting the documentation from modules and generating an
HTML manual based on it. Currently very incomplete, and needs
significant additions to the reflection API before it can be
completed, but is a nice proof of concept and exercises various less
often used code paths, which makes it useful for regression testing.")
)
{

    var io.File baseDir (internal);
    var HashMap«Object, String» pathLookup;

    def __init__()
    {
	baseDir = io.File("documentation");
	baseDir.makeDirectory();
	pathLookup = HashMap«Object, String»();
    }
    
    def extractDocumentation(parser.Call attr)
    (
	internal
    )
    {
        res := "".thaw;
	attr.each(at)
	{
	    if(at.isCallTo("documentation"))
	    {
		switch((at as parser.Call)[0])
		{
		    case(str as parser.StringLiteral)
		    {
			res ~= str.payload;
			res ~= "<p>";
		    }
		}
	    }
	}
	return res;
    }
    
    def String getLink(Type typ)
    {
	"<a href='../%'>%</a>" % [pathLookup[typ], typ.__name__];

    }

    def String getSignature(reflection.Member mem)
    {
	switch(mem)
	{
	    case(meth as reflection.Method)
	    {
	      fun := meth.function;
	      argv := ", ".join(
		  fun.inputType.map(idx, t)
		  {
		      "% %" % [getLink(t), fun.inputName[idx]]
		  });
		"def % % (%)" % [getLink(fun.outputType), fun.__name__, argv];
	    }
	    default
	    {
		"var % %" % [getLink(mem.type), mem.__name__];
	    }
	}
    }

    def documentMember(reflection.Member mem)
    {
        doc := extractDocumentation(mem.__attribute__);
	"
<a name='%'>%</a>
<br>
%

" % [mem.__name__, getSignature(mem), doc];
    }
    
    def documentType(Type type, File dir)
    {
        file := dir ~ (type.__name__ ~ ".html");
	file.writeFile(template("util/document/type.html"));
    }
    
    def documentModule(Object module)
    {
        file := baseDir ~ (module.__type__.__name__ ~ ".html");
        dir  := baseDir ~ module.__type__.__name__;
	dir.makeDirectory();

	module.__type__.__member__.each(mem)
	{
	    if(mem.isConstant and mem.isStatic)
	    {
  	        val := mem.value(?);
		switch(val)
		{
		    case(t as Type)
		    {
			pathLookup[t] = module.__type__.__name__ ~ "/" ~ t.__name__ ~ ".html";
		    }
		}
	    }
	}
	
	file.writeFile(template("util/document/module.html"));

	module.__type__.__member__.each(mem)
	{
	    if(mem.isConstant and mem.isStatic)
	    {
  	        val := mem.value(?);
		switch(val)
		{
		    case(t as Type)
		    {
			documentType(t, dir);
		    }
		}
	    }
	}
    }
}

def main()
{
    doc := DocumentationExtractor();
    doc.documentModule(lang);
}

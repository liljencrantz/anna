use(io);
use(reflection);

expand(template);

var io.File baseDir;

type DocumentationData
{
    var Type object;
    var DocumentationData parent;
    var Int done;

    def __init__(Type object, DocumentationData parent)
    {
	this.object = object;
	this.parent = parent;
	done = ?;
    }

    def String link(DocumentationData from)
    {
	if(!from)
	{
	    return ?;
	}
        res := "".thaw;
	(0..from.steps).each(i){ res ~= "../" }
	return res ~ path() ~ ".html";
    }

    def String linkPath(DocumentationData from = ?)
    {
        prev := (parent.linkPath(from or this) ~ ".") or "";
	return prev ~ if(from) {
	    "<a href='%'>%</a>" % [link(from), object.__name__];
	} else {
	    "<em>%</em>" % [object.__name__]
	}
    }

    def String path()
    {
	return ((parent.path() ~ "/") or "") ~ object.__name__;
    }

    def File fileGetter()
    {
	directory ~ (object.__name__ ~ ".html");
    }
    var File file (property(fileGetter));

    def File directoryGetter()
    {
	if(parent) {parent.directory ~ parent.object.__name__} else {baseDir}
    }
    var File directory (property(directoryGetter));
    
    def Int stepsGetter()
    {
	return (parent.steps + 1) or 0;
    }
    var Int steps (property(stepsGetter));
    
}

type DocumentationExtractor
(
    document("
A tool for extracting the documentation from modules and generating an
HTML manual based on it. Currently very incomplete, and needs
significant additions to the reflection API before it can be
completed, but is a nice proof of concept and exercises various less
often used code paths, which makes it useful for regression testing.")
)
{

    var HashMap«Type, DocumentationData» path;

    def __init__()
    {
	baseDir.makeDirectory();
	path = HashMap«Type, String»();
    }
    
    def extractDocumentation(parser.Call attr)
    (
	internal
    )
    {
        res := "".thaw;
	attr.each(at)
	{
	    if(at.isCallTo("documentation"))
	    {
		switch((at as parser.Call)[0])
		{
		    case(str as parser.StringLiteral)
		    {
			res ~= str.payload;
			res ~= "<p>";
		    }
		}
	    }
	}
	return res;
    }
    
    def String getLink(Type from, Type to)
    {
       "<a href='%'>%</a>" % [path[to].link(path[from]), to.__name__];
    }

    def String getSignature(reflection.Member mem)
    {
	switch(mem)
	{
	    case(meth as reflection.Method)
	    {
	      fun := meth.function;
	      argv := ", ".join(
		  fun.inputType.map(idx, t)
		  {
		      "% %" % [getLink(mem.memberOf, t), fun.inputName[idx]]
		  });
		"def % <em>%</em> (%);" % [getLink(mem.memberOf, fun.outputType), fun.__name__, argv];
	    }
	    default
	    {
		"var % <em>%</em>;" % [getLink(mem.memberOf, mem.type), mem.__name__];
	    }
	}
    }

    def documentMember(reflection.Member mem)
    {
        doc := extractDocumentation(mem.__attribute__);
	"
<a name='%'>%</a>
<br>
%

" % [mem.__name__, getSignature(mem), doc];
    }
    
    def documentType(Type type, File dir)
    {
        file := dir ~ (type.__name__ ~ ".html");
	file.writeFile(template("util/document/type.html"));
    }

    def document(Object module)
    {
	lookup(module.__type__, ?);
	this.writeFile(module.__type__);
    }

    def lookup(Type module, Object parent)
    {
	if(module in path)
	{
	    return;
	}
        parentData := path[parent];

	path[module] = DocumentationData(module, parentData);
	path[module].directory.makeDirectory();

	module.__member__.each(mem)
	{
	    if(mem.isStatic)
	    {
  	        val := mem.value(?);
		if(val.__type__.isModule)
		{
		    lookup(module: val.__type__, parent: module);
		}
		if(val as Type and module.isModule)
		{
		    lookup(module: val as Type, parent: module);
		}
	    }
	}
    }

    def writeFile(Type module)
    {
	if(!(module in path)){ return }
        data := path[module];
	if(data.done){return}
	data.done=1;
	
	data.file.writeFile(template("util/document/module.html"));

	module.__member__.each(mem)
	{
	    if(mem.isStatic)
	    {
  	        val := mem.value(?);
		if(val.__type__.isModule)
		{
		    writeFile(val.__type__);
		}
		if(val as Type)
		{
		    writeFile(val as Type);
		}
	    }
	}
    }
}

def main()
{
    baseDir = io.File("documentation");
    doc := DocumentationExtractor();
    doc.document(global);
}

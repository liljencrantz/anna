#! /usr/bin/env anna
use(io)
use(parser)
use(error)

attribute(
    doc(
	"
This is the Anna binding compiler. Unlike many other binding
generators, this one doesn't parse C headers at all. Instead, the
binding creator has to write headers that contain roughly the same
information as traditional C headers, but expressed in a syntax that
is very easy to parse. This is a pretty simple solution, and it
means more work in order to get things up and running. But on the
plus side, it avoids the often significant amount of hand holding
required in order to get C header files to behave well enough in
order to let them be parsed. It should also be noted that aside from
the obvious problems with finding a good strategy for mixing GC:ed
and non-GC:ed objects, there is very little to prevent this strategy
from working perfectly well with C++ bindings as well.",
	"
The bind utility simply outputs a C file that should be compiled into a
dynamic library and placed in the Anna library search path. On startup,
Anna will automatically locate the library and load it as needed.",
	"
Basic function declarations look like this:",
	"
def Int foo(Int x, Buffer y)",
	"
this is equivalent to the following C header:",
	"
int foo(int x, char *y);",
	"
  The following basic types are built in:",
	"
  * Int: maps to the regular Anna Int. Should be used for all integer types of the C 'int' of the platform.
  * UInt: maps to the regular Anna Int. Should be used for all integer types of the C 'unsigned int' of the platform.
  * Float: maps to the regular Anna Float. Should be used for the C 'float' type.
  * Double: maps to the regular Anna Float. Should be used for the C 'double' type.
  * Buffer: maps to a memory region. Should be used for various array data.
  * List«X»: Maps to a list of items. X needs to be another basic type, potentially including another list. When a List is given as an output type, it will need annotations to inform the binder of the vector size, see below.
  * MutableList«X»: Maps to a list of items. X needs to be another basic type, potentially including another list. When a List is given as an output type, it will need annotations to inform the binder of the vector size, see below. The values of the MutableList type can be changed by the call, but the list length must not be changed.
  * cStructs from the same module (including other submodules in the same module) are usable as types
  * Bool: maps to the regular Anna Int. Should be used in situations where the return value is either 0, which will map to the Anna null value, or non-zero, which will map to the integer 1",
	"
  The following additional types are planned:",
	"
  * Short, UShort, Long, ULong, Char, UChar, Int32, UInt32, Int64, UInt64.
  * Void: Only available as a return type. A function which returns nothing. Will be translated into a function of return type Any and return value null.
  * Pointer«X»: Opaque pointer value. Opaque pointers can not be used inside of any except for sending them as parameters to other functions. Pointers can be recast as any other pointer type. 
  * FloatVector, IntVector, etc. Maps to a list of numbers. When a List is given as an output type, it will need annotations to inform the binder of the vector size.",
	"
  cStruct information:",
	"
  TODO",
	"
  Constants:",
	"
  TODO",
"
   Code-wise, this program is a mess. It's a quick and dirty proof of
   concept that has grown into a semi-complicated application with
   very little in the way of refactoring. The code needs to be split
   into multiple multiple files using a bit of templating.
",

))

def main() { 
    init()
    
    system.argument[1...].each(binding) {
	if(!File(binding).exists?) {
	    print("Error: File «%()» does not exist" % [binding])
	    unix.proc.exit(1)
	}
	BindingGenerator(binding).generate()
    }    
}

def cEscape(String in) {
    in or (return "0")
  res := "L\"".thaw
    in.each(ch) {
	switch(ch.ordinal) {
	    case('\n'.ordinal) {
		res ~= "\\n"
	    }
	    case('"'.ordinal) {
		res ~= "\\\""
	    }
	    cases(0..32) {
		res ~= "\\x" ~ ch.ordinal.format(16).lpad(count: 2, char: '0')
	    }
	    cases(128...) {
		res ~= "\\u" ~ ch.ordinal.format(16).lpad(count: 4, char: '0')
	    }
	    default {
		res ~= ch
	    }
	}
    }
    res ~= "\""
    return res
}

tempCounter := 0
def generateTempName() {
    tempCounter++
    "tmp_var_" ~ tempCounter
}

def extractDoc(Call attr) {
    cEscape((attr.filterByCall("doc")[0] as StringLiteral).payload)
}

def extractDocAll(Call attr) {
    attr.filterByCall("doc").map(el){cEscape((el as StringLiteral).payload)}
}

def init() {
    bindingType = [
	ast(Void): BasicBindingType(
	    ?,
	    "any_type", 
	    ?,
	    "    %(source);\n    anna_entry_t %(dest) = null_entry;\n",
	    ),
	ast(String): BasicBindingType(
	    "char *",
	    "string_type", 
	    "    char *%(dest) = anna_entry_null(%(source)) ? 0 : anna_string_payload_narrow(anna_as_obj(%(source)));\n",
	    "    anna_entry_t %(dest) = (%(source)) ? anna_from_obj(anna_string_create_narrow(strlen(%(source)), %(source))) : null_entry;\n",
	    cleanupToC: "    free(%(dest));\n"),
	ast(Int): BasicBindingType(
	    "int",
	    "int_type",
	    "    int %(dest) = anna_as_int(%(source));\n",
	    "    anna_entry_t %(dest) = anna_from_int(%(source));\n"),
	ast(Char): BasicBindingType(
	    "char",
	    "char_type",
	    "    char %(dest) = wctob(anna_as_char(%(source)));\n",
	    "    anna_entry_t %(dest) = anna_from_char(btowc(%(source)));\n"),
	ast(Bool): BasicBindingType(
	    "int",
	    "any_type", 
	    "    int %(dest) = !anna_entry_null(%(source));\n",
	    "    anna_entry_t %(dest) = (%(source))?anna_from_int(1):null_entry;\n",
	    preValidateToC: ""),
	ast(UInt64): BasicBindingType(
	    "uint64_t",
	    "int_type", 
	    "    uint64_t %(dest) = anna_as_int(%(source));\n",
	    "    anna_entry_t %(dest) = anna_from_uint64(%(source));\n"),
	ast(Float): BasicBindingType(
	    "float",
	    "float_type", 
	    "    float %(dest) = (float)anna_as_float(%(source));\n",
	    "    anna_entry_t %(dest) = anna_from_float((double)%(source));\n"),
	ast(Double): BasicBindingType(
	    "double",
	    "float_type", 
	    "    double %(dest) = anna_as_float(%(source));\n",
	    "    anna_entry_t %(dest) = anna_from_float(%(source));\n"),
	ast(Complex): BasicBindingType(
	    "double complex",
	    "complex_type", 
	    "    complex double %(dest) = anna_as_complex(%(source));\n",
	    "    anna_entry_t %(dest) = anna_from_complex(%(source));\n"),
	/*  ast(Pointer): BasicBindingType(
	    "void *",
	    "pointer_type", 
	    "void *%(dest) = anna_entry_get_addr(anna_as_obj(%(source)), ANNA_MID_POINTER_PAYLOAD);",
	    "anna_entry_t %(dest) = anna_from_obj(anna_pointer_create(%(source)));"),*/
	ast(Buffer): BasicBindingType(
	    "unsigned char *",
	    "buffer_type", 
	    "    unsigned char *%(dest) = anna_buffer_get_payload(anna_as_obj(%(source)));\n",
	    ?,
	    capacityCheck: "    if(anna_buffer_ensure_capacity(anna_as_obj(%(source)), %(capacity))) 
    {
        return null_entry;
    }
    else
    {
        %(dest) = anna_buffer_get_payload(anna_as_obj(%(source)));
    }\n"),
	ast(List): ListBindingType(),
	ast(MutableList): MutableListBindingType(),
	]
}

var HashMap«Node, BindingType» bindingType

def getBindingType(Node node) {
    return bindingType[node] or bindingType[(node as Call)[0]]
}

error ParseError {
    var Node node
    var String message

    def __init__(Node node, String message) {
	this.node=node
	this.message=message
    }

}

class BindingType (
    doc("Base class for the types used in the bindings.",
	"A BindingType is used to convert from data from Anna objects into C data and back. They also need to be able to validate the data and to cleanup any memory used in the conversion process.")
) {
    def String annaNativeType(Node decl, Node attr) (doc("The C type that this BindingType handles")) {}

    def String annaCType(Node decl, Node attr) (doc("The anna_type_t * of the type that this BindingType handles")) {}

    def String convertToC(Node decl, Node attr, String dest, String source) (doc("Convert the anna_entry_t  pointed to by source into C data in the (newly declared) variable named by dest")) {}

    def String convertToAnna(Node decl, Node attr, String dest, String source) (doc("Convert the C data pointed to by source into an anna_entry_t  in the (newly declared) variable named by dest")) {}
    
    def String cleanupToC(Node decl, Node attr, String dest, String source) (doc("Perform any cleanup needed after a anna => C conversion. This is run after the C function has been run")) {}
    
    def String cleanupToAnna(Node decl, Node attr, String dest, String source) (doc("")) {}
    
    def String preValidateToC(Node decl, Node attr, String dest, String source) (doc("Perform validation of the specified conversion to C.")){
	if(!(attr as Call).childNamed?("nullable")) {
	    "    if(anna_entry_null(%())){return null_entry;}\n" % [source]
	}
    }
    
    
    def String postValidateToC(Node decl, Node attr, String dest, String source) (doc("Perform validation of the specified conversion to C.")) {""}
    
    def String preValidateToAnna(Node decl, Node attr, String dest, String source) (doc("Perform validation of the specified conversion to anna.")) {""}

    def String postValidateToAnna(Node decl, Node attr, String dest, String source) (doc("Perform validation of the specified conversion to anna.")) {""}
}

class ListBindingType (
    extends(BindingType), 
    doc("A BindingType implementation used for read-only lists"),) {

    def String annaNativeType(Node decl, Node attr){
        subType := ((decl as Call)[1] as Call)[0]
        subBinding := getBindingType(subType)
	return subBinding.annaNativeType(subType, ?) ~"*"
    }

    def String annaCType(Node decl, Node attr){
      subType := ((decl as Call)[1] as Call)[0]
      subBinding := getBindingType(subType)
	return "anna_list_type_get_any(%())" % [subBinding.annaCType(subType, ?)]
    }

    def String convertToC(Node decl, Node attr, String dest, String source){
        subType := ((decl as Call)[1] as Call)[0]
        subBinding := getBindingType(subType)
        subTypeNative := subBinding.annaNativeType(subType, ?)
	
	return "    size_t %(szName) = anna_list_get_count(anna_as_obj(%(source)));
    %(subTypeNative)* %(dest) = malloc(sizeof(%(subTypeNative)) * %(szName));
    if(!%(dest)){ return null_entry; }
    int %(dest)_idx;
    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        %(conversion)
        %(dest)[%(dest)_idx] = %(dest)_val;
    }\n" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
            "conversion": subBinding.convertToC(subType, ?, dest ~ "_val", "anna_list_get(anna_as_obj(%()), %())" % [source, dest ~ "_idx"])
            ]
    }

    def String convertToAnna(Node decl, Node attr, String dest, String source){
	?
    }

    def String cleanupToC(Node decl, Node attr, String dest, String source) {	
        subType := ((decl as Call)[1] as Call)[0]
        subBinding := getBindingType(subType)
        subTypeNative := subBinding.annaNativeType(subType, ?)
	return "    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        %(subCleanup)
    }
    free(%(dest));\n" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
            "subCleanup": subBinding.cleanupToC(subType, ?, dest ~ "["~dest~"_idx]", "anna_list_get(anna_as_obj(%()), %()" % [source, dest ~ "_idx"])
            ]
    }

    def String cleanupToAnna(Node decl, Node attr, String dest, String source){	

    }

}

class MutableListBindingType (
    extends(BindingType), 
    doc("A BindingType used for mutable lists.")
) {

    def String annaNativeType(Node decl, Node attr){
        subType := ((decl as Call)[1] as Call)[0]
        subBinding := getBindingType(subType)
	return subBinding.annaNativeType(subType, ?) ~"*"
    }

    def String annaCType(Node decl, Node attr){
      subType := ((decl as Call)[1] as Call)[0]
      subBinding := getBindingType(subType)
	return "anna_list_type_get_mutable(%())" % [subBinding.annaCType(subType, ?)]
    }

    def String convertToC(Node decl, Node attr, String dest, String source){
        subType := ((decl as Call)[1] as Call)[0]
        subBinding := getBindingType(subType)
        subTypeNative := subBinding.annaNativeType(subType, ?)
	
        res := "".thaw

        annaUtil.findAttribute(attr as Call, "ensureCapacity").each(cap) {
	    capStr := switch(cap) {
		case(capId as Identifier) {
		    BindingGenerator::getNativeParamName(capId.name)
		}
		case(capNum as IntLiteral) {
		    String::convert(capNum.payload)
		}
	    }
	    res ~= "    if(anna_list_ensure_capacity(anna_as_obj(%(source)), %(capacity)))
    {
        return null_entry;
    }\n" % ["source": source, "capacity": capStr]
	}

	res ~= "    size_t %(szName) = anna_list_get_count(anna_as_obj(%(source)));
    %(subTypeNative)* %(dest) = malloc(sizeof(%(subTypeNative)) * %(szName));
    if(!%(dest)){ return null_entry; }
    int %(dest)_idx;
    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        anna_entry_t tmp = %(value);
        if(anna_entry_null(tmp))
        {
            %(dest)[%(dest)_idx] = 0;
        }
        else
        {
            %(conversion)
            %(dest)[%(dest)_idx] = %(dest)_val;
        }
    }\n" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
            "conversion": subBinding.convertToC(subType, ?, dest ~ "_val", "tmp"),
	    "value": "anna_list_get(anna_as_obj(%()), %())" % [source, dest ~ "_idx"],
	    
            ]

	return res
    }

    def String convertToAnna(Node decl, Node attr, String dest, String source){
	?
    }
    def String cleanupToC(Node decl, Node attr, String dest, String source) {	
        subType := ((decl as Call)[1] as Call)[0]
        subBinding := getBindingType(subType)
        subTypeNative := subBinding.annaNativeType(subType, ?)
	return "    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        %(value)
        anna_list_set(anna_as_obj(%(source)), %(dest)_idx, tmp);
        %(subCleanup)
    }
    free(%(dest));\n" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
	    "value": subBinding.convertToAnna(subType, ?, "tmp", "%(dest)[%(dest)_idx]" % ["dest": dest]),
            "subCleanup": subBinding.cleanupToC(subType, ?, dest ~ "["~dest~"_idx]", "anna_list_get(anna_as_obj(%()), %()" % [source, dest ~ "_idx"])
            ]
    }

    def String cleanupToAnna(Node decl, Node attr, String dest, String source){	

    }

}

class BasicBindingType (
    extends(BindingType), 
    doc("A very simple BindingType implementation that simply relies on string templates to perform its tasks. Works well for basic types like Int, String, etc."),
) {
    var String annaNativeTypeStr
    var String annaCTypeStr
    var String convertToCStr
    var String convertToAnnaStr
    var String cleanupToCStr
    var String cleanupToAnnaStr
    var String capacityCheck
    var String preValidateToCStr
    
    def __init__(
	String annaNativeType, String annaCType, String convertToC, String convertToAnna,
	String capacityCheck = ?, String cleanupToC = ?, String cleanupToAnna= ?, String preValidateToC = ?) {
	annaNativeTypeStr = annaNativeType
	annaCTypeStr = annaCType
	convertToCStr = convertToC
	convertToAnnaStr = convertToAnna
	this.capacityCheck = capacityCheck
	cleanupToCStr = cleanupToC
	cleanupToAnnaStr = cleanupToAnna
	preValidateToCStr = preValidateToC
    }
    
    def String annaNativeType(Node decl, Node attr){
	return annaNativeTypeStr
    }

    def String annaCType(Node decl, Node attr){
	return annaCTypeStr
    }

    def String convertToC(Node decl, Node attr, String dest, String source) {
        return convertToCStr % ["dest": dest, "source": source]
    }

    def String preValidateToC(Node decl, Node attr, String dest, String source) {
	if(preValidateToCStr) {
	    return preValidateToCStr % ["dest": dest, "source": source]
	} else {
	    return BindingType::preValidateToC(this, decl, attr, dest, source)
	}
    }

    def String postValidateToC(Node decl, Node attr, String dest, String source) {
        res := "".thaw
        annaUtil.findAttribute(attr as Call, "ensureCapacity").each(cap) {
	  capStr := switch(cap) {
		case(capId as Identifier) {
		    BindingGenerator::getNativeParamName(capId.name)
		}
		case(capNum as IntLiteral) {
		    String::convert(capNum.payload)
		}
	    }
	    res ~= capacityCheck % ["dest": dest, "source": source, "capacity": capStr]
	}
	res
    }
    
    def String convertToAnna(Node decl, Node attr, String dest, String source) {
	return convertToAnnaStr % ["dest": dest, "source": source]
    }

    def String cleanupToAnna(Node decl, Node attr, String dest, String source) {
	return cleanupToAnnaStr % ["dest": dest, "source": source]
    }

    def String cleanupToC(Node decl, Node attr, String dest, String source) {
	return cleanupToCStr % ["dest": dest, "source": source]
    }

}

class CStructBindingType (
    extends(BindingType), 
    doc("A BindingType used when passing cStruct objects as parameters.")
) {
    var String structName
    var String typeName
    var String structText
    var Int isPointer

    def __init__(
	String structName, String typeName, Int isStruct=1, Int isPointer=?) {
	expandCode(this.%name = %name, name: [structName, typeName, isPointer])
	structText = if(isStruct){"struct "} else {""}
    }
    
    def String annaNativeType(Node decl, Node attr){
	return structText ~ structName ~ " *"
    }

    def String annaCType(Node decl, Node attr){
	return typeName
    }

    def String convertToC(Node decl, Node attr, String dest, String source) {
        param := [
	    "structName": structName,
	    "dest": dest, 
	    "source": source, 
	    "structText": structText,
	    ]
	code := "%(structText)%(structName) *%(dest);\n" % param
	if(isPointer) {
	    if((attr as Call).childNamed?("nullable")) {
		code ~= "    %(dest) = anna_entry_null(%(source)) ? 0 : (%(structText)%(structName) *)anna_entry_get_ptr(anna_as_obj_fast(%(source)), ANNA_MID_CSTRUCT_PAYLOAD);" % param
	    } else {
		code ~= "    %(dest) = (%(structText)%(structName) *)anna_entry_get_ptr(anna_as_obj_fast(%(source)), ANNA_MID_CSTRUCT_PAYLOAD);" % param
	    }
	} else {
	    if((attr as Call).childNamed?("nullable")) {
		code ~= "    %(dest) = anna_entry_null(%(source)) ? 0 : (%(structText)%(structName) *)anna_entry_get_addr(anna_as_obj_fast(%(source)), ANNA_MID_CSTRUCT_PAYLOAD);" % param
	    } else {
		code ~= "    %(dest) = (%(structText)%(structName) *)anna_entry_get_addr(anna_as_obj_fast(%(source)), ANNA_MID_CSTRUCT_PAYLOAD);" % param
	    }
	}
	return code
    }

    def String convertToAnna(Node decl, Node attr, String dest, String source) {
	if(isPointer) {
	    param := [
		"structName": structName,
		"structText": structText,
		"dest": dest,
		"source": source,
		"annaCType": annaCType(decl, attr),
	    	]
	    return "    anna_entry_t %(dest) = anna_from_obj(anna_object_create(%(annaCType)));
    anna_entry_set_ptr(anna_as_obj_fast(%(dest)), ANNA_MID_CSTRUCT_PAYLOAD, %(source));" % param
	}
	return ?
    }

}

class BindingGenerator (
    doc("The main object of the binding generator. Iterates over the parse tree in the binding file and generates C code based on the prototypes found there."),
) {

    var String path
    var String name

    def __init__(String name) {
	path = name.freeze
	this.name = name.split('/')[-1].split('.')[0]
    }
    
    def mangleFunctionName(String name, List«String» path = ?) {
	this.name ~ "_i_" ~ (("_".join(path.map(el){mangleName(el)}) ~ "_") or "") ~ mangleName(name)
    }

    def String getFunctionNativeName(Call decl) {
	nameToStr(decl[0], decl[3])
    }

    def getNativeParamName(String originalName) (static) {
	return "native_param_" ~originalName
    }
    
    def generateFunctionCode(Call decl, BindingType methodFor = ?, Int init? = ? ) {
        attr := decl[3] as Call

	lock? := attr.childNamed?("lock")
        paramNames := «String»[]
        init := "".thaw
        preValidate := "".thaw
        postValidate := "".thaw
        cleanup := "".thaw
        code := "".thaw
        inp := decl[2] as Call

	if(methodFor) {
            npn := getNativeParamName("this")
	    init ~= "    " ~ methodFor.convertToC(decl[1], decl[3], npn, "param[0]") ~ "\n"
	    preValidate ~= methodFor.preValidateToC(decl[1], decl[3], npn, "param[0]")
	    postValidate ~= methodFor.postValidateToC(decl[1], decl[3], npn, "param[0]")
	    cleanup ~= ("    " ~ methodFor.cleanupToC(decl[1], decl[3], npn, "param[0]") ~ "\n") or ""
	    paramNames.push(npn)
	}
	
	inp.each(oIdx, inp){
	  idx := oIdx + if(methodFor){1} else {0}
	    inpDecl := inp as Call
	    inpBindingType := getBindingType(inpDecl[1])
            npn := getNativeParamName((inpDecl[0] as Identifier).name)
	    paramNames.push(npn)
	    varName := "param[%()]" % [idx]
	    init ~= inpBindingType.convertToC(inpDecl[1], inpDecl[3], npn, varName)
	    preValidate ~= inpBindingType.preValidateToC(inpDecl[1], inpDecl[3], npn, varName) or ""
	    postValidate ~= inpBindingType.postValidateToC(inpDecl[1], inpDecl[3], npn, varName) or ""
	    cleanup ~= inpBindingType.cleanupToC(inpDecl[1], inpDecl[3], npn, varName) or ""
	}
	
        nname := getFunctionNativeName(decl)
        responseType := getBindingType(decl[1])
        args := ", ".join(paramNames)
        varType := responseType.annaNativeType(decl[1], decl[3])
	if(varType) {
	    tempName := generateTempName()
	
	    code ~= "    %(varType) %(tempName) = %(call);\n" % [
		"varType": varType,
		"tempName": tempName, "call": nname ~"(" ~args~")"]
	    code ~= responseType.convertToAnna(decl[1], decl[3], "result", tempName)
	} else {
	    code ~= "    %(functionName)(%(args));
    anna_entry_t result = null_entry;\n" % ["functionName": nname, "args": args]
	}
        param := [
	    "init": init, "preValidate": preValidate, "postValidate": postValidate, 
	    "code": code, "cleanup": cleanup, 
	    "retValue": (if(init?){"param[0]"} else {"result"}),
	    ]
	if(lock?) {
	    param["lock"] = "
    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);"
	    param["unlock"] = "
    pthread_mutex_unlock(&lock);"
	}
	
	return "    // Validate parameters
%(preValidate)
    // Mangle input parameters
%(init)
    // Validate parameters
%(postValidate)%(lock)
    // Call the function
%(code)
    // Perform cleanup
%(cleanup)%(unlock)
    // Return result
    return %(retValue);" % param
	    
    }

    def generateFunction(String name, Call decl, List«String» path=?) {
        attr := decl[3] as Call
        mangled := mangleFunctionName(name, path: path)
        returnType := getBindingType(decl[1]).annaCType(decl[1], decl[3])
        inputTypeVar := mangled ~ "_argv"
        inputNameVar := mangled ~ "_argn"

        inputTypeData := «String»[]
        inputNameData := «String»[]

	(decl[2] as Call).each(inp){
  	    inpCall := inp as Call
	    inputTypeData.push(getBindingType(inpCall[1]).annaCType(inpCall[1], inpCall[3]))
	    inputNameData.push("L\"" ~ ((inp as Call)[0] as Identifier).name ~"\"")
	}
        inputCount := inputTypeData.count

	escapedName := cEscape(name)
	aliasCode := "".thaw
	aliasList := annaUtil.findAttribute(attr, "alias")
	aliasList.each(alias) {
	    aliasCode ~= "    anna_member_alias(stack_type, anna_mid_get(%()), %());\n" % [escapedName, cEscape(alias.toString())]
	}

	allDoc := extractDocAll(attr)


        data := [
		"functionName": escapedName, 
		"mangledName": mangled,
		"returnType": returnType,
		"inputCount": inputCount,
		"inputTypeVar": inputTypeVar,
		"inputTypeData": ", ".join(inputTypeData),
		"inputNameVar": inputNameVar,
		"inputNameData": ", ".join(inputNameData),
		"doc": allDoc[0] or "0",
		"codeInternal": generateFunctionCode(decl),
		"aliasCode": aliasCode
	    ]
	    

        native := annaUtil.findAttribute(attr, "native")
        code := ""
	if(!native.empty?) {
	    data["mangledName"] = native[0].toString()
	} else {
            code = "
ANNA_VM_NATIVE(%(mangledName), %(inputCount))
{
%(codeInternal)
}
" % data
	}

        load := "
    anna_type_t *%(inputTypeVar)[] = {%(inputTypeData)};
    wchar_t *%(inputNameVar)[] = {%(inputNameData)};
    latest_function = anna_module_function(stack, %(functionName), 0, &%(mangledName), %(returnType), %(inputCount), %(inputTypeVar), %(inputNameVar), 0, %(doc));
%(aliasCode)" % data
  
	    allDoc[1...].each(doc) {
		load ~= "   anna_function_document(latest_function,anna_intern_static(%()));\n" % [doc]
	    }
	    

	return struct(load:load, code:code)
    }


    def generateMethod(BindingType type, String name, Call decl, List«String» path = ?) {
        attr := decl[3] as Call
        mangled := mangleFunctionName(name, path)
        returnType := getBindingType(decl[1]).annaCType(decl[1], decl[3])
        inputTypeVar := mangled ~ "_argv"
        inputNameVar := mangled ~ "_argn"

        inputTypeData := [type.annaCType(decl[1], decl[3])]
        inputNameData := ["L\"this\""]

        init? := name == "__init__"

	(decl[2] as Call).each(inp){
  	    inpCall := inp as Call
	    inputTypeData.push(getBindingType(inpCall[1]).annaCType(inpCall[1], inpCall[3]))
	    inputNameData.push("L\"" ~ ((inp as Call)[0] as Identifier).name ~"\"")
	}
        inputCount := inputTypeData.count
	
        data := [
		"type": type.annaCType(decl[1], decl[3]),
		"functionName": name, 
		"mangledName": mangled,
		"returnType": returnType,
		"inputCount": inputCount,
		"inputTypeVar": inputTypeVar,
		"inputTypeData": ", ".join(inputTypeData),
		"inputNameVar": inputNameVar,
		"inputNameData": ", ".join(inputNameData),
		"doc": extractDoc(attr),
		"codeInternal": generateFunctionCode(decl, type, init?),
	    ]

        load := "
    anna_type_t *%(inputTypeVar)[] = {%(inputTypeData)};
    wchar_t *%(inputNameVar)[] = {%(inputNameData)};
    anna_member_create_native_method(
        %(type), anna_mid_get(L\"%(functionName)\"), 0, 
        &%(mangledName), %(returnType), %(inputCount), %(inputTypeVar), %(inputNameVar), 0, %(doc));
" % data
  
        code := "
ANNA_VM_NATIVE(%(mangledName), %(inputCount))
{
%(codeInternal)
}
" % data

	    return struct(load:load, code:code)
    }


    def mangleName(String name) {
	name = "".join(name.filter(ch){ch != '_'})
        res := "".thaw ~ name[0].lower
	name[1...].each(ch) {
	    switch(ch.lower) {
   	        case('?') {
		    res ~= "_check"
		}

		case('!') {
		    res ~= "_destructive"
		}
		    
		case(ch) {
		    res ~= ch
		}

		default {
		    res ~= "_" ~ ch.lower
		}
	    }
	}
	res
    }

    def mangleTypeName(String name) {
	this.name ~ '_' ~ mangleName(name) ~ "_type"
    }

    def generateCStructGetterCode(
	String structName, String fieldName, 
	BindingType structType, BindingType membType, Node decl, Node attr, Int isStruct) {
        cCode := structType.convertToC(decl, attr, "data", "param[0]")
	return "
    %(cCode)
    %(wrapData)
    return result;
" % [
		"cCode": cCode,
		"structName": structName,
		"wrapData": membType.convertToAnna(decl, attr, "result", "data->"~fieldName),
		"structText": (if(isStruct){"struct "} else {""}),
		]
    }

    def generateCStructSetterCode(
	String structName, String fieldName, 
	BindingType structType, BindingType membType, Node decl, Node attr, Int isStruct) {
        cCode := structType.convertToC(decl, attr, "data", "param[0]")
	return "
    %(cCode)
    %(wrapData)
    data->%(fieldName) = tmp;
    return param[1];
" % [
		"cCode": cCode,
		"structName": structName,
		"wrapData": membType.convertToC(decl, attr, "tmp", "param[1]"),
		"structText": (if(isStruct){"struct "} else {""}),
		"fieldName": fieldName,
		]
    }

    def generateVarGetterCode(
	String varName, 
	BindingType bindingType, Node decl, Node attr) {
	return "
    %(wrapData)
    return result;
" % [
		"wrapData": bindingType.convertToAnna(decl, attr, "result", varName)
		]
    }

    def generateVarSetterCode(
	String varName, 
	BindingType bindingType, Node decl, Node attr) {
	return "
    if(!anna_entry_null(param[1]))
    {
        %(wrapData)
        %(varName) = value;
    }
    return param[1];
" % [
		"wrapData": bindingType.convertToC(decl, attr, "value", "param[1]"),
		"varName": varName,
		]
    }

    def mangleGetterName(String typeName, String fieldName) {
	return "%()_i_%()_%()_getter" % [this.name, mangleName(typeName), mangleName(fieldName)]
    }

    def mangleSetterName(String typeName, String fieldName) {
	return "%()_i_%()_%()_setter" % [this.name, mangleName(typeName), mangleName(fieldName)]
    }

    def mangleMethodName(String typeName, String methodName) {
	return "%()_i_%()_%()" % [this.name, mangleName(typeName), mangleName(methodName)]
    }

    def String nameToStr(Node name, Node attr) {
        use(parser)
        val := annaUtil.findAttribute(attr as Call, "define")[0] or annaUtil.findAttribute(attr as Call, "name")[0] or name
        switch(val) {
            case(lit as StringLiteral) {
                return lit.payload
            }
            default {
                return String::convert(val)
            }
        }
    }

    def generateCStruct(String structName, Call cstructDecl) {
        typeName := mangleTypeName(structName)
        code := "".thaw
        cstructAttr := cstructDecl[1] as Call
	typeDecl := "anna_type_t *%();\n".thaw %[typeName]
	typeData := "    { &%(), L\"%()\" },\n".thaw % [typeName, structName]
        load := "".thaw
        nativeStructName := nameToStr(parser.Identifier(?, structName), cstructDecl[1])
        initName := mangleMethodName(structName, "init")
	
        isStruct := !cstructDecl.callTo?("cTypeType")
        isPointer := cstructDecl.callTo?("cStructPointerType")
	bindingType[cstructDecl[0]] = (myBinding := CStructBindingType(nativeStructName, typeName, isStruct, isPointer))

        cstructDoc := extractDocAll(cstructAttr)

        commonData := [
	    "typeName": typeName,
	    "nativeStructName": nativeStructName, 
	    "initName": initName,
	    "structName": nativeStructName, 
	    "structText": (if(isStruct){"struct "} else {""}), 
	    "structPointer": (if(isPointer){" *"} else {""}),
	    "initParam": myBinding.convertToC(?,?, "data", "param[0]"),
	    ]

	load ~= "
    anna_member_create_blob(%(typeName), ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(%(structText)%(nativeStructName)%(structPointer)));
" % commonData
        hadInit := ? as Int

	(cstructDecl[2] as Call).each(node) {
	    if(node.callTo?("__const__") or node.callTo?("__var__")) {
                decl := node as Call
                attr := decl[3] as Call
		isVar := node.callTo?("__var__")
	        fieldName := (decl[0] as Identifier).name
 	        fieldType := decl[1]
		hadInit = hadInit or (fieldName == "__init__")

		if(fieldType.callTo?("staticType") and (fieldType as Call)[0].callTo?("__def__")) {
		  methOut := generateMethod(myBinding, fieldName, (fieldType as Call)[0] as Call, [structName])
		    load~= methOut.load
		    code ~= methOut.code
		    continue
		}

	        nativeFieldName := nameToStr(decl[0], attr)
		
  	        memberBinding := getBindingType(decl[1])
  	        getterName := mangleGetterName(structName, fieldName)

  	        setterName := if(isVar){mangleSetterName(structName, fieldName)} else {"0"}
	        getterCode := generateCStructGetterCode(nativeStructName, nativeFieldName, myBinding, memberBinding, decl[1], attr, isStruct)
	        setterCode := generateCStructSetterCode(nativeStructName, nativeFieldName, myBinding, memberBinding, decl[1], attr, isStruct)



  	        data := [
		    "name": fieldName,
		    "typeName": typeName,
		    "returnType": memberBinding.annaCType(decl[1], attr),
		    "getterName": getterName,
		    "setterName": setterName,
		    "getterCode": getterCode,
		    "setterCode": setterCode,
                    "doc": extractDoc(attr),
		    ]
		code ~= "
ANNA_VM_NATIVE(%(getterName), 1)
{%(getterCode)}
" % data
                if(isVar) {
	  	    code ~= "
ANNA_VM_NATIVE(%(setterName), 2)
{%(setterCode)}
" % data
		}

		load ~= "
    anna_member_create_native_property(
        %(typeName), anna_mid_get(L\"%(name)\"),
        %(returnType), %(getterName), %(setterName), %(doc));
" % data

	    } else {
		raise(ParseError(node, "Invalid struct member"))
	    }

	}

	if(!hadInit) {
	    load ~= "    anna_member_create_native_method(
	%(typeName), anna_mid_get(L\"__init__\"), 0,
	&%(initName), any_type, 1, &%(typeName), this_argn, 0, 0);    
" % commonData

	    code ~= "
ANNA_VM_NATIVE(%(initName), 1)
{
    %(initParam)
    memset(data, 0, sizeof(%(structText)%(structName)));
    return param[0];
}
" % commonData

	}

	cstructDoc.each(doc) {
            commonData["doc"] = doc
	    load ~= "    anna_type_document(
            %(typeName), %(doc));
" % commonData
	}

	return struct(code: code, typeData: typeData, typeDecl: typeDecl, load: load)
    }

    def generateModule(Node nodes, List«String» path) {
        code := "".thaw
        load := "".thaw
        typeDecl := "".thaw
        typeData := "".thaw
        moduleData := "".thaw
        customInclude := "".thaw
        attr := ? as Call

	(nodes as Call).each(node) {
	    decl := node as Call
	    switch((decl.function as Identifier).name) {

		case("__const__") {
		    name := (decl[0] as Identifier).name
  		    attr := decl[3] as Call

		    declType := decl[1]
		    declVal := decl[2]

		    switch(declVal) {
			case (intVal as IntLiteral) {
			    load ~= "    anna_module_const_int(stack, L\"%(name)\", %(value), %(doc));\n" % [
				    "name": name,
				    "value": intVal.payload,
				    "doc": extractDoc(attr),
				    ]
			}

			case (callVal as Call) {
			    switch((callVal.function as Identifier).name) {
				case("__def__") {
				  out := generateFunction(name, decl[2] as Call, path)
				    load ~= out.load
				    code ~= out.code
				}
				
				case("cTypeType", "cStructType", "cStructPointerType") {
  				    out := generateCStruct(name, decl[2] as Call)
				    load ~= out.load
				    code ~= out.code
				    typeDecl ~= out.typeDecl
				    typeData ~= out.typeData
				}

				default {
				    print("Unknown declaration:")
				    print(decl)
                                    unix.proc.exit(1)
				}	
			    }
			}

			default {
                            declTypeName := (declType as Identifier).name
                            switch(declTypeName) {
                                case("Int") {
				    nativeName := nameToStr(decl[0], decl[3])
				    
				    define? := annaUtil.findAttribute(attr as Call, "define")[0]

				    params := [
					    "name": name,
					    "value": nativeName,
					    "doc": extractDoc(attr),
					    ]
				    
				    definition := "    anna_module_const_int(stack, L\"%(name)\", %(value), %(doc));
" % params
				    if(define?) {
					params["definition"] = definition
					load ~= "#ifdef %(value)
%(definition)#else
    anna_module_const(stack, L\"%(name)\", int_type, null_entry, %(doc));
#endif

" % params
				    } else {
					load ~= definition
				    }
                                }
				
                                case("Double") {
			            nativeName := nameToStr(decl[0], decl[3])

			            load ~= "    anna_module_const_float(stack, L\"%(name)\", %(value), %(doc));
" % [
				        "name": name,
				        "value": nativeName,
				        "doc": extractDoc(attr),
				    ]
                                }

                                default {
                                    print("Unknon declaration type:", declTypeName)
                                    unix.proc.exit(1)
                                }
                            }
			}	
		    }
		    
		}
		

		case("__var__") {
		    name := (decl[0] as Identifier).name
		    attr := decl[3] as Call

		    declType := decl[1]
		    declVal := decl[2]
		    if(declType.callTo?("staticType")) {
		        typeExpr := (declType as Call)[0] as Call
			if(typeExpr.callTo?("__def__")) {
			    out := generateFunction(name, typeExpr, path)
			    load ~= out.load
			    code ~= out.code
			}
		    } else {
		    nativeName := nameToStr(decl[0], attr)
  	            bindingType := getBindingType(declType)
                    returnType := bindingType.annaCType(declType, attr)
                    getterName := "anna_" ~ this.name ~ "_" ~ nativeName ~"_getter"
                    setterName := "anna_" ~ this.name ~ "_" ~ nativeName ~"_setter"
		    
		    data := [
			    "name": name,
			    "returnType": returnType,
			    "getterName": getterName,
                            "setterName": setterName,
			    "getterCode": generateVarGetterCode(nativeName, bindingType, declType, attr),
			    "setterCode": generateVarSetterCode(nativeName, bindingType, declType, attr),
			    "doc": extractDoc(attr)
			    ]
		    code ~= "
ANNA_VM_NATIVE(%(getterName), 1)
{%(getterCode)}

ANNA_VM_NATIVE(%(setterName), 2)
{%(setterCode)}
" % data

		    load ~= "    anna_member_create_native_property(
        stack_type, anna_mid_get(L\"%(name)\"),
        %(returnType), %(getterName), %(setterName), %(doc));
" % data
                    }
		}
		
		case("include") {
		    decl.each(inc) {
			customInclude ~= "#include %()\n" %[(inc as StringLiteral).payload]
		    }
		}

                case("verbatim") {
		    decl.each(inc) {
			code ~= (inc as StringLiteral).payload
		    }
		}
				
                case("verbatimDeclare") {
		    decl.each(inc) {
			load ~= (inc as StringLiteral).payload
		    }
		}
				

                case("attribute") {
                    attr = decl
                }

		default {
                    if(decl.count == 1 and decl[0].callTo?("__block__")) {
			subName := String::convert(decl.function)
  		        mangledName := mangleName(subName)
  		        loadName := "anna_" ~ mangledName~"_load"
  		        createName := "anna_" ~ mangledName~"_create"

		        out := generateModule(decl[0], [subName])
			code ~= "const static anna_type_data_t anna_%(moduleName)_type_data[] = 
{
%(typeData)};
" % ["typeData": out.typeData, "moduleName": mangledName]
			typeDecl ~= out.typeDecl
			customInclude ~= out.customInclude
                        code ~= out.code
                        code ~= generateCreateFunction(mangledName)
                        code ~= generateLoadFunction(mangledName, out.moduleData, out.load, ?)
                        moduleData ~= "            { L\"%(name)\", %(createName), %(loadName)},\n" % [
				"name": decl.function,
				"loadName": loadName,
				"createName": createName,
                            ]
                    }
		}
	    }
	}

        if(attr) {
            extractDocAll(attr).each(doc) {
                load ~= "    anna_stack_document(stack, %());\n" % [doc]
            }
        }
	
	return struct(
            code: code, typeData: typeData, typeDecl: typeDecl, 
            load: load, customInclude: customInclude, 
            moduleData: moduleData)
    }
    
    def generate() {
        code := "".thaw
        load := "".thaw
        typeDecl := "".thaw
        typeData := "".thaw
        customInclude := "".thaw
        moduleData := "".thaw
	
        text := File(path).readFile()
        nodes := parse(text)
        out := generateModule(nodes, «String»[])

        load ~= out.load
        code ~= out.code
        typeDecl ~= out.typeDecl
        typeData ~= out.typeData
	customInclude ~= out.customInclude
	moduleData ~= out.moduleData

	print( end: "", "
/*
    DO NOT MANUALLY EDIT THIS FILE.

    This file has been automaticaly generated by the anna bind
    utility. If you manually edit it, your changes will eventually be
    lost. Not to mention the fact that staring at machine generated
    code rots your brain. If this file is incorrect, either update the
    bind utility or update the binding source, which is located in the
    file:

    %(source)

 */
#include \"anna/config.h\"

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>
#include <pthread.h>

%(customInclude)
#include \"anna/anna.h\"

// Declare internal variables for all types defined in this module
%(typeDecl)

// Data used to initialize all types defined in this module
const static anna_type_data_t anna_%(moduleName)_type_data[] = 
{
%(typeData)};

// This is the source code of the various wrapper functions
%(code)

// This function is called to create all types defined in this module
%(createFunction)

// This function is called to load all functions and other declarations into the module
%(loadFunction)
" % [
		"customInclude": customInclude,
		"typeDecl": typeDecl,
		"typeData": typeData,
		"code": code,
		"loadFunction": generateLoadFunction(this.name, moduleData, load, 1),
		"createFunction": generateCreateFunction(this.name),
		"moduleName": this.name,
                "source": this.path
	    ]
	    )
    }

    def generateCreateFunction(String moduleName) {
"
void anna_%(moduleName)_create(anna_stack_template_t *stack);
void anna_%(moduleName)_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_%(moduleName)_type_data, stack);        
}" % ["moduleName": moduleName]
    }

    def generateLoadFunction(String moduleName, String moduleData, String load, Int isRootFunction) {
        return "
void anna_%(moduleName)_load(anna_stack_template_t *stack);
void anna_%(moduleName)_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
%(moduleData)        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L\"this\"};

%(load)
    anna_type_data_register(anna_%(moduleName)_type_data, stack);
}
" % [
            "moduleName": moduleName, 
            "moduleData": moduleData,
            "load": load,
            "register": (if(isRootFunction){"    anna_type_data_register(anna_type_data, stack);"} else {""})
        ]
    }

}


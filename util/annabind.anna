#! /usr/bin/env anna
use(io);
use(parser);
use(error);

attribute(
    doc(
	"
This is the Anna binding compiler. Unlike many other binding
generators, this one doesn't parse headers in any way. Instead, the
binding creator has to write headers that contain roughly the same
information as traditional C headers, but expressed in a syntax that
is very easy to parse. This is a pretty simple solution, and it
means more work in order to get things up and running. But on the
plus side, it avoids the often significant amount of hand holding
required in order to get C header files to behave well enough in
order to let them be parsed. It should also be noted that aside from
the obvious problems with finding a good strategy for mixing GC:ed
and non-GC:ed objects, there is very little to prevent this strategy
from working beutifully with C++ bindings as well.",
	"
The bind utility simply outputs a C file that when compiled into a
library can be linked into Anna at runtime in order to provide the
runtime with an additional library.  It would be nice if the whole
build chain could be moved into Anna, but that would require that
Anna has access to a C compiler. Using exec(\"cc\", ...) should be
enough. This might happen later on.",
	"
Basic function declarations look like this:",
	"
def Int foo(Int x, Buffer y);",
	"
this is equivalent to the following C header:",
	"
int foo(int x, char *y);",
	"
  The following basic types are built in:",
	"
  * Int: maps to the regular Anna Int. Should be used for all integer types of the C 'int' of the platform.
  * Float: maps to the regular Anna Float. Should be used for the C 'float' type.
  * Double: maps to the regular Anna Float. Should be used for the C 'double' type.
  * Buffer: maps to a memory region. Should be used for various array data.
  * List«X»: Maps to a list of items. X needs to be another basic type, potentially including another list. When a List is given as an output type, it will need annotations to inform the binder of the vector size, see below.
  * MutableList«X»: Maps to a list of items. X needs to be another basic type, potentially including another list. When a List is given as an output type, it will need annotations to inform the binder of the vector size, see below. The values of the MutableList type can be changed by the call, but the list length must not be changed.
",
	"
  The following additional types are planned:",
	"
  * UnsignedInt: maps to the regular Anna Int. Should be used for all integer types of the C 'unsigned int' of the platform.
  * Short, UnsignedShort, Long, UnsignedLong, Char, UnsignedChar, Int32, UnsignedInt32, Int64, UnsignedInt64 all work the same as well.
  * Void: Only available as a return type. A function which returns nothing. Will be translated into a function of return type Object and return value null.
  * Pointer«X»: Opaque pointer value. Opaque pointers can not be used inside of any except for sending them as parameters to other functions. Pointers can be recast as any other pointer type. 
  * FloatVector, IntVector, etc. Maps to a list of numbers. When a List is given as an output type, it will need annotations to inform the binder of the vector size.",
	"
  There should be a mechanism for adding library specific types. ",
	"
  cStruct information:",
	"
  TODO",
	"
  Constants:",
	"
  TODO",

));

var HashMap«Node, BindingType» bindingType;

def getBindingType(Node node)
{
    return bindingType[node] or bindingType[(node as Call)[0]];
}

type ParseError (extends(error.Error))
{
    var Node node;
    var String message;

    def __init__(Node node, String message)
    {
	this.node=node;
	this.message=message;
    }

}

type BindingType 
(
    doc("Base class for the types used in the bindings.",
	"A BindingType is used to convert from data from Anna objects into C data and back. They also need to be able to validate the data and to cleanup any memory used in the conversion process.")
)
{
    def String annaNativeType(Node decl, Node attr)
    (doc("The C type that this BindingType handles"))
    {}

    def String annaCType(Node decl, Node attr)
    (doc("The anna_type_t * of the type that this BindingType handles"))
    {}

    def String convertToC(Node decl, Node attr, String dest, String source)
    (doc("Convert the anna_entry_t * pointed to by source into C data in the (newly declared) variable named by dest"))
    {}

    def String convertToAnna(Node decl, Node attr, String dest, String source)
    (doc("Convert the C data pointed to by source into an anna_entry_t * in the (newly declared) variable named by dest"))
    {}
    
    def String cleanupToC(Node decl, Node attr, String dest, String source)
    (doc("Perform any cleanup needed after a anna => C conversion. This is run after the C function has been run"))
    {}
    
    def String cleanupToAnna(Node decl, Node attr, String dest, String source)
    (doc(""))
    {}
    
    def String validateToC(Node decl, Node attr, String dest, String source)
    (doc("Perform validation of the specified conversion to C."))
    {}
    
    def String validateToAnna(Node decl, Node attr, String dest, String source)
    (doc("Perform validation of the specified conversion to anna."))
    {}
}

type ListBindingType 
(
    extends(BindingType), 
    doc("A BindingType implementation used for read-only lists"),)
{

    def String annaNativeType(Node decl, Node attr){
        subType := ((decl as Call)[1] as Call)[0];
        subBinding := getBindingType(subType);
	return subBinding.annaNativeType(subType, ?) ~"*";
    }

    def String annaCType(Node decl, Node attr){
      subType := ((decl as Call)[1] as Call)[0];
      subBinding := getBindingType(subType);
	return "anna_list_type_get_any(%)" % [subBinding.annaCType(subType, ?)];
    }

    def String convertToC(Node decl, Node attr, String dest, String source){
        subType := ((decl as Call)[1] as Call)[0];
        subBinding := getBindingType(subType);
        subTypeNative := subBinding.annaNativeType(subType, ?);
	
	return "size_t %(szName) = anna_list_get_count(anna_as_obj(%(source)));
    %(subTypeNative)* %(dest) = malloc(sizeof(%(subTypeNative)) * %(szName));
    if(!%(dest)){ return null_entry; }
    int %(dest)_idx;
    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        %(conversion)
        %(dest)[%(dest)_idx] = %(dest)_val;
    }
" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
            "conversion": subBinding.convertToC(subType, ?, dest ~ "_val", "anna_list_get(anna_as_obj(%), %)" % [source, dest ~ "_idx"])
            ];
    }

    def String convertToAnna(Node decl, Node attr, String dest, String source){
	?
    }
    def String cleanupToC(Node decl, Node attr, String dest, String source)
    {	
        subType := ((decl as Call)[1] as Call)[0];
        subBinding := getBindingType(subType);
        subTypeNative := subBinding.annaNativeType(subType, ?);
	return "
    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        %(subCleanup)
    }
    free(%(dest));
" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
            "subCleanup": subBinding.cleanupToC(subType, ?, dest ~ "["~dest~"_idx]", "anna_list_get(anna_as_obj(%), %" % [source, dest ~ "_idx"])
            ];
    }

    def String cleanupToAnna(Node decl, Node attr, String dest, String source){	

    }

    def String validateToC(Node decl, Node attr, String dest, String source){	
	"";
    }
    def String validateToAnna(Node decl, Node attr, String dest, String source){
	"";
    }

}

type MutableListBindingType 
(
    extends(BindingType), 
    doc("A BindingType used for mutable lists.")
)
{

    def String annaNativeType(Node decl, Node attr){
        subType := ((decl as Call)[1] as Call)[0];
        subBinding := getBindingType(subType);
	return subBinding.annaNativeType(subType, ?) ~"*";
    }

    def String annaCType(Node decl, Node attr){
      subType := ((decl as Call)[1] as Call)[0];
      subBinding := getBindingType(subType);
	return "anna_list_type_get_mutable(%)" % [subBinding.annaCType(subType, ?)];
    }

    def String convertToC(Node decl, Node attr, String dest, String source){
        subType := ((decl as Call)[1] as Call)[0];
        subBinding := getBindingType(subType);
        subTypeNative := subBinding.annaNativeType(subType, ?);
	
      res := "".thaw;

        findAttr(attr, "ensureCapacity").each(cap)
	{
	    capStr := switch(cap)
	    {
		case(capId as Identifier)
		{
		    BindingGenerator::getNativeParamName(capId.name);
		}
		case(capNum as IntLiteral)
		{
		    String::convert(capNum.payload);
		}
	    }
	    res ~= "if(anna_list_ensure_capacity(anna_as_obj(%(source)), %(capacity)))
    {
        return null_entry;
    }\n    " % ["source": source, "capacity": capStr];
	}

	res ~= "size_t %(szName) = anna_list_get_count(anna_as_obj(%(source)));
    %(subTypeNative)* %(dest) = malloc(sizeof(%(subTypeNative)) * %(szName));
    if(!%(dest)){ return null_entry; }
    int %(dest)_idx;
    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        anna_entry_t *tmp = %(value);
        if(tmp == null_entry)
        {
            %(dest)[%(dest)_idx] = 0;
        }
        else
        {
            %(conversion)
            %(dest)[%(dest)_idx] = %(dest)_val;
        }
    }
" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
            "conversion": subBinding.convertToC(subType, ?, dest ~ "_val", "tmp"),
	    "value": "anna_list_get(anna_as_obj(%), %)" % [source, dest ~ "_idx"],
	    
            ];

	return res;
    }

    def String convertToAnna(Node decl, Node attr, String dest, String source){
	?
    }
    def String cleanupToC(Node decl, Node attr, String dest, String source)
    {	
        subType := ((decl as Call)[1] as Call)[0];
        subBinding := getBindingType(subType);
        subTypeNative := subBinding.annaNativeType(subType, ?);
	return "
    for(%(dest)_idx=0; %(dest)_idx < %(szName); %(dest)_idx++)
    {
        %(value)
        anna_list_set(anna_as_obj(%(source)), %(dest)_idx, tmp);
        %(subCleanup)
    }
    free(%(dest));
" % [
	    "subTypeNative": subTypeNative,
	    "dest": dest,
	    "source": source,
	    "szName": dest ~ "_count",
	    "value": subBinding.convertToAnna(subType, ?, "tmp", "%(dest)[%(dest)_idx]" % ["dest": dest]),
            "subCleanup": subBinding.cleanupToC(subType, ?, dest ~ "["~dest~"_idx]", "anna_list_get(anna_as_obj(%), %" % [source, dest ~ "_idx"])
            ];
    }

    def String cleanupToAnna(Node decl, Node attr, String dest, String source){	

    }

    def String validateToC(Node decl, Node attr, String dest, String source){	
	"";
    }
    def String validateToAnna(Node decl, Node attr, String dest, String source){
	"";
    }

}

def List«Node» findAttr(Call attr, String name)
{
    res := «Node»[];
    attr.each(at)
    {
	(at.isCallTo(name)) and (at as Call).each(item){res.push(item)}
    }
    res;
}

type BasicBindingType 
(
    extends(BindingType), 
    doc("A very simple BindingType implementation that simply relies on string templates to perform its tasks. Works well for basic types like Int, String, etc."),
)
{
    var String annaNativeTypeStr;
    var String annaCTypeStr;
    var String convertToCStr;
    var String convertToAnnaStr;
    var String cleanupToCStr;
    var String cleanupToAnnaStr;
    var String capacityCheck;
    
    def __init__(
	String annaNativeType, String annaCType, String convertToC, String convertToAnna,
	String capacityCheck = ?, String cleanupToC = ?, String cleanupToAnna= ?)
    {
	this.annaNativeTypeStr = annaNativeType;
	this.annaCTypeStr = annaCType;
	this.convertToCStr = convertToC;
	this.convertToAnnaStr = convertToAnna;
	this.capacityCheck = capacityCheck;
	this.cleanupToCStr = cleanupToC;
	this.cleanupToAnnaStr = cleanupToAnna;
    }
    
    def String annaNativeType(Node decl, Node attr){
	return annaNativeTypeStr;
    }

    def String annaCType(Node decl, Node attr){
	return annaCTypeStr;
    }

    def String convertToC(Node decl, Node attr, String dest, String source)
    {
        return convertToCStr % ["dest": dest, "source": source];
    }

    def String validateToC(Node decl, Node attr, String dest, String source)
    {
        res := "".thaw;
        findAttr(attr, "ensureCapacity").each(cap)
	{
	  capStr := switch(cap)
	    {
		case(capId as Identifier)
		{
		    BindingGenerator::getNativeParamName(capId.name);
		}
		case(capNum as IntLiteral)
		{
		    String::convert(capNum.payload);
		}
	    }
	    res ~= "    " ~ capacityCheck % ["dest": dest, "source": source, "capacity": capStr] ~ "\n";
	}
	res;
    }
    
    def String convertToAnna(Node decl, Node attr, String dest, String source)
    {
	return convertToAnnaStr % ["dest": dest, "source": source];
    }

    def String cleanupToAnna(Node decl, Node attr, String dest, String source)
    {
	return cleanupToAnnaStr % ["dest": dest, "source": source];
    }

    def String cleanupToC(Node decl, Node attr, String dest, String source)
    {
	return cleanupToCStr % ["dest": dest, "source": source];
    }

}

type CStructBindingType 
(
    extends(BindingType), 
    doc("A BindingType used when passing cStruct objects as parameters.")
)
{
    var String structName;
    var String typeName;
    var String structText;

    def __init__(
	String structName, String typeName, Int isStruct=1)
    {
	this.structName = structName;
	this.typeName = typeName;
	structText = if(isStruct){"struct "}else{""}
    }
    
    def String annaNativeType(Node decl, Node attr){
	return structText ~ structName
    }

    def String annaCType(Node decl, Node attr){
	return typeName;
    }

    def String convertToC(Node decl, Node attr, String dest, String source)
    {
	"char *%(dest) = anna_string_payload_narrow(anna_as_obj(%(source)));";
	"%(structText)%(structName) *%(dest) = (%(structText)%(structName) *)anna_entry_get_addr(anna_as_obj_fast(%(source)), ANNA_MID_CSTRUCT_PAYLOAD);" % ["structName": structName, "dest": dest, "source": source, "structText": structText];
    }

}

type BindingGenerator
(
    doc("The main object of the binding generator. Iterates over the parse tree in the binding file and generates C code based on the prototypes found there."),
)
{

    var String path;
    var String name;

    def __init__(String name)
    {
	path = name.freeze;
	this.name = name.split('/')[-1].split('.')[0];
    }
    
    def mangleFunctionName(String name)
    {
	this.name ~ "_i_" ~mangleName(name);
    }

    def getFunctionNativeName(Call decl)
    {
	String::convert(findAttr(decl[3], "name")[0]) or (decl[0] as Identifier).name;
    }

    def getNativeParamName(String originalName) (static)
    {
	return "native_param_" ~originalName;
    }
    
    def generateFunctionCode(Call decl)
    {
        init := "".thaw;
        validate := "".thaw;
        cleanup := "".thaw;
        code := "".thaw;
        inp := decl[2] as Call;
	
        paramNames := «String»[];
	inp.each(idx, inp){
	    inpDecl := inp as Call;
	    inpBindingType := getBindingType(inpDecl[1]);
            npn := getNativeParamName((inpDecl[0] as Identifier).name);
	    paramNames.push(npn);
	    init ~= "    if(param[%] == null_entry){return null_entry;}\n" % [idx];
	    init ~= "    " ~ inpBindingType.convertToC(inpDecl[1], inpDecl[3], npn, "param[%]" % [idx]) ~ "\n";
	    validate ~= inpBindingType.validateToC(inpDecl[1], inpDecl[3], npn, "param[%]" % [idx]);
	    cleanup ~= ("    " ~ inpBindingType.cleanupToC(inpDecl[1], inpDecl[3], npn, "param[%]" % [idx]) ~ "\n") or "";
	}
	
        nname := getFunctionNativeName(decl);
        responseType := getBindingType(decl[1]);
        args := ", ".join(paramNames);
	code ~= "    " ~ responseType.convertToAnna(decl[1], decl[3], "result", nname ~"(" ~args~")");

	"    // Mangle input parameters
%(init)
    // Validate parameters
%(validate)
    // Call the function
%(code)
    // Perform cleanup
%(cleanup)
    // Return result
    return result;" % ["init": init, "validate": validate, "code": code, "cleanup": cleanup];

    }

    def generateFunction(String name, Call decl)
    {
        mangled := mangleFunctionName(name);
        returnType := getBindingType(decl[1]).annaCType(decl[1], decl[3]);
        inputTypeVar := mangled ~ "_argv";
        inputNameVar := mangled ~ "_argn";

        inputTypeData := «String»[];
        inputNameData := «String»[];

	(decl[2] as Call).each(inp){
  	    inpCall := inp as Call;
	    inputTypeData.push(getBindingType(inpCall[1]).annaCType(inpCall[1], inpCall[3]));
	    inputNameData.push("L\"" ~ ((inp as Call)[0] as Identifier).name ~"\"");
	}
        inputCount := inputTypeData.count;
	
        doc := "";
	
        data := 
	    [
		"functionName": name, 
		"mangledName": mangled,
		"returnType": returnType,
		"inputCount": inputCount,
		"inputTypeVar": inputTypeVar,
		"inputTypeData": ", ".join(inputTypeData),
		"inputNameVar": inputNameVar,
		"inputNameData": ", ".join(inputNameData),
		"doc": "L\"" ~ doc ~ "\"",
		"codeInternal": generateFunctionCode(decl),
	    ];

        load := "
    anna_type_t *%(inputTypeVar)[] = {%(inputTypeData)};
    wchar_t *%(inputNameVar)[] = {%(inputNameData)};
    anna_module_function(stack, L\"%(functionName)\", 0, &%(mangledName), %(returnType), %(inputCount), %(inputTypeVar), %(inputNameVar), %(doc));
" % data;
  
        code := "
ANNA_VM_NATIVE(%(mangledName), %(inputCount))
{
%(codeInternal)
}
" % data;

	    return struct(load:load, code:code);
    }

    def mangleName(String name)
    {
        res := "".thaw ~ name[0].lower;
	name[1...].each(ch)
	{
	    if(ch.lower != ch){
		res ~= "_";
	    }
	    res ~= ch.lower;
	}
	res;
    }

    def mangleTypeName(String name)
    {
	this.name ~ '_' ~ mangleName(name) ~ "_type";
    }

    def generateCStructGetterCode(
	String structName, String fieldName, 
	BindingType bindingType, Node decl, Node attr, Int isStruct)
    {
	return "
    %(structText)%(structName) *data = (%(structText)%(structName) *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    %(wrapData)
    return result;
" %
	    [
		"structName": structName,
		"wrapData": bindingType.convertToAnna(decl, attr, "result", "data->"~fieldName),
		"structText": if(isStruct){"struct "}else{""},
		];
    }

    def generateCStructSetterCode(
	String structName, String fieldName, 
	BindingType bindingType, Node decl, Node attr, Int isStruct)
    {
	return "
    %(structText)%(structName) *data = (%(structText)%(structName) *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    %(wrapData)
    data->%(fieldName) = tmp;
    return param[1];
" %
	    [
		"structName": structName,
		"wrapData": bindingType.convertToC(decl, attr, "tmp", "param[1]"),
		"structText": if(isStruct){"struct "}else{""},
		"fieldName": fieldName,
		];
    }

    def generateVarGetterCode(
	String varName, 
	BindingType bindingType, Node decl, Node attr)
    {
	return "
    %(wrapData)
    return result;
" %
	    [
		"wrapData": bindingType.convertToAnna(decl, attr, "result", varName)
		];
    }

    def generateVarSetterCode(
	String varName, 
	BindingType bindingType, Node decl, Node attr)
    {
	return "
    if(param[1] != null_entry)
    {
        %(wrapData)
        %(varName) = value;
    }
    return param[1];
" %
	    [
		"wrapData": bindingType.convertToC(decl, attr, "value", "param[1]"),
		"varName": varName,
		];
    }

    def mangleGetterName(String typeName, String fieldName)
    {
	return "%_i_%_%_getter" % [this.name, mangleName(typeName), mangleName(fieldName)];
    }

    def mangleSetterName(String typeName, String fieldName)
    {
	return "%_i_%_%_setter" % [this.name, mangleName(typeName), mangleName(fieldName)];
    }

    def mangleMethodName(String typeName, String methodName)
    {
	return "%_i_%_%" % [this.name, mangleName(typeName), mangleName(methodName)];
    }

    def generateCStruct(String structName, Call decl)
    {
        typeName := mangleTypeName(structName);
        code := "".thaw;
	typeDecl := "anna_type_t *%;\n".thaw %[typeName];
        typeData := "    { &%, L\"%\" },\n".thaw % [typeName, structName];
        load := "".thaw;
        nativeStructName := findAttr(decl[1], "name")[0] or structName;
        initName := mangleMethodName(structName, "init");
	
        isStruct := decl.isCallTo("cStruct");
	bindingType[decl[0]] = CStructBindingType(nativeStructName, typeName, isStruct);
      commonData := ["typeName": typeName, "nativeStructName": nativeStructName, "initName": initName, "structName": nativeStructName, "structText": if(isStruct){"struct "}else{""}];

	load ~= "
    anna_member_create_blob(%(typeName), ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(%(structText)%(nativeStructName)));

    anna_member_create_native_method(
	%(typeName), anna_mid_get(L\"__init__\"), 0,
	&%(initName), object_type, 1, &%(typeName), this_argn, 0, 0);    
" % commonData;

	code ~= "
ANNA_VM_NATIVE(%(initName), 1)
{
    %(structText)%(structName) *data = (%(structText)%(structName) *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(%(structText)%(structName)));
    return param[0];
}
" % commonData;


	(decl[2] as Call).each(node)
	{
	    if(node.isCallTo("__const__") or node.isCallTo("__var__"))
	    {
		isVar := node.isCallTo("__var__");

	        it := node as Call;
	        fieldName := (it[0] as Identifier).name;
	        nativeFieldName := findAttr(it[3], "name")[0] or fieldName;
		
  	        bindingType := getBindingType(it[1]);
  	        getterName := mangleGetterName(structName, fieldName);

  	        setterName := if(isVar){mangleSetterName(structName, fieldName);}else{"0"}
	      getterCode := generateCStructGetterCode(nativeStructName, nativeFieldName, bindingType, it[1], it[3], isStruct);
	      setterCode := generateCStructSetterCode(nativeStructName, nativeFieldName, bindingType, it[1], it[3], isStruct);

  	        data := [
		    "name": fieldName,
		    "typeName": typeName,
		    "returnType": bindingType.annaCType(it[1], it[3]),
		    "getterName": getterName,
		    "setterName": setterName,
		    "getterCode": getterCode,
		    "setterCode": setterCode,
		    ];
		code ~= "
ANNA_VM_NATIVE(%(getterName), 1)
{%(getterCode)}
" % data;
                if(isVar)
                {
	  	    code ~= "
ANNA_VM_NATIVE(%(setterName), 2)
{%(setterCode)}
" % data;
		}
                

		load ~= "
    anna_member_create_native_property(
        %(typeName), anna_mid_get(L\"%(name)\"),
        %(returnType), %(getterName), %(setterName), 0);
" % data;

	    } else
	    {
		raise(ParseError(node, "Invalid struct member"));
	    }

	}

	return struct(code: code, typeData: typeData, typeDecl: typeDecl, load: load);
    }

    def generateModule(Node nodes)
    {
        code := "".thaw;
        load := "".thaw;
        typeDecl := "".thaw;
        typeData := "".thaw;
        moduleData := "".thaw;
        customInclude := "".thaw;

	(nodes as Call).each(node)
	{
	    decl := node as Call;
	    switch((decl.function as Identifier).name)
	    {

		case("__const__")
		{
		    name := (decl[0] as Identifier).name;
		    
		    switch(decl[2])
		    {
			case (intVal as IntLiteral)
			{
			    load ~= "    anna_module_const_int(stack, L\"%(name)\", %(value), L\"%(doc)\");\n" % 
				[
				    "name": name,
				    "value": intVal.payload,
				    "doc": "",
				    ];
			}

			case (callVal as Call)
			{
			    switch(((decl[2] as Call).function as Identifier).name)
			    {
				case("__def__")
				{
				  out := generateFunction(name, decl[2] as Call);
				    load ~= out.load;
				    code ~= out.code;
				}
				
				case("cType", "cStruct")
				{
  				    out := generateCStruct(name, decl[2] as Call);
				    load ~= out.load;
				    code ~= out.code;
				    typeDecl ~= out.typeDecl;
				    typeData ~= out.typeData;
				}
				
				default
				{
				    print(decl);
				}	
			    }
			}

			default
			{

 			    nativeName := findAttr(decl[3], "name")[0] or name;
			    load ~= "    anna_module_const_int(stack, L\"%(name)\", %(value), L\"%(doc)\");
" % 
				[
				    "name": name,
				    "value": nativeName,
				    "doc": "",
				    ];
			}	
		    }	
		}
		

		case("__var__")
		{
		    name := (decl[0] as Identifier).name;
		    nativeName := findAttr(decl[3], "name")[0] or name;

  	            bindingType := getBindingType(decl[1]);

                    returnType := bindingType.annaCType(decl[1], decl[3]),;
                    getterName := "anna_" ~ this.name ~ "_" ~ nativeName ~"_getter";
                    setterName := "anna_" ~ this.name ~ "_" ~ nativeName ~"_setter";

		    data :=
			[
			    "name": name,
			    "returnType": returnType,
			    "getterName": getterName,
                            "setterName": setterName,
			    "getterCode": generateVarGetterCode(nativeName, bindingType, decl[1], decl[3]),
			    "setterCode": generateVarSetterCode(nativeName, bindingType, decl[1], decl[3]),
			    ];

		    code ~= "
ANNA_VM_NATIVE(%(getterName), 1)
{%(getterCode)}

ANNA_VM_NATIVE(%(setterName), 2)
{%(setterCode)}
" % data;

		    load ~= "    anna_member_create_native_property(
        stack_type, anna_mid_get(L\"%(name)\"),
        %(returnType), %(getterName), %(setterName), 0);
" % data;
		}
		
		case("include")
		{
		    decl.each(inc)
		    {
			customInclude ~= "#include %\n" %[(inc as StringLiteral).payload];
		    }
		}

		default
		{
                    if(decl.count == 1 and decl[0].isCallTo("__block__"))
                    {
  		        mangledName := mangleName(String::convert(decl.function));
  		        loadName := "anna_" ~ mangledName~"_load";
  		        createName := "anna_" ~ mangledName~"_create";

		        out := generateModule(decl[0]);
			code ~= "const static anna_type_data_t anna_%(moduleName)_type_data[] = 
{
%(typeData)};
" % ["typeData": out.typeData, "moduleName": mangledName];
			typeDecl ~= out.typeDecl;
			customInclude ~= out.customInclude;
                        code ~= out.code;
                        code ~= generateCreateFunction(mangledName);
                        code ~= generateLoadFunction(mangledName, out.moduleData, out.load, ?);
                        moduleData ~= "            { L\"%(name)\", %(createName), %(loadName)},\n" %
                            [
				"name": decl.function,
				"loadName": loadName,
				"createName": createName,
                            ];
                    }
		}
	    }
	}
	
	return struct(code: code, typeData: typeData, typeDecl: typeDecl, load: load, customInclude: customInclude, moduleData: moduleData);

    }
    
    def generate()
    {
        code := "".thaw;
        load := "".thaw;
        typeDecl := "".thaw;
        typeData := "".thaw;
        customInclude := "".thaw;
        moduleData := "".thaw;
	
        text := File(path).readFile();
        nodes := parse(text);
	
        out := generateModule(nodes);

        load ~= out.load;
        code ~= out.code;
        typeDecl ~= out.typeDecl;
        typeData ~= out.typeData;
	customInclude ~= out.customInclude;
	moduleData ~= out.moduleData;

	print( "
/*
    DO NOT MANUALLY EDIT THIS FILE.

    This file has been automaticaly generated by the anna bind
    utility. If you manually edit it, your changes will eventually be
    lost. Not to mention the fact that staring at machine generated
    code rots your brain. If this file is incorrect, either update the
    bind utility or update the binding source, which is located in the
    file:

    %(source)

 */

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

%(customInclude)
#include \"anna/common.h\"
#include \"anna/util.h\"
#include \"anna/anna.h\"
#include \"anna/mid.h\"
#include \"anna/type.h\"
#include \"anna/type_data.h\"
#include \"anna/vm.h\"
#include \"anna/module.h\"
#include \"anna/lib/lang/list.h\"
#include \"anna/lib/lang/string.h\"
#include \"anna/lib/lang/buffer.h\"
#include \"anna/member.h\"
#include \"anna/module_data.h\"

// Declare internal variables for all types defined in this module
%(typeDecl)

// Data used to initialize all types defined in this module
const static anna_type_data_t anna_%(moduleName)_type_data[] = 
{
%(typeData)};

// This is the source code of the various wrapper functions
%(code)

// This function is called to create all types defined in this module
%(createFunction)

// This function is called to load all functions and other declarations into the module
%(loadFunction)
" %
	    [
		"customInclude": customInclude,
		"typeDecl": typeDecl,
		"typeData": typeData,
		"code": code,
		"loadFunction": generateLoadFunction(this.name, moduleData, load, 1),
		"createFunction": generateCreateFunction(this.name),
		"moduleName": this.name,
                "source": this.path
	    ]
	    );
    }

    def generateCreateFunction(String moduleName)
    {
"
void anna_%(moduleName)_create(anna_stack_template_t *stack);
void anna_%(moduleName)_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_%(moduleName)_type_data, stack);        
}" % ["moduleName": moduleName];
    }

    def generateLoadFunction(String moduleName, String moduleData, String load, Int isRootFunction)
    {
        return "
void anna_%(moduleName)_load(anna_stack_template_t *stack);
void anna_%(moduleName)_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
%(moduleData)        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L\"this\"};

%(load)
     anna_type_data_register(anna_%(moduleName)_type_data, stack);
}
" % ["moduleName": moduleName, "moduleData": moduleData, "load": load, "register": if(isRootFunction){"    anna_type_data_register(anna_type_data, stack);"}else{""}]
    }

}

def main()
{ 
	bindingType = [
	    ast(Void): BasicBindingType(
                "int",
		"object_type", 
		?,
		"%(source); anna_entry_t *%(dest) = null_entry;",
	        ),
	    ast(String): BasicBindingType(
                "char *",
		"string_type", 
		"char *%(dest) = anna_string_payload_narrow(anna_as_obj(%(source)));",
		"anna_entry_t *%(dest) = (%(source)) ? anna_from_obj(anna_string_create_narrow(strlen(%(source)), %(source))) : null_entry;",
		cleanupToC: "free(%(dest));"),
	    ast(Int): BasicBindingType(
                "int",
 		"int_type", 
		"int %(dest) = anna_as_int(%(source));",
		"anna_entry_t *%(dest) = anna_from_int(%(source));"),
	    ast(UInt64): BasicBindingType(
                "unsigned int64_t",
 		"int_type", 
		"uint64_t %(dest) = anna_as_int(%(source));",
		"anna_entry_t *%(dest) = anna_from_uint64(%(source));"),
	    ast(Float): BasicBindingType(
                "float",
		"float_type", 
		"float %(dest) = (float)anna_as_float(%(source));",
		"anna_entry_t *%(dest) = anna_from_float((double)%(source));"),
	    ast(Double): BasicBindingType(
                "double",
		"float_type", 
		"double %(dest) = anna_as_float(%(source));",
		"anna_entry_t *%(dest) = anna_from_float(%(source));"),
	    /*  ast(Pointer): BasicBindingType(
                "void *",
		"pointer_type", 
		"void *%(dest) = anna_entry_get_addr(anna_as_obj(%(source)), ANNA_MID_POINTER_PAYLOAD);",
		"anna_entry_t *%(dest) = anna_from_obj(anna_pointer_create(%(source)));"),*/
	    ast(Buffer): BasicBindingType(
                "unsigned char *",
		"buffer_type", 
		"unsigned char *%(dest) = anna_buffer_get_payload(anna_as_obj(%(source)));",
		?,
		capacityCheck: "if(anna_buffer_ensure_capacity(anna_as_obj(%(source)), %(capacity))) 
    {
        return null_entry;
    }
    else
    {
        %(dest) = anna_buffer_get_payload(anna_as_obj(%(source)));
    }"),
	    ast(List): ListBindingType(),
	    ast(MutableList): MutableListBindingType(),
	    ];

    system.argument[1...].each(binding)
    {
	BindingGenerator(binding).generate();
    }    
}


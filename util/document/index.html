<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/anna.css" type="text/css" />
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="js/anna.js"></script>
    <title>Anna - A brief introduction</title>
  </head>
  <body>


    <div class="anna-content">
      <div class="anna-main">
	<div class="anna-main-inner">
	  <h1><a name='root'>A brief introduction to Anna</a></h1>
	  <pre class="anna-code">
def main()
{
    print("Hello, World!\n");
}
	  </pre>
	  <p>
	    This is a brief introduction to the Anna programming language,
	    written in the form of a «Choose your own adventure»-style
	    gamebook. 
	  </p>
	  <p>
	    Let's get started:
	  </p>
	  <ul>
	    
	    <li>
	      <a href='#download'>Try it out!</a> Anna is open source
	      and available on the net.
	    </li>

	    <li>
	      Read <a href='#examples'>Anna by examples</a> if you
	      just want to dig in to the syntax.
	    </li>
	    
	    <li>
	      If you already know everything there is to know about
	      other programming languages, you should
	      read <a href='#intro_short'>Anna in a single
	      sentence</a>.
	    </li>
	    
	    <li> 
	      Recommended if you are the most familiar with
	      languages in the LISP family, you should continue
	      to <a href='#intro_lisp'>Anna for LISP programmers</a>.
	    </li>
	    
	    <li>
	      If langauges from the C family are your main strength,
	      move along to <a href='#intro_c'>Anna for C, C++, Java,
	      C#, Go and D programmers</a>.
	    </li>
	    
	    <li>
	      Are modern dynamically typed languages your cup of
	      tea? <a href='#intro_script'>Anna for Python and Ruby
	      programmers</a> is for you.
	    </li>
	    
	    <li>
	      Want to check out the standard library?
	      The <a href='api/global.html'>API documentation</a> is
	      what you're looking for.
	    </li>  
	    
	    <li>
	      Still looking? There is also a section
	      titled <a href='#intro_long'>Gentle Anna.</a> If you're
	      a programmer, but unsure which of the above categories
	      your language of choice falls into, or if you are not
	      entirely familiar with programming a computer to begin
	      with, but curious about what makes Anna different, then
	      this is the link for you.
	    </li>  
	    
	  </ul>
      
	  <h2><a name="examples">Anna by examples</a></h2>
	  <div class='anna-subheading'>Because time is too precious to actually learn anything.</div>

	  <h3><a name="examples-functions">Defining and calling functions</a></h3>
	  <pre class="anna-code">
def Int fibonacci(Int n) 
{
    return if (n &lt; 2) { 1 } else { fibonacci(n-2) + fibonacci(n-1) }
}

def main()
{
    print(fibonacci(20), "\n");
}
	  </pre>
	  <p>
	    The above code is a program that calculates and prints the 20:th
	    Fibonacci number. It demonstrates a few features of the Anna
	    syntax. The first line tells us how to declare a new function:
	  </p>
	  <pre class="anna-code">
def Int fibonacci(Int n)
	  </pre>
	  <p>
	    The <code class="anna-code">def</code> keyword means that we're defining a function. Then
	    a return type and the name of the function we're defining. After
	    that follows a list of all input parameteres the function accepts
	    and their types. A few things should be noted:
	  </p>
	  <ul>
	    <li>
	      The function return type can usually be omitted, as it is for the
	      main function below. Specifically, if the compiler can calculate
	      the return type by looking at all the return statments, then it
	      can be omitted. The fibonacci function is recursive, which makes
	      this difficult, so we need to help the compiler. If you don't
	      provide the return type, and the compiler can't calculate it
	      either, the compiler will let you know. Usually by crashing.
	    </li>
	    <li>
	      The function name can be omitted if desired. If you omit it, you
	      will have created an anonymous function. These can be used e.g. as
	      input paramters to other functions that accept a function as an
	      argument.
	    </li>
	  </ul>
	  <p>
	    If you want to know more about type
	    inference, <a href="#type-inference">click here</a>. Otherwise,
	    continue reading. The next line of interest is this:
	  </p>
	  <pre class="anna-code">
return if (n &lt; 2) { 1 } else { fibonacci(n-2) + fibonacci(n-1) }
	  </pre>
	  <p>
	    This line tells us a few important things about Anna:
	  </p>
	  <ul>
	    <li>
	      To call a function, like e.g. the <code class="anna-code">fibonacci</code> function,
	      just write the function name followed by it's input parameters
	      in parenthesis, like in any C-like language. 
	    </li>
	    <li>
	      The <code class="anna-code">if</code> clause in Anna returns a value. In computer
	      words, it is an expression, not a statement. Specifically, it
	      returns the last value of the block which was executes. In
	      fact, there are no statements in Anna - everything is an
	      expression,
	    </li>
	    <li>
	      The bullet point above implies that the <code class="anna-code">return</code>
	      keyword in the code above was superflous - since the if
	      expression was the last expression in the fibonacci function,
	      it would have been returned as the function output
	      regardless. This is in fact correct - the return keyword was
	      only used to make the intent of the code more clear.
	    </li>
	  </ul>
	  
	  <h3><a name="examples-variables">Variables</a></h3>
	  <p>
	    That wasn't very hard. It's going to stay pretty easy for a
	    while longer.
	  </p>
	  <pre class="anna-code">
def main()  
{
    foo := 3;         // Declare foo as 3
    print(foo, "\n"); // Print 3
    foo = 5;          // Assign 5 to foo
    print(foo, "\n"); // Print 5
}
	  </pre>
	  <p>
	    Wow. That one may have been even easier than the first one.
	  </p>
	  <ul>
	    <li>
	      To declare a variable, write the variable name, followed
	      by <code class="anna-code">:=</code> and the initial value for the varialbe.
	    </li>
	    <li>
	      To assign a new value to an existing variable, write the
	      variable name, followed by <code class="anna-code">=</code> and the new value for
	      the variable.
	    </li>
	    
	  </ul>
	  <p>
	    Anna is a so called statically typed language. That means that
	    she insists that she must have an idea of the type of every
	    variable at compile time. Anna does this by checking the type of
	    the initial value. This is called type inference. If we don't
	    want the variable to have the type of the initial value, we'll
	    use the cast operator. In Anna, the cast operator is
	    called <code class="anna-code">as</code>. It is used like this:
	  </p>
	  <pre class="anna-code">
foo := 3 as Object;  // Declare foo as a variable of type Object
	  </pre>
	  <p>
	    The above code will declare the variable foo, which will be of
	    type Object. Object is the root of the Anna type tree, which
	    means that objects of any type can be cast to an Object. The
	    initial value of the foo variable is the integer 3.
	  </p>
	  <p>
	    Anna also has constants. Constants are like variables, except
	    after the initial assignment, they can never be reassigned. This
	    is how you declare a constant:
	  </p>
	  <pre class="anna-code">
pi :== 4.0;    // Declare pi as a constant with value 4.0
	  </pre>
	  <p>
	    To learn more about type inference,
	    click <a href="#type-inference">here</a>. Otherwise, continue
	    reading.
	  </p>
	  <h3><a name="examples-numbers">Numbers</a></h3>
	  <pre class="anna-code">
/*
  Prints 1307674368000. Integers in Anna are arbitrary precision, so there are 
  no overflows
*/
print(1*2*3*4*5*6*7*8*9*10*11*12*13*14*15, "\n");

// Underscores in numeric literals are ignored
print(100_000_000, "\n");

// Hexadecimal, binary and octal integer literals
print(0xdeadbeef, 0b010101, 0o777, "\n");

// This is a decimal integer literal, not an octal one. Use the 0o prefix to 
// specify octal integer literals 
print(0777, "\n");

// Prints 3.5. The output type of Int/Float algebra is always a Float. 
print(1 + 2.5);

// Another way of saying 1.0
print(1_000.0e-3);

/* 
  These two lines are syntax errors - floating point numbers must have at least
  one digit before and after the decimal point 
*/
print( 0. );
print( .5 );
	  </pre>
	  <p>
	    To learn more about how Anna stores numbers efficiently,
	    click <a href="#implementation-numbers">here</a>. Otherwise,
	    keep reading.
	  </p>

	  <h3><a name="examples-lists">Lists</a></h3>
	  <p>
	    Anna has several collection types, types that represent a
	    series of elements. The most basic of these is the List,
	    a collection which stores values at unique integer offsets.
	  </p>
	  <pre class="anna-code">
// lst is a list with four members
lst := ["first", "second", "third", "fourth"]

/* 
  Access list element by index. Regular access is zero based, so 0 is
  the first element, etc.

  Negative indices are offsets from the end of the list, with -1 being 
  the last element in the list
*/

// Prints «first fourth»
print(lst[0], lst[-1]);

// Print the number of members. In this case, that is '4'
print(lst.count, "\n");

// Truncate the list to three elements
lst.count = 3;

// Increase the list length to 15. The new elements will have null as their 
// initial value.
lst.count = 15;

// Create a new list, which contains the members of the original list 
// in the range of 1 (inclusive) to 3 (exclusive)
lst2 := lst[1..3]

// Print the number of members. In this case, that is '2'
print(lst2.count, "\n");

// Prints the first member of lst2, which is "second"
print(lst2[0], "\n");

/* 
  Lists are suitable for use as stacks. Use the push and pop methods
  to add an element to the end and remove the last element,
  respectively, and use the empty? property to check if the stack is
  empty.  
*/

// Push an element to the end of a list
lst2.push("last");

// Remove and return the last element of a list
print(lst2.pop());

// The «empty?» property is 1 if the list is empty, and null otherwise
print(lst.empty?, "\n")

// Join two lists together
lst3 := ["Spoon", "Banana"] ~ lst2;

// Append one list to another
lst ~= ["Cheese", "Eggs"];

/*
  Lists know the type of object they store, e.g. String or Int.

  This is a compile time error - lst3 is a list of strings, not a list of integers
*/
lst3.push(5);

/*
  When creating a list using a collection literal, Anna automatically
  calculates the type objects that can be stored in a list as the
  intersection of all types specified. In this case, the type is the
  intersection of the Int, String and Float types.
*/
weirdList := [1, "foo", 6.666]

/*
  Use template specialization if you want to manually specify the type
  of object to store in a list. This is a list of objects.
*/
objList := «Object»[1, 3, 5, "foo", 6.666]

/* 
  The in operator checks if the specified value exists in the list. 
  It returns null if not, and the integer offset of the item if true.
  In this case, «3» will be printed.
*/
print("foo" in objList, "\n");
	  </pre>
	  <ul>
	    <li>
	      To learn more about the various collection types in Anna, see the section<a href="#collections">More about collections</a>.
	    </li>
	    <li>Notice how there is a property
	    called <code>empty?</code> in Anna? Question marks are
	    valid as part of variable names in Anna, so long as
	    they're not the first character. To learn more about legal
	    Anna variable names an it's naming convensions, read the
	    section <a href="#design-naming">Naming of variables and
	    types</a>.</li>
	  </ul>
	  <h3><a name="examples-list-assign">Assigning to lists of variables</a></h3>
	  <p>
	    Anna also has a convenient short hand syntax for when you
	    want to assign the values of the individual items in a list
	    to different variables.
	  </p>
	  <pre class="anna-code">
/*
  This declares that foo, bar, and baz are integer variables with the values
  of 1, 2 and 3, respectively.

  Note the use of ':=', making this a variable declaration, not a simple 
  assignment. ':==' would also have worked, and would have declared foo, bar 
  and baz as constants.
*/
[foo, bar, baz] := [1, 2, 3];

/*
  This will also work as expected, though someFancyFunction must of course 
  return a collection of Ints, or there will be a compile time type checking
  error.
*/
[foo, bar, baz] = someFancyFunction();
	  </pre>
	  <h3><a name="examples-maps">Maps</a></h3>
	  <p>
	    Maps are collections that map from one object to
	    another. The default Anna map is the HashMap.
	  </p>
	  <pre class="anna-code">
/*
  hash is a HashMap that maps from one String to another String. It
  has four such mappings
*/
hash := ["first":"A", "second":"B", "third":"C", "fourth":"D"]

// Print the number of members. In this case, that is '4'
print(hash.count, "\n");

// Hashes are not ordered, so there is no well defined way to truncate them.
// For that reason, the count property for hashes is read only, making this a 
// syntax error.
hash.count = 3;

// Prints the value associated with the key "third", which is "C".
print(hash["third"], "\n");

// Add another mapping
hash["other"] = "unknown";

// "unknown" is not in the hash, so this returns null
print(hash["unknown"]);

// Set the default value to "I don't know"
hash.default = "I don't know";

// "unknown" is not in the hash, but this time we have set
// a default value for the hash, namely "I don't know".
print(hash["unknown"]);

/* 
  The in operator checks if the specified key exists in the map. Note that this 
  is different from the in operator of the List type, which searches the values,
  not the keys. It returns null if not, and non-null otherwise. In this case, 
  «?» will be printed.
*/
print("unknown" in hash, "\n");
	  </pre>
	  <ul>
	    <li>
	      To learn more about the various collection types in Anna, see the section<a href="#collections">More about collections</a>.
	    </li>
	  </ul>
	  <h3><a name="examples-more-calls">More on function calls</a></h3>
	  <p>
	    Function calls in Anna have a few additional options
	  </p>
	  <pre class="anna-code">
/*
  In addtion to using only ordering to determine input parameters in a
  function call, Anna supports mapping parameters by name as well.
*/
math.sin(value: 1.0);

/*
  Named parameters in function calls can significantly increase code
  readability for calls to function that accept many parameters.
*/

def myFun(Int intVal, Float floatVal, String stringVal, Char charVal)
{
    return intVal + floatVal + stringVal.count + charVal.ordinal;
}

// The following two calls are equivalent
myFun(1, 2.0, "abc", 'g');
myFun(floatVal:2.0, stringVal:"abc", charVal:'g', intVal:1);

// Function parameters can also have a default value. 

def myFun(Int intVal, Float floatVal, String stringVal = "", Char charVal = 'a')
{
    return intVal + floatVal + stringVal.count + charVal.ordinal;
}

// The following three calls are equivalent
myFun(1, 2.0);
myFun(floatVal:2.0, intVal: 1);
myFun(1, 2.0, "", 'a');
	  </pre>

	  <h3><a name="examples-looping">Looping</a></h3>
	  <p>
	    The while loop looks like in any other C-like language
	  </p>
	  <pre class="anna-code">
while(1)
{
    print("Are we having fun yet?\n");
}
	  </pre>
	  <p>
	    Anna does not have a traditional C-like for loop syntax,
	    instead, the each method should be used. To print the values 5
	    to 10 in Anna, do the following:
	  </p>
	  <pre class="anna-code">
(5..11).each(ii){print(ii)}
	  </pre>
	  <p>
	    <code class="anna-code">5..11</code> is a Range object,
	    spanning from 5 (inclusive) to 11
	    (exclusive). The <code class="anna-code">each(ii){...}</code>
	    part is a bit of syntactic suger. A macro will translate
	    it into the equivalent of the following code:
	  </p>
	  <pre class="anna-code">
(5..11).__each__(def (Int !unused, Int idx){print(ii)});
	  </pre>
	  <p>
	    <code class="anna-code">__each__</code> is a method that
	    will execute the supplied block once for each member in
	    the collection. Anna will automatically determine the
	    correct type for the <code class="anna-code">ii</code>
	    variable. All collection type objects, such as maps, lists
	    and ranges provide an each method. It can be used with a
	    single argument, such as above, or it can be used with two
	    arguments, in which case the first argument is the
	    index/key and the second is the value:
	  </p>
	  <pre class="anna-code">
temperatures := ["Monday":31.1, "Tuesday":31.7, "Wednesday": 32.5];
temperatures.each(day,value){print("Day: ", day, ", temperature: ", value, "\n")}
	  </pre>

	  <h3><a name="examples-ranges">Ranges</a></h3>
	  <p>
	    Ranges are objects that represent a finite or semi-finite
	    collection of evenly spaced integers.
	  </p>
	  <pre class="anna-code">
// r is a range from 6 (inclusive) to 10 (exclusive)
r := 6..10

/*
  We can specify a step on a range. The step on this range is 6,
  making the numbers it contains 5, 11 and 17
*/
print(5..20|6);

/*
  Use ... instead of .. to specify an semi-infinite range. This is the 
  range containing all positive numbers.
*/
1...
// And this is the range of all positive, odd numbers:
1|2...

/* 
  Instead of using the .. and ... sugar syntax, we can use the Range
  constructor directly. It takes three arguments, first, last and
  step. This is often useful when writing macros.
*/
 r := Range(6, 10, 1);

/*
  The most common use for ranges is to slice lists and strings
*/

// This outputs [2, 8, 6, 1, 1, 4]
print([9,2,3,8,1,6,8,1,5,1,9,4][1|2...], "\n") 

// This outputs «banana»
print("abrainbadnoah\n"[1|2...]);
	  </pre>
	  <ul>
	    <li>
	      To learn more about the various collection types in Anna, see the section<a href="#collections">More about collections</a>.
	    </li>
	  </ul>
	  <h3><a name="examples-blocks">Blocks</a></h3>
	  <p>
	    In addition to an each method, collection types offer a wide
	    variety of functional programming methods, like map and filter.
	  </p>
	  <pre class="anna-code">
// Prints 2, 3 and 4, on separate lines
[1, 2, 3].map(i){i+1}.each(i){print(i,'\n')}
// Filters out the even numbers for the list
[1, 2, 3, 4].filter(i){i ^mod 2 == 0}
	  </pre>


	  <h3><a name="examples-truth">Truth</a></h3>
	  <p>
	    Anna does not have so called type coercison. There is
	    exactly one value in the Anna language which is considered
	    to be false, and that is the null object.
	  </p>
	  <pre class="anna-code">
if(?)
{
  // Null is the only false value in Anna.
  // This will _not_ get executed
}

if(0)
{
  // The number 0 is an Int objects, and all Int objects are considered
  // to be true, so this will get executed
}

if([])
{
  // En empty list is also true, so this will also get executed
}

if(false)
{
  // This is likely a syntax error -there is no 'true' or 'false' constant 
  // defined in Anna. 
}

	  </pre>	  
	  
	  <h3><a name="examples-andor">and/or</a></h3>
	  <p>
	    
	  </p>
	  <pre class="anna-code">
/* 
  The code below tries to convert the first command line argument 
  of the program to an integer and assign it to the laps variable.
  If that fails, laps is instead assigned a default value of 5.

  Note that the type of an or expression is the intersection of the two types
  that are checked, in this case Int and Int. In other words, the laps variable
  will have the type Int.
*/
laps := Int::convert(system.argument[1]) or 5;

/*
  The code below checks if the first command line argument is
  '--level', and if so, sets the variable 'level' to the second
  command line argument. 

  The return type of an and expression is the type of the second
  argument, in this case Int.

  If no level is set or if the conversion fails, an additional or
  expression sets the default to 2.
*/
level := (system.argument[1] == "--level") and Int::convert(system.argument[2]) or 2;
	  </pre>
	  
	  <h3><a name="examples-null">Null</a></h3>
	  <p>
	    The null object has all members, and their value is
	    null. Calling any method on the null object will return
	    null. Calling a method or accessing a member on the null
	    object is not an error. Many functions in the Anna
	    standard library also return null when given a null
	    argument.
	  </p>
	  <pre class="anna-code">
// This will print «nullnullnullnullnull»
print(?, 1+?, (? as String)~ "hello", "hello" ~ ?, (? as Int) + 1 );
	  </pre>


	  <h3><a name="examples-functions-more">More on defining functions</a></h3>
	  <pre  class="anna-code">
/*
  Previous examples have shown us that this is the standard way to define 
  a function
*/
def myFunctionDecl(Int arg)
{
    return arg+1;
}

/*
  By skipping the name of the function, we can create an anonymous function,
  that is, a function not bound to a constant name. We can do this when we 
  simply want to send a function as a parameter to another function call:
*/
print(functional.reduce([1,2,3,4], 0, def (Int a, Int b){a+b}), "\n");

/*
  Creating a named function is really just a short hand for doing two
  things, namely creating an anonymous function and binding it to a
  constant. We can do the two things separatly with identical meaning,
  like this:
*/

myFunctionConst :== def (Int arg)
{
    return arg+1;
}

/*
  Sometimes, it is useful to bind a function to a variable instead of a 
  constant:
*/
myFunctionVar := def (Int arg){ arg+1 }

/*
  It (obviously) doesn't matter if you're calling a function variable or a 
  function constant. This will print 8.
*/
print(myFunctionVar(7), "\n");

/*
  But a variable can be reassigned. This will print 7, because the function 
  variable has been reassigned.
*/
myFunctionVar = def (Int arg){ arg }
print(myFunctionVar(7), "\n");
	  </pre>
	  

	  <h3><a name="examples-objects">Defining and creating objects</a></h3>
	  <pre class="anna-code">
/*
  Use the class keyword to define your own types
*/
class MyClass
{
    // This declares that the type has a member of type Int with the 
    // name myMember and the initial value 7.
    myMember := 7;

    // This declares that the type has a method named myMethod
    def myMethod()
    {
        // If an identifier can't be found in the scope of the local 
        // function, the object scope is automatically checked.
        print(myMember, "\n");

        // The identifier «this» automatically exists and points to
        // the current object
        print(this.__type__.name, "\n");
    }

}

/*
  Call a type in order to create a new object instance of that type.
  This calls the constructor, which sets the value of myMember to 7.
*/
myInstance := MyClass();

// This will print «7» and «MyClass».
myInstance.myMethod();

// Member variables are public by default.
// For now, there is no support for non-public members.
myInstance.myMember = 9;

// This will print «9» and «MyClass».
myInstance.myMethod();
	  </pre>
	  
	  <h3><a name="examples-properties">Properties</a></h3>
	  <pre class="anna-code">
/*
  Properties are method calls that look like member variables. For example, the
  count property of the List type returns the number of elements in the list.
*/
myList := [1, 2, 3];
print(myList.count, "\n"); // This prints 3
myList.push(0);
print(myList.count, "\n"); // This prints 4

/*
  Some properties are read only, like List::empty?, but others can be written to
  as well as read. MutableList::count can be written to.
*/
myList.count = 2; // This truncates the list
print(myList, ' ', myList.count, "\n"); // This prints [1, 2] 2
myList.count = 5; // This will null-pad the list to five elements.
print(myList.count, "\n"); // This prints 5

/*
  Defining you own properties is straight forward. Define a getter and
  optionally a setter method, both with suitable parameter lists. Then
  declare a member variable and add a property attribute to it, giving
  the name of the getter/setter as parameters.
*/
class PropertyExample 
{
    propValue := 0;

    def myGetter()
    {
        propValue;
    }

    def mySetter(Int val)
    {
        print("Setting myProperty to %\n" % [val]);
        propValue = val;
    }

    var Int myProperty (property(myGetter, mySetter));
}

/*
  For read only properties, there is a slightly less verbose short
  hand. Simply define a suitable getter method and add the property
  attribute directly to the getter method like this:
*/
class PropertyExample2
{
    def myProperty() (property)
    {
        3;
    }
}
	  </pre>

	  <h3><a name="examples-static">Static members</a></h3>
	  <pre class="anna-code">
// When defining a type, members can be set as static using the 
// static attribute

class MyClass
{
    var Int staticVar (static);
}

// Static variables are shared between all instances of an object,
// so this will print '7'
mt1 := MyClass(), mt2 := MyClass();
mt1.staticVar = 7;
print(mt2.staticVar);

// Static members can be accessed by using the :: operator
MyClass::staticVar = 9;

// If a method is accessed using the static member access operator, the unbound
// version of the method is returned. The unbound method does not have an 
// implicit «this», so it needs an additional input parameter, which is the
// first parameter in the list.
myList := [];

// This is identical to myList.push(7)
MutableList::push(myList, 7);

// Methods can be defined as static, just like variables
class MyClass
{

    def Object staticMeth() (static)
    {
        // In static methods, this does not point to the current 
        // object instance (there is none), instead this points
        // to the type. 

        // This might seem meaningless, but can actually be quite useful 
        // in static methods of subclassed types.
	print(this, " ", this::staticMeth, "\n");
    }

}

def main()
{
    MyClass::staticMeth();
}
	  </pre>

	  <h3><a name="examples-convert">Converting and formating</a></h3>
	  <p>
	    Converting is the act of taking a piece of data
	    represented as one type of object and creating a new object
	    of a different type that represents the same piece of
	    data. Conversion can be lossless (such as when converting
	    an Int to a String) or lossy (such as when converting a
	    Float to an Int). 
	  </p>
	  <pre class="anna-code">
/* 
  All conversions in Anna are by convention doneusing the static
  convert method.
*/
sevenString := String::convert(7);
sevenFloat := Float::convert(sevenString);
sevenComplex := Complex::convert(sevenFloat);

	  </pre>

	  <h3><a name="examples-mutable">Mutable and imutable objects</a></h3>
	  <p>
	    Some objects in Anna are mutable, i.e. they can be changed
	    after they where created. Others are imutable. It
	    sometimes makes sense to provide both a mutable and an
	    imutable version of the same basic type. Anna does not
	    currently support automatically stripping mutating methods
	    from a mutable type to create an imutable version,
	    instead, two separate types must be created. When creating
	    such a pair of types, the Anna convention is that both
	    types of objects should have two properties,
	    named <code class="anna-code">freeze</code>
	    and <code class="anna-code">thaw</code>, that can be used
	    to obtain a mutable or imutable object with the same
	    content.
	  </p>
	  <pre class="anna-code">
/*
  The String literal is of the ImutableString type, which is
  imutable. This is a compile time error, because ImutableString 
  does not have a __set__ function.
*/
imutableString :="foo";
imutableString[0] = 'F';

/*
  Use the thaw property to get a mutable version of the String.
  This will work as expected.
*/
mutableString :="foo".thaw;
mutableString[0] = 'F';

/*
  You can use the ~= append operator both on mutable and imutable
  strings. When used on imutable strings, every call to ~= will create
  a new ImutableString. When this happens in e.g. a loop, it can
  lead to a lot of copying, which can make your code slow. In such 
  situations, you can speed up the program by making sure the String 
  you're appending to is mutable:
*/
result := "".thaw;
someCollection.each(item){ result ~= doSomeProccessing(item) }

/*
  The List collection literal is mutable, so this is ok.
*/
mutableList := [1,2,3];
mutableList[0] = 0;

/*
  MutableList.freeze returns an ImutableList, so this is a compile time error.
*/
imutableList := [1,2,3].freeze;
imutableList[0] = 0;

/*
  The thaw property of a mutable object returns itself, as does the
  freeze property of an imutable object.
*/
useless := "useless".freeze;
alsoUseless := ["useless"].thaw;
/* 
  Note that when thawing an already mutable object, the convention is
  to return the object itself, not a copy.

  This will print «I'm a little tea»
*/

  thing := "tea";
  thing2 := thing.thaw;
  thing2 ~= "pot";
  print("I'm a little %\n" % [thing]);
	  </pre>
	  <p>
	    For more information on mutability in Anna, see
	    the <a href='#misc-mutability'>Mutable</a> section of the
	    manual.
	  </p>
	  <h3><a name="examples-specialization">Template specialization</a></h3>
	  <p>
	    
	  </p>
	  <pre class="anna-code">
/*
  Templates are specialized using «». This creates an empty list of Int items.
*/
lst := MutableList«Int»()

/* 
  Explicitly specializing a template is superflous when all template
  parameter types can be calculated from the constructor call. This
  will also create a list of Int items.
*/
lst2 := MutableList(5,6,7);

/*
  The specialization of collection literals can be specified
*/

// Empty list of integers
lst3 := «Int»[];

// Empty HashMap mapping from String to Char
hash := «String, Char»[];

/*
  A simple example of how to create your own template type.

  Foo uses Int as the default type for the %A template parameter.

  All templated arguments must be prefixed with a '%' symbol. Template
  arguments that are type names must begin with an upper case letter.
*/
class Foo (template(%A:Int)) {
    def %A bar(%A a, %A b){
        a+b;
    }
}

def Int main()
{
    foo := Foo«Float»();
    print(foo.bar(3.0,4.0));
}

/*
  Template specialization parameters aren't restricted to being
  types. In this example, we specify which member method should be
  called by using a template.  
*/
class Foo (template(%op:__add__)) 
{

    def Int bar(Int a, Int b)
    {
        a.%op(b);
    }

}

def Int main()
{
    foo := Foo();
    print(foo.bar(3,4),"\n");
    boo := Foo«__sub__»();
    print(boo.bar(3,4),"\n");
}

// On some keyboard layouts, «» may not be easily accessible. And If you're
// not using a unicode character set, «» may not even be available to you. 
// As a fallback, Anna also supports using &lt;&lt;&gt;&gt; instead.
&lt;&lt;Int&gt;&gt;[];
	  </pre>
	  <ul>
	    <li>
	      Templated identifiers in a template definition all need
	      to start with a % symbol. This makes them into internal
	      identifiers. You
	      can <a href="#misc-internal-identifiers">read up on
	      internal identifiers here</a>.
	    </li>
	  </ul>
	  <h3><a name="examples-continuations">Continuations</a></h3>
	  <p>
	    
	  </p>
	  <pre class="anna-code">
TODO
	  </pre>


	  <h3><a name="examples-expandCode">The expandCode macro</a></h3>
	  <p>
	    Sometimes, one has to write a large bulk of nearly
	    identical code expressions. I these cases, it is often
	    possible to use the expandCode macro to reduce the amount
	    of repetition.
	  </p>
	  <pre class="anna-code">
// This is a boring piece of code
first := getNextValue(someValue, someOtherValue);
second := getNextValue(someValue, someOtherValue);
third := getNextValue(someValue, someOtherValue);
fourth := getNextValue(someValue, someOtherValue);
fifth := getNextValue(someValue, someOtherValue);

// This is exactly equivalant to the above, but less redundant
expandCode(
    %var := getNextValue(someValue, someOtherValue),
    var: [first, second, third, fourth, fifth]);    
	  </pre>
	  <ul>
	    <li>
	      <code class="anna-code">expandCode</code> is just a regular
	      Anna macro. You can <%! toggleCodePopup("expandCode", "check out the source code") %>.
	    </li>
            <%! codePopup("expandCode", "bootstrap/expandCode.anna") %>
	    <li>
	      The placeholders in the template code all need to start
	      with a % symbol. This makes them into internal
	      identifiers. You
	      can <a href="#misc-internal-identifiers">read up on
	      internal identifiers here</a>.
	    </li>
	  </ul>

	  <h3><a name="examples-switch">The switch macro</a></h3>
	  <p>
	    The Anna version of the classical C switch statement
	    contains some changes:
	  </p>
	  <ul>
	    <li>
	      The syntax is slightly altered to follow how all Anna
	      code is structured.
	    </li>
	    <li>
	      No <code class="anna-code">break</code> keyword is
	      needed at the end of a case - execution never continues
	      into an alternative case.
	    </li>

	    <li>
	      Any types of values can be switched on, not just
	      integers.
	    </li>
	    
	    <li>
	      Aside from checking for equality, the switch statement
	      can also be used to check if a value is contained in a
	      specified collection by using code
	      like <code class="anna-code">cases(someCollection)</code>
	      keyword.
	    </li>
	    <li>
	      It is also possible to check if the given value can
	      masque as another type. This is done by
	      writing <code class="anna-code">case(varName as
	      SomeType)</code>,
	      where <code class="anna-code">SomeType</code> is the
	      name of the type you want to test for,
	      and <code class="anna-code">varName</code> is a variable
	      name. If the test succeeds, the
	      variable <code class="anna-code">varName</code> will be
	      declared to be of
	      type <code class="anna-code">SomeType</code> and hold
	      the value from the original switch condition.
	    </li>
	  </ul>
	  
	  <pre class="anna-code">
/*
  Switch containing Int:s
 */
(0..10).each(foo)
{
    switch(foo)
    {
	case(2,4,6,8)
	{
	    print("Even\n");
	}

	case(7)
	{
	    print("Seven\n");
	}

	cases(1..5|2)
	{
	    print("Odd\n");
	}

	default
	{
	    print("Whatever\n");
	}
    }
}

/*
  Switch containing strings
*/
["abc", "a", "aa", ?, "bbb"].each(bar)
{
    switch(bar)
    {
	case("abc")
	{
	    print("abc\n");
	}

	case("b", "bb", "bbb")
	{
	    print("Bunch of b:s\n");
	}

	cases(["a":?, "o":?, "u":?, "e":?, "i":?, "y":?])
	{
	    print("Vowel\n");
	}

	default
	{
	    print("Don't righly know\n");
	}
    }
}

// Loop over a series of items and classify them using their type
[3, 4.0, "foo", 'g'].each(item)
{
    switch(item)
    {
	case(i as Int)
	{
	    print("It is an Int, its square is ", i*i, "\n");
	}

	case(f as Float)
	{
	    print("It is a Float, its square root is ", math.sqrt(f), "\n");
	}

	case(s as String)
	{
	    print("It is a String, its length is ", s.count, "\n");
	}

	default
	{
	    print("Don't know, don't care\n");
	}
    }
}
	  </pre>
	  <p>
	    <code class="anna-code">switch</code> is just a regular
	    Anna macro. You can <%! toggleCodePopup("switch", "check out the source code") %>.
	  </p>

          <%! codePopup("switch", "bootstrap/switch.anna") %>
  
	  <h3><a name="examples-struct">The struct macro</a></h3>
	  <p>
	    
	  </p>
	  <pre class="anna-code">
/*
  The struct macro is used to easily create an object to store a 
  specific list of fields in. All fields are typed based on the 
  input provided to the struct macro.
*/
myVar := struct(someNumber: 7, someString: "hello", someList: [1,2,3]);
// Prints «10 helloworld 2»
print(myVar.someNumber + 3, ' ', myVar.someString ~ "world", myVar.someList[1]);
	  </pre>
	  <p>
	    <code class="anna-code">struct</code> is just a regular
	    Anna macro. You can <%! toggleCodePopup("struct", "check out the source code") %>.
	  </p>

	  <%! codePopup("struct", "bootstrap/struct.anna") %>
	  
	  <h3><a name="examples-enum">The enum type</a></h3>
	  <p>
	    
	  </p>
	  <pre class="anna-code">
enum MyEnum
{
    foo,
    bar = 32,
    baz
}

enum MyEnum2
{
    aaa=-7,
    bbb,
    ccc
}

def main()  
{
    // This will print the names of these three enum values, namely «foo bar baz»
    print(MyEnum::foo, ' ', MyEnum::bar, ' ', MyEnum::baz, "\n");
    // This will print the actual integer value, which is 0
    print(MyEnum::foo.__value, "\n");
    // MyEnum2 starts at offset -7, so this will print «-7 -6 -5»
    print(
        MyEnum2::aaa.__value, ' ', MyEnum2::bbb.__value, ' ', 
        MyEnum2::ccc.__value, "\n");
}
	  </pre>

	  <p>
	    <code class="anna-code">enum</code> is just a regular
	    Anna macro. You can <%! toggleCodePopup("enum", "check out the source code") %>.
	  </p>

	  <%! codePopup("enum", "bootstrap/enum.anna") %>
	  <h3><a name="examples-macros">Defining your own macros</a></h3>
	  <pre class="anna-code">
/*
  A simple macro that takes a string literal and reverses the order of the 
  characters in it
*/
macro reverseStringLiteral(node)
{
    /*
      Check that we have exactly one argument to the macro, otherwise set the 
      error flag, print an error message and return a null literal. 
    */
    checkCallCount(node, 1);
    /*
      Check that node[0] is a StringLiteral ast symbol, otherwise set the 
      error flag, print an error messagge and return a null literal. 
    */
    checkNodeType(node[0], StringLiteral);
    /*
      Return a new StringLiteral, that is the reverse of the original literal
    */
    return StringLiteral(node, (node[0] as StringLiteral).payload[-1|-1...]);
}

/*
  Use the expand call to tell the Anna interpreter that you wish to
  use the macros of a library for macro expansion.

  If the above macro was defined in the file myStringMacro.anna, then it could
  be used like this in another file:
*/
expand(myStringMacro);

def main()
{
    // Prints olleH
    print(reverseStringLiteral("Hello"));
}
	  </pre>
	  <p>
	    The macro call is just a wrapper around the def call to
	    shorten the code a bit. We could have written the above
	    macro using the following def syntax:
	  </p>
	  <pre class="anna-code">
def parser.Node reverseStringLiteral(parser.Call node)
{
    use(parser);
    ...
}
	  </pre>
	  <ul>
	    <li>
	      As can be seen in the code above, there are several
	      convenience macros that are used for performing error
	      checks in macros. If you want to learn more about these
	      macros, see the documentation for
	      the <a href="api/global/macroUtil.html">macroUtil
	      library</a>.
	    </li>

	    <li>
	      Macros deal with AST nodes. If you want to learn more
	      about these, see the documentation for
	      the <a href="api/global/parser.html">parser library</a>.
	    </li>

	  </ul>
	  <h3><a name="examples-errors">Error handling</a></h3>
	  <p>
	    
	  </p>
	  <pre class="anna-code">
TODO
	  </pre>

	  <h2><a name="intro_short">Anna in a single sentence</a></h2>
	  <div class='anna-subheading'>Wherein the author demonstrates his mastery of commatation</div>
	  <p>
	    Anna is a statically, structurally typed computer language that
	    supports LISP style macros, functions and types as first class
	    citizens, closures and continuations; it has a C-style syntax
	    and its aim is to combine the expressiveness and power of LISP
	    with the type safety, familarity and control of Java.
	  </p>
	  <p>
	    Note the use of a semicolon to combine two separate sentences into
	    something that works around the originally stated limitations and
	    still manages to be perfectly readable. That is the essence of Anna.
	  </p>
	  <p>
	    Sounds good? To learn more about Anna, check out the following sections:
	  </p>
	  <ul>
	    <li><a href='#examples'>Examples - learning by doing</a></li>
	    <li><a href='#structural_typing'>Structural typing - duck typing rethought</a></li>
	    <li><a href='#macros'>Macros - redefining the problem to fit the solution</a></li>
	    <li><a href='#misc'>An odd number of legs for a horse to have</a>, various oddities about Anna.</li>
	    <li><a href='#continuations'>Continuations</a>, the power to shoot yourself in the foot an infinite number of times.</li>
	  </ul>
    
	  <h2><a name="intro_long">Gentle Anna</a></h2>
	  <div class='anna-subheading'>Wherein strategic use of mood lighting makes
	    Anna seem less intimadating.</div>
	  <p>
	    Anna is a computer programming language. That is, it is a
	    language designed to be written and read by humans, but which
	    contains a series of instructions designed to be executed by
	    computers. There are many programming languages, all with their
	    own strengths and weaknesses.
	  </p>
	  <ul>
	    <li>
	      Some languages are low level, meaning they force you to
	      go into great detail about how you want to perform any
	      actions, whereas other are high level, meaning they skim
	      the details and force the computer to figure out more by
	      itself. As computers grow faster and programmers grow
	      lazier, the definition of what constitutes a high level
	      language is shifting. What was a high level language 30
	      years ago is considered a very low level language
	      today. High level languages are usually slower, and they
	      almost always require much more memory, but they are
	      also easier for the programmer to write, and usually
	      less error prone. Anna is a high level language. It is
	      designed in a way that should make it possible to make
	      Anna programs significantly faster than many high level
	      languages, though the current interpreter does not do
	      so. Even given a significantly better compiler, many
	      type of programs written in Anna are unlikely to match
	      the speed of a well written program in a low level
	      language.
	    </li>
	    <li>
	      Some languages are statically typed, meaning the
	      programmer has to tell the computer what type of data is
	      being processed at every step of a program, other are
	      dynamically typed, meaning the programmer only tells the
	      computer what steps to take, and the computer will find
	      out what type of data to operate on when the program is
	      run. Statically typed languages avoid some types of bugs
	      because it can figure out that some operations won't
	      work on the specific type of data you're operating on,
	      and will warn you in advance that your code is broken,
	      but dynamically typed languages require less verbosity
	      from the programmer. Statically typed languages are
	      usually also faster than dynamically typed
	      languages. Anna tries to find a middle ground between
	      these two by being statically typed, but making the
	      computer figure out the actual type for you when
	      possible using a process known as type inference, so
	      that you don't need to repeat yourself needlessly.
	    </li>
	    <li>
	      Pretty much all computer languages allow you to extend
	      the language to new domains. The way this is usually
	      done is through software libraries. If we make an
	      analogy to regular human languages, like english, a
	      software library is like a set of new words. We can add
	      new words to most languages that allow us to discuss new
	      subjects, such as the sending of emails. What most
	      computer languages do not allow, however, is for us to
	      redefine the grammar of the language; that is, the basic
	      structure of the language is constant. The LISP
	      language, invented over 50 years ago, actually provided
	      a means to redefine some parts of the grammar of the
	      language. This feature is extremely powerful, and it has
	      allowed LISP to stay relevant even today. Many people
	      rever LISP as some kind of divine and perfect ideal of a
	      language, though precious few of them actually use it
	      much. The downside of LISP is that the most basic level
	      of underlying structure of the language - the part of
	      the grammar that can not be changed, is extremely
	      simple. LISP code is always a nested list of lists,
	      something which is not very easy to read or understand
	      for humans. No matter how much you redefine the high
	      level grammar of LISP, it will always keep that basic
	      structure of lists of lists, and humans tend to find
	      that hard to handle. Anna is different from LISP in this
	      regard. To the computer, Anna looks like a list of
	      lists, very much like LISP, but when writing programs
	      for Anna, there is a special translation layer called
	      the sugar, that allows you to write your code in a way
	      that is much more intuitive (and familiar) to human
	      beings. This way, Anna gives you the power to grow and
	      redefine the language, just like in LISP, but still lets
	      you use a syntax that most people find more intuitive
	      and readable.
	    </li>
	    <li>
	      There are many styles of programming. These include Object
	      oriented programming, imperative programming, generic
	      programming and functional programming. Some program problems
	      are solved better with one approach, others with another, but
	      no single approach is optimal for all types of
	      problems. Pretty much all languages support all these styles
	      to some degree; they rely more on a way of thinking than on
	      any specific language feature. However, Anna contains many
	      features to make all these styles pleasant to use. Thus you
	      can be reasonably confident that no matter what the problem
	      is, Anna provides you with the tools to solve it efficiently.
	    </li>
	  </ul>
	  <h3>Moving on</h3>
	  <p>
	    That should give you an idea about Anna. If you want more in
	    depth information about some aspect of Anna, follow one of the
	    links below.
	  </p>
	  <ul>
	    <li>
	      <a href='#examples'>Anna by examples.</a> If you want to see
	      theory turned into practice.
	    </li>
	    <li>
	      <a href='#macros'>Macros - redefining the problem to fit
		the solution</a>
	    </li>
	    <li>
	      <a href='#misc'>An odd number of legs for a horse to
		have</a>, various oddities about Anna.
	    </li>

	  </ul>
	  <h2><a name="intro_lisp">Anna for LISP programmers</a></h2>
	  <div class='anna-subheading'>Old is the new new.</div>
    
	  <p>
	    Anna is a statically typed language with a front end that allows
	    you to write your code with a C-like structure, e.g. using infix
	    operators, braces and brackets. What sets Anna apart from other
	    such languages is it's support for LISP-features such as
	    LISP-style macros, continuations, closures and anonymous functions.  
	  </p>
	  <ul>
	    <li>
	      Instead of the backtick operator of LISP, Anna uses
	      named substitutions. This involves slightly more
	      typing, but often makes the intention of the code
	      clearer. See the section <a href="#misc-format">The %
	      (format) operator</a> for more information.
	    </li>
	    <li>
	      The Anna type system is static, but it uses structural
	      typing, not inheritance, to determine if two types are
	      compatible. Structural typing means that if the type of
	      variable B contains all members of the type A, with
	      compatible type signatures, then B can be freely cast
	      into a variable of type A. For more information, see the
	      section titled <a href='#structural_typing'>Structural
	      typing</a>.
	    </li>
	    <li>
	      <a href='#examples'>Anna by examples.</a> If you just want to
	      dig in to the syntax.
	    </li>
	    <li>
	      <a href="#sugar">Sugar and spice</a> - How the front end
	      sugar works and what Anna looks like without makeup.
	    </li>
	  </ul>
    
	  <h2><a name="intro_c">Anna for Java, C, C++, Go and D programmers</a></h2>
	  <div class='anna-subheading'>Confusingly familiar.</div>
	  <p>
	    Anna is a C-like language with garbage collection and a powerful
	    object system. At first glance, Anna feels very familiar to Java
	    and C# programmers, and coders of C, C++ and other C-like
	    languages should pick up the changes relatively quickly as
	    well. Anna does have a few nifty short cuts to save a few
	    keypresses, including:
	  </p>
	  <ul>
	    <li>
	      There are lots of situations in statically typed
	      languages where you need to repeat the type of a
	      specific expression over and over and over. Anna is
	      pretty clever about figuring out what type an expression
	      should have, and not force you to write it out multiple
	      times. Variables in Anna are usually declared by writing
	      something like <code class="anna-code">foo :=
	      bar();</code>. Note the use of := instead of plain old
	      =. This makes the above expressioin into a variable
	      declaration, not an assignment. The correct type for the
	      foo variable in the code above is determined at compile
	      time by inspecting the return type of the foo
	      function. In much the same way, Anna can usually
	      determine the return type of functions. Go and C#
	      programmers should recognise this feature.
	    </li>
	    <li>
	      Say you've written a class A, and it implements all of
	      the members of an interface/class B. You do not need to
	      explicitly say that A <em>is</em> a B, the interpreter
	      figures out for itself that the class A can masque as
	      B. This is called structural typing. The benefits of
	      structural typing may not be obvious at once, but it
	      makes it easier to write unit tests and makes code
	      easier to adapt to new uses. The same basic ideas have
	      been popularized in dynamically typed langauges like
	      Python in recent years, where it is usually referred to
	      as duck typing. Go programmers should recognise this
	      feature.
	    </li>
	    <li>
	      There are no statements in Anna, only expressions. The
	      if expression, for example, returns the output of the
	      conditional block that was executed. The Anna equivalent
	      of the C ternary operator
	      becomes <code class="anna-code">foo = if (a>3) {3} else
	      {a}</code>. If a function reaches the end of it's block
	      without encountering a return statement, the output from
	      the last expression of the function is returned.
	    </li>
	  </ul>
	  <p>
	    This is all fine and good, but hardly something that makes it
	    worth ones time to switch to a whole other programming
	    language. What really sets Anna apart is the level of
	    metaprogramming it allows. Anna allows you to redefine the very
	    building blocks of the language. Use/with statements, exceptions
	    and loop constructs can all be created or altered in order to
	    extend the language in any way you choose. Even better, such
	    extensions are written in the language itself, no C++-style
	    separate template metaprogramming language is needed.
	  </p>
	  <p>
	    There are two basic building blocks of Anna that allow you to
	    redefine the language. They are macros and continuations. We'll
	    explan them brifely. C and C++ coders may think to themselves
	    that they know macros, and they really aren't that great. In one
	    sense they'd be correct, because C-style macros really aren't
	    that great. Ignore C macros, lets instead talk about Anna style
	    macros, because they're actually pretty neat. But first, just a
	    little bit of background.
	  </p>
	  <h3><a name="intro-c-macros">Macros, redefined</a></h3>
	  <p>
	    Pretty much all compilers will read a source file into some kind
	    of tree of nodes called an abstract syntax tree, or AST for
	    short. 
	  </p>
	  <p>
	    Every node in the AST tree above is at some point a
	    regular Anna object, and the compiler can alter these
	    nodes as it sees fit. That's pretty nifty, but how does
	    that tie in with us? Anna has two keywords for defining a
	    function, namely <code class="anna-code">def</code>
	    and <code class="anna-code">macro</code>. They work pretty
	    much the same, they both let you define a piece of code
	    with a few input parameters and a few output
	    parameters. There are two differences between the two,
	    firstly that macros are run at compile time, and secondly
	    that the input and output of the macros is an AST. The
	    implications of this may not be obvious at once, so we'll
	    consider a few examples. First, look at the code snippet
	    below:
	  </p>
	  <pre class="anna-code">
macro replaceObjectWithInt(node)
{
    node.replaceChildren(child)
    {
        id := child as Identifier;
	if(id and id.name=="Object")
	{
	    return Identifier(id, "Int");
	}
	child;
    }
    return node;
}
	  </pre>
	  <p>
	    What does the above code do? If you can't guess, the
	    correct answer is that it walks the entire AST and
	    replaces all identifiers that have the
	    value <code class="anna-code">Object</code> with a new
	    identifier with the
	    value <code class="anna-code">Int</code>. Instant
	    templating!  Of course, the Anna standard library
	    already <em>has</em> a very nice templating system, so
	    there is no need to write your own, but the possibility to
	    make that type of additions to the language is actually in
	    your hands.
	  </p>
	  <p>
	    The most common reason for using macros is to construct
	    sublanguages, also called domain specific languages. The Anna
	    front end is pretty loose about what input it will accept -
	    pretty much anything that can be reasonably parsed into an AST
	    is allowed. That opens up the possibility to create macros that
	    parse things using a completely different syntax. For example,
	    one could write a macro that allows you to create date objects using
	    the standard ISO data format:
	  </p>
	  <pre>
birthday := isoDate(1978-05-20, 12:34:00);
	  </pre>
	  <p>
	    It is possible to create a list search interface like LINQ
	    in Anna, but unlike LINQ, it is not a special case grafted
	    onto the compiler. Anna provides a general purpose
	    framework that allows anyone proficiant in Anna to create
	    libraries that do the same thing LINQ does, but better.
	  </p>
	  <p>
	    Various parts of Anna, including
	    the <a href="#examples-switch">switch expression</a> and
	    the <a href="#examples-enum">enum type</a> are actually implemented using macros.
	  </p>
	  <h3><a name="intro-c-continuations">Continuations, continued</a></h3>
	  <p>
	    This paragraph is for C and C++ coders that know what a
	    longjmp is. If you don't, feel free to skip this
	    paragraph. So, you know what a longjmp
	    is? Congratulations! A continuation is exactly like a
	    longjmp, except that the restrictions placed on longjmps
	    are removed. Specifically, longjmp:s only allow you to
	    «rewind» the stack and continue execution further down on
	    the function stack, whereas continuations allow you to
	    jump up, down or sideways into a whole other branch of the
	    stack - as many times as you like. That's it. Nothing
	    more. Simple. Because continuations can more or less
	    arbitrarily control program flow, they can be used to
	    easily implement various high level features like
	    exception handling and green threads. Feel free to skip
	    the next paragraph, which says the same thing with
	    smaller words.
	  </p>
	  <p>
	    Continuations are a way to explicitly control the location that
	    a function will return to when it finishes. Continuations are an
	    extremely powerful language feature that can be used to
	    implement exception handling, green threads and a multitude of
	    other features.
	  </p>
	  <h3>Moving on</h3>
	  <p>
	    Very few Anna programmers will directly use continuations
	    on a regular basis. Most will stay away from writing their
	    own macros as well. What makes these features exciting is
	    that they allow other programmers to evolve the
	    languages. Changes that traditionally require a deep
	    understanding of the compiler and that can only be
	    implemented by a small handful of people are suddenly
	    within the grasp of any language guru. (Not that there are many Anna gurus around at the moment...)
	  </p>
	  <p>
	    This concludes the Anna overview for people familiar with
	    the C class of languages. You now need to decide where to
	    go next:
	  </p>
	  <ul>
	    <li>
	      Read <a href='#examples'>Anna by examples</a> if you
	      feel ready to see some code.
	    </li>

	    <li>
	      To learn more about continuations,
	      click <a href="#continuations">here</a>.
	    </li>
	    
	    <li>
	      Or you can read a discussion on the
	      various <a href='#design'>Design choices</a> in Anna.
	    </li>
	    
	  </ul>
	  
	  <h2><a name="intro_script">Anna for Python and Ruby programmers</a></h2>
	  <div class='anna-subheading'>Wherein...</div>
	  
	  <p>
	    In daily use, Python and Ruby are probably the languages
	    that most resemble Anna. Anna code looks a fair bit like
	    C, which means the code may not look like Python or Ruby,
	    but once you've gotten used to it, the way the language
	    feels and works should be very familiar.
	  </p>
	  <pre class="anna-code">
def Int fibonacci(Int n) 
{
    return if (n &lt; 2) { 1 } else { fibonacci(n-2) + fibonacci(n-1) }
}

def main()
{
    print(fibonacci(20), "\n");
}
	  </pre>
	  <p>
	    Like Ruby, but unlike Python, Anna does not have
	    statements, only expressions. A function declaration is an
	    expression that returns a function. Thus, you do not need
	    Pythons's rather limited lambda expression to create anonymous
	    functions:
	  </p>
	  <pre class="anna-code">
functionExpectingAFunctionAsAParameter(def (){print("I am happy\n")});
	  </pre>
	  <p>
	    Much like in Ruby, there is a very simple shortcut for
	    throwing in a block of code as an additional parameter in
	    Anna. If you simply append a code block afer a function
	    call, Anna will interpret it as a function parameter. The
	    above code example could just as well have been written
	    like this:
	  </p>
	  <pre class="anna-code">
functionExpectingAFunctionAsAParameter {print("I am happy\n")};
	  </pre>
	  <p>
	    Another way in which Anna is like Python and Ruby is the
	    convenient support for functional programming. Say we haxe
	    EXAMPLE FIXME LALALA.
	  </p>
	  <pre class="anna-code">
FIXME! Functional programming example here
	  </pre>
	  <p>
	    Blocks of code, by the way, are anonymous functions that take 0
	    parameters.
	  </p>
	  <h3>Static typing, but not as bad as it seems</h3>
	  <p>
	    So. Enough dodging, lets address what is likely to be the major
	    cause of concern for Ruby- and Python lovers. Static typing. In
	    Anna, you will sometimes have to do slightly more typing. It's
	    true. Anna does its best to figure out types for you using type
	    inference, and when it can, you don't have to tell her, but
	    there are still situations where you have to talk about
	    types. Lets break it down:
	  </p>
	  <ul>
	    <li>
	      When declaring a variable, if you supply an initial
	      value, the variable will take the type of that value. If
	      you don't you'll have to give the type. 
	    </li>
	    <li>
	      When defining a function, you will have to supply the type of
	      each input parameter and in rare cases also the return
	      type. (Most of the time, Anna can figure out the return type
	      by examining the function body)
	    </li>
	  </ul>
	  <p>
	    The upshoot of this is that you have to do significantly less
	    type checking when validating your input arguments (and you do
	    validate your input arguments, don't you?), regaining you some
	    of those lost key strokes. You also get much better ahead of
	    time code checking - some silly mistakes can be caught earlier
	    in the development process in Anna.
	  </p>
	  <p>
	    Static typing does catch some bugs at compile time that aren't
	    tiggered until you happen to run a specific function with a
	    specific combination of parameters in dynamic languages. That is
	    a fact. Static typing also involves more typing. Another
	    fact. It is hoped that the «smart» static typing of Anna is the
	    optimal tradeoff - you get most of the safety and a more
	    tolerable amount of typing than in other statically typed
	    languages.
	  </p>
	  <h3>Duck typing</h3>
	  <p>
	    The practice of duck typing, e.g. not checking for specific
	    function types when validating the type of an input parameter,
	    but only checking that the required members are present, is
	    increasingly popular in modern dynamically typed programming
	    languages. This technique makes code significantly more
	    reusable, and can also to a degree decouple modules from each
	    other. On the surface, duck typing seems to be an idea that can
	    only work in dynamically typed languages, but statically typed
	    languages like Anna can actually implement a close equivalnt,
	    something called structural typing.
	  </p>
	  <p>
	    Structural typing means that if a function expects a parameter
	    of type <code class="anna-code">A</code>, and type <code class="anna-code">B</code> contains all the
	    same members as A, and all the members have compatible
	    signatures, then type B can be used as input to the function,
	    regardless of if <code class="anna-code">B</code> actually inherits from
	    type <code class="anna-code">A</code> or not.
	  </p>
    
	  
	  <h3>Moving on</h3>
	  <p>
	    This concludes the Anna overview for people familiar with
	    scripting languages. You now need to decide where to
	    go next:
	  </p>
	  <ul>
	    <li>
	      Read <a href='#examples'>Anna by examples</a> if you
	      feel ready to see some code.
	    </li>
	    
	    <li>
	      Or you can read a discussion on the
	      various <a href='#design'>Design choices</a> in Anna.
	    </li>
	    
	  </ul>
	  

	  <h1><a name="structural_typing">Structural typing</a></h1>
	  <p>
	    Most languages, including Python and Java, have operations
	    that let you check if an object explicitly states that it
	    implements some interface. You have, for example,
	    the <code class="anna-code">Comparable</code> interface in
	    Java, which defines a set of methods that allow you to
	    compare one object to another. The realization that it
	    doesn't, or at least shouldn't, matter if an object
	    explicitly states that it implements a specific interface,
	    so long as it actually does implement it, has struck a
	    great number of people over the ages. In python, it has
	    become popular to avoid
	    the <code class="anna-code">is</code> operator to perform
	    type checking, and instead simply check if the relevant
	    fields and methods are present in an object. This idea is
	    called duck typing, and while the idea and its usage
	    predates Python, the concept of duck typing has been
	    widely adopted as best practice by the Python community.
	  </p> 
	  <p>
	    Anna takes the concept of duck typing and runs with it. It
	    is not possible in Anna to check if an object inherits
	    from a specific type. There is simply no inheritance
	    information available. You can _only_ check if an
	    object <code class="anna-code">A</code> is compatible with
	    a type <code class="anna-code">B</code> using duck
	    typing. It is also trivial to perform operations on types
	    in order to type templates dynamically. For example, say
	    you want to test if the
	    object <code class="anna-code">someObject</code> has all
	    the members common to both
	    the <code class="anna-code">String</code>
	    and <code class="anna-code">Int</code> types. That is
	    easily done using this code:
	  </p>
	  
	  <pre>
if(someObject is String.intersect(Int)) 
{
    ...
}
	  </pre>
	  <p>
	    Anna makes it similarly easy to filter out a subset of members from
	    a type, create the union of two types, etc.
	  </p>
	  <h2><a name="structural-typing-dynamic-type-creation">Dynamic type creation</a></h2>
	  
	  <p>
	    In order for structural typing to be viable in a statically typed
	    language, it must be easy to create new types on the spot. A very
	    simple example of this is the <code class="anna-code">or</code> macro. Take the
	    following snippet of Anna code:
	  </p>
	  <pre class="anna-code">
foo := 1;
bar := "1";
var baz = foo or bar;
	  </pre>
	  <p>
	    The or operator in Anna will return the first value (foo)
	    if it is true, otherwise, bar will be returned. This means
	    that the return type of <code class="anna-code">foo or
	    bar</code> is the intersection of the types of the
	    respective arguments, in this case, the intersection of
	    the types <code class="anna-code">Int</code>
	    and <code class="anna-code">ImutableString</code>.
	  </p>
	  
	  <h1>
	    <a name="type-inference"> 	
	      Type inference - painless static typing
	    </a>
	  </h1>
	  <p>
	    Anna is a statically typed language. That means that
	    before a block of Anna code is compiled by the computer,
	    every variable declaration and every object member will
	    have a known type associated with it. This does not,
	    however, mean that you as a programmer must tell the
	    interpreter about all of those types. Anna goes out of her
	    way to find situations where there is no ambiguity as to
	    the type of a variable, and to relieve you of the burden
	    of explicit typing in such situations. Consider this
	    trivial example:
	  </p>
	  <pre>
var Int i = 7;
	  </pre>
	  <p>
	    The above is an Anna style variable declaration, the
	    variable <code class="anna-code">i</code> is declared to
	    be of type <code class="anna-code">Int</code>, and is
	    given the initial value of 7. Now, the above is a
	    perfectly valid Anna expression, but it is not the
	    simplest way possible to express the above. You see, the
	    numeric literal <code class="anna-code">7</code> is known
	    by the interpreter to be of the type Int. The interpreter
	    can use this information to guess the type of the variable
	    declaration. Therefore, Anna also has an alternative,
	    simpler syntax:
	  </p>
	  <pre>
i := 7;
	  </pre>
	  
	  <p>
	    This only saves you seven key strokes in the example above, but
	    consider for example templated types, such as a map with String keys
	    and Float values:
	  </p>

	  <pre class="anna-code">
var Map«String,Float» map = ["Mon":0.0, "Tue":1.1];
map := ["Mon":0.0, "Tue":1.1];
	  </pre>

	  <p>
	    Suddenly, we've cut the number of key strokes nearly in
	    half, without sacrificing readability or type safety.
	  </p>
	  
	  <p>
	    Variable declarations aren't the only place where the
	    interpreter can figure out the variable type for you:
	  </p>
	  
	  <pre class="anna-code">
/*
 * Function with return type implied by the type of value it is returning
 */
def next(Int in)
{
    return in+1;
}
	  </pre>

	  <h1><a name="macros">Macros redefine our world</a></h1>
	  <p>
	    Anna, much like LISP, allows you to define functions that accept a
	    tree of nodes representing a program code snippet as an input, and
	    returning another code snippet as its output. This is in stark
	    contrast to regular functions, that accept the
	    evaluated <em>results</em> of a code snippet as its input and
	    output. For example, consider the following snippet:
	  </p>
	  <pre>
TODO
	  </pre>
	  
	  <h1><a name="errors">Handling errors with no exceptions</a></h1>
	  <p>
	    Anna does not have exceptions. It would be easy to implement
	    exceptions using continuations, but they are considered bad
	    coding style in Anna. The perception is that exceptions make
	    your programs unpredictable and often causes error handling,
	    which is the least well tested part of most application, to use
	    completely different code paths that often result in unintended
	    bugs. In its stead, Anna allows you to record all errors that
	    occured during the execution of a function, and deal with them
	    where convenient. Instead of the classic try/except block of
	    other languages, Anna has a collect block that in many
	    ways behaves the same, but with an important difference. This is
	    how a collect block will usually look like:
	  </p>
	  <pre class="anna-code">
collect
{
    /* Some code that may cause various error conditions */
    ...
}.each(err){
    switch(err)
    {
	case(ioErr as IOError)
        {
	    /* If we encounter an IO error, ignore the rest of the error 
	     * list, but continue running the program */
	    print("There was an IO problem. Details:\n", err.message);
	    break; 
	}
	case (pErr as PermissionError)
        {
	    /* If we encounter a permission error, exit the program */
	    print("Access denied! Shutting down\n");
	    exit(1);
	}
	default 
        {
	    /* If we encounter any other error,  continue processing the 
	     * error list */
	    print("Unknown error. Details:\n", err.message);
	}
    }
}
	  </pre>
	  <p>
	    The <code class="anna-code">collect</code> call will save
	    any errors that occur while executing its body, including
	    any errors occusing in functions called by the body at any
	    level of nesting, into a list of errors. Once the code has
	    finished, the list of errors is iterated over and handled
	    by the <code class="anna-code">each</code> loop.
	  </p>
	  <p>
	    Curious about the switch expression, and how it was used
	    for trying to cast a value to different types in the above
	    code? You might want to read up on
	    the <a href="#examples-switch">switch statement
	    examples</a>.
	  </p>
	  <p>
	    How is this different from exceptions? Exceptions can skip over
	    parts of your code in very unpredictable ways. Whenever you
	    allocate some form of resource, you need to use try/finally to
	    make sure it's released, which is very error prone. When an
	    error happens in Anna, it is recorded, but the code will keep in
	    running. In Anna, you don't need to code defensively around the
	    possibility that some code you called might throw an
	    exception. You do't need to be afraid thet there is an
	    undocumented exception that might be thrown by some library code
	    you're using causing a program flow that you hadn't thought of
	    and results in rare and unpredictable bugs. Instead, code that
	    errors out be recorded, and will then usually simply return
	    null. And because using null objects does nothing in Anna, you
	    can usually make your code exit cleanly and automatically on
	    errors without even trying. For example, look at this trivial
	    example:
	  </p>
	  <pre class="anna-code">
var f = File("foo.txt").open();
while(f.readLine())
{
    ...
}
f.close();
	  </pre>
	  <p>
	    If the file can not be read, either because it doesn't exist or
	    because you lack the permissions, the open call will fail and
	    return null, and f will be assigned null. Calling readLine on
	    the null object will again return null, ending the loop at
	    once. Calling close on the null object will also have no
	    effect. So because of how null handling works in Anna, the above
	    code will handle any error without forcing you to write any
	    error handling code.
	  </p>

	  <h1><a name="misc">An odd number of legs for a horse to have</a></h1>
	  <p>
	    This section gives an overview of the various Anna features that,
	    while important, did not warrant an entire section of their own.
	  </p>
	  <h2><a name="null">The talented mister null</a></h2>
	  <p>
	    The null object in Anna, which can be accessed through
	    the <code class="anna-code">?</code> keyword, is a very
	    odd object. It masques as every interface, and calling any
	    method on it will without exception have no side effects
	    and will return the null object. In other words, it is
	    perfectly ok to call <code class="anna-code">? + 1</code>,
	    it will not crash or throw an exception, and the result
	    will be null. 
	  </p>
	  <p>
	    For more information about error handling in Anna, and how
	    the null object ties in with it, read the section
	    titled <a href="#errors">Handling errors with no
	    exceptions</a>.
	  </p>

	  <h2><a name="booleans">Null is the new no</a></h2>
	  <p>
	    There is no separate Boolean type in Anna. There is exactly one
	    object that takes on the responsibility of representing the
	    false state, and that is the null object. Any other object,
	    including the empty list, the number zero and the text strings
	    "null", "?" and "0" all count as true in the eyes of if
	    expressions, while loops and any other statement that expects a
	    yes/no answer. Null is the new no.
	  </p>

	  <h2><a name="blocks">Blocks, lambdas, procedures and functions</a></h2>
	  <p>
	    In Anna, if you enclose a list of expressions within curly
	    brackets, you will define a block.
	  </p>
	  <pre class="anna-code">
// Define a block
{
    print("This is a block, and it will not get run\n");
}
	  </pre>
	  <p>
	    Unlike other C-based languages, the block does not by
	    default get run, so the code above does not actually print
	    anything. Instead, an anonymous function is returned by
	    the block expression, that can then be further
	    manipulated:
	  </p>
	  <pre class="anna-code">
// Define a block and explicitly call it
{
    print("This block will be run because it is explicitly called\n");
}();

// Define a block and assign it to the variable myBlock
myBlock := 
{
    print("This is yet another block\n");
};
myBlock();

	  </pre>
	  <p>
	    If you've read the section about functions in Anna, you
	    may be wondering what the difference between a function
	    and a block is. The code above could just as well be
	    written using functions:
	  </p>
	  <pre class="anna-code">
// Define an anonymous function and explicitly call it
def ()
{
    print("This function will be run because it is explicitly called\n");
}()

// Define a named function
def myFun()
{
    print("This is yet another function\n");
}
myFun();
	  </pre>
	  <p>
	    The answer is that blocks are just syntactic sugar for
	    defining extremely simple functions, and internally, they
	    are exactly the same thing.
	  </p>
	  <pre class="anna-code">
// These two lines are exactly equivalent, but less writing is required 
// when using the block syntax
{print("hi")}
def () (block){print("hi")}
	  </pre>
	  <p>
	    You may have noticed that the function definition that is
	    equivalent to the block definition snuck in an attribute
	    in the function definition,
	    namely <code class="anna-code">block</code>. So what does
	    the <code class="anna-code">block</code> attribute do? The
	    answer is that the <code class="anna-code">return</code>
	    expression will return from the innermost
	    function <em>that is not a block</em>.
	  </p>
	  <p>
	    So there you go. Anna has two different syntaxes for
	    defining callable sequences of code, called blocks and
	    functions. Blocks use a very terse syntax, but
	    functions are a lot more expressive in that you can pass
	    parameters to them, you can control how
	    the <code class="anna-code">return</code> expression
	    works, you can give them a name, etc. Underneath, they are
	    completely equivalent and rely on the same implementation,
	    and functions are in fact a strict superset of the
	    functionality of blocks.
	  </p>
	  <h3><a name="blocks-param">Sending a block as an input parameter to a function call</a></h3>
	  <p>
	    There is one more thing that one should know about
	    blocks. When calling a function, a code block coming right
	    after the parameter list is interpreted as an argument to
	    that function:
	  </p>
	  <pre class="anna-code">
// These two lines are completely equivalent
someFunction(1,2,3, {1+1});
someFunction(1,2,3) {1+1};

// These two lines are also completely equivalent
someOtherFunction({1+1});
someOtherFunction{1+1};
	  </pre>
	  <p>
	    What is the point of this alternative syntax? Here are some examples of it in use:
	  </p>
	  <pre class="anna-code">
if(someCheck())
{
    doSomething();
}

while(someCondition())
{
    doSomething();
}

switch(x)
{
    case(0)
    {
        ...
    }
    ...
}

(0..10).map(idx){0.0+x}.each(val){print(idx,"\n")}
	  </pre>
	  <p>
	    As you can see, this syntax (which has been adapted from
	    Ruby), allows you to pass on a piece of code to another
	    function using a rather terse syntax.
	  </p>
	  <p>
	    The main benefit of this type of code is how easily it
	    allows you to extend and repurpose Anna for new problem
	    domains. Imagine that you're writing a database API. You
	    might want a simple way to define database
	    transactions. Consider the following piece of code:
	  </p>
	  <pre class="anna-code">
class Database
{	    

    ...

    def transaction( def Object code())
    {
        connection.beginTransaction();
        code();
        connection.commit();
    }
}
	  </pre>
	  <p>
	    The above code would allow you to use the following simple
	    syntax for performing a group of queries witin a
	    transaction like this:
	  </p>
	  <pre class="anna-code">
// Connect to the database
db := Database(...);

// Start a transaction
db.transaction
{
    // Perform a bunch of queries. These are all part of the same transaction
    db.query(...);
    db.query(...);
    db.query(...);
}
	  </pre>
	  <h2><a name="operator-overloading">I'll be your
	  operator</a></h2>
	  <p>
	    Anna has a small number of special operators that allow you to
	    implement some of the most common language operations with a
	    slightly terser syntax that most people find easier to parse. These
	    operators include comparison, assigment, basic aritmetic, string
	    formating, list slicing and a few more. The complete table of
	    operators and their precedence is listed in the table below. Most of
	    these operators are overloadable. The exceptions are the '!' not
	    operator, the '.' member access operator and a few more. The rest
	    can be overloaded by defining methods with special names. For
	    example, when the '+' operator is used...
	  </p>
	  <p>
	    In addition to overloading +, - and various other operators,
	    Anna also allows you define you own generic operators. These
	    operators all start with the «^» symbol, followed by an identifier:
	  </p>
	  <pre class="anna-code">
a := 4;
b := 7;
print(a ^bitand b);
	  </pre>
	  <p>
	    The above example shows usage of
	    the <code class="anna-code">^bitand</code> generic
	    operator of the Int class, which will perform a bitwise
	    and operation. These «generic operators» are actually just
	    a different syntax for calling a method with one
	    parameter.  To define your own generic operator, simply
	    define a method named like the operator. An example:
	  </p>
	  <pre class="anna-code">
class Color
{
    function blend(Float alpha)
    {
	...
    }
}

var col = Color();
col ^blend 0.1;
	  </pre>

	  <table class='anna-table'>
	    <caption>
	      Operator precedence, higher to lower.
	    </caption>
	    <thead>
	      <tr>
		<th>
		  Operator symbols
		</th>
		<th>
		  Operator method names
		</th>
		<th>
		  Notes
		</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>
		  <code class="anna-code">
		    ++, --
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __next__, __prev__
		  </code>
		</td>
		<td>
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    *, /, % 
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __mul__, __div__, __format__
		  </code>
		</td>
		<td>
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    +, -, ~
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __add__, __sub__, __join__
		  </code>
		</td>
		<td>
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    |
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __pair__
		  </code>
		</td>
		<td>
		  <code class="anna-code">__pair__</code> can not be overloaded.
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    ^xxx
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    xxx
		  </code>
		</td>
		<td>
		  any identifier can be used as an operator using the
		  generic operator syntax.
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    <, >, ==, !=, <=, >=, in
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __lt__, __gt__, __eq__, __neq__, __lte__, __gte__, __in__
		  </code>
		</td>
		<td>
		  While all of these operators can be overloaded, it
		  is strongly discouraged to overload any except
		  for <code class="anna-code">in</code>. Instead,
		  override the __cmp__ method, used to compare two
		  objects and return a negative Int, zero or a
		  positive Int depending on if the first number is
		  smaller, equal to, or greater than the second one,
		  respecitvely.
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    or, and
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __or__, __and__
		  </code>
		</td>
		<td>
		  <code class="anna-code">__or__</code> and <code class="anna-code">__and__</code> can not be overloaded.
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    =, ~=, +=, -=, :
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    __assign__, __append__, __increase__, __decrease__, __mapping__
		  </code>
		</td>
		<td>
		  
		  <code class="anna-code">__assign__</code>
		  and <code class="anna-code">__mapping__</code> can
		  not be overloaded.
		</td>
	      </tr>
	    </tbody>
	    
	  </table>
	  <h2><a name="misc-reserved-words">No reservations? No problem!</a></h2>
	  <p>
	    The Sugar layer has a small number of reserved words, including
	    'def', 'var' and 'return'. Because macros can never be
	    redefined, the builtin collection of macros more or less count
	    as additional reserved words. It may seem scary that modules you
	    import can add reserved words to the language - what if a module
	    you rely on suddenly adds a macro named 'pie'?  Suddenly, you'll
	    have to edit all your source code to remove any variables and
	    functions named pie. And given how delicious pie is, that is
	    bound to take an insurmountable amount of time.
	    For this reason, great care must be taken when using
	    the <code class="anna-code">expand</code> expression to import macros.
	  </p>

	  <h2><a name="misc-comments">Comments nest</a></h2>
	  <p>
	    Like C and friends Anna uses /* to start a multiline
	    comment, and */ to end it. But unlike C and friends,
	    comments can be nested inside each other. This makes it
	    trivial to comment out a large chunk of code, even if it
	    happens to contain multiline comments.
	  </p>
	  <pre class="anna-code">
/*
  /*
    This is a comment
  */
  thisIsAComment();
*/
thisIsCode();
	  </pre>

	  <h2><a name="misc-mutability">Mutability</a></h2>
	  <p>
	    Some objects in Anna are mutable, i.e. they can be changed
	    after they where created.  Mutable objects are sometimes
	    significantly easier to work with, but the fact that an
	    imutable object can't change unexpectedly has some
	    important code safety implications. Imutable objects also
	    offer important opportunities for optimizations.
	  </p>
	  <p>
	    Anna has both mutable and imutable versions of several
	    basic types. The table below shows these types.  Anna also
	    has an intersection of these types, which is suitable to
	    use when you're taking a value as input into a function
	    and don't care if you're getting the mutable or the
	    imutable version of the object. All types that exist in
	    Mutable and Imutable form are listed in the table below.
	  </p>
	  <table class='anna-table'>
	    <caption>
	      The anna types that exist in both a mutable and an imutable version.
	    </caption>
	    <thead>
	      <tr>
		<th>
		  Mutable version
		</th>
		<th>
		  Imutable version
		</th>
		<th>
		  Intersection
		</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>
		  <code class="anna-code">
		    MutableList
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    ImutableList
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    List
		  </code>
		</td>
	      </tr>
	      <tr>
		<td>
		  <code class="anna-code">
		    MutableString
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    ImutableString
		  </code>
		</td>
		<td>
		  <code class="anna-code">
		    String
		  </code>
		</td>
	      </tr>
	    </tbody>
	  </table>

	  <h3><a name="mutability-vs-const">Mutability and constants</a></h3>
	  <p>
	    It is sometimes easy to confuse the concepts of mutability
	    and of constants in Anna. They might on the surface seem
	    to be more or less the same, but in actuality, they are
	    different concepts that complete each other. 
	  </p>
	  <ul>
	    <li>
	      Imutable objects are objects that can't change over
	      time. Imutability is a property of a specific object
	      type. There is no way in Anna to enforce imutability -
	      any object whose value never changes after construction
	      is said to be imutable.
	    </li>
	    <li>
	      Constants are fields (like variables) whose value can
	      not change after their initial assignment. Const:ness is
	      a property of a specific field in the stack (or a
	      specific member field). Const:ness is enforced by the
	      language and can not be overridden. 
	    </li>
	  </ul>
	  <p>
	    So what does this mean in practice?
	  </p>
	  <ul>
	    <li>
	      A constant pointing to an imutable object truly is
	      unchanging during the entire run of the program. The
	      math.pi constant is such a value, it
	      will <em>always</em> return the floating point number
	      that most closely aproximates the mathematical constant
	      pi.
	    </li>
	    <li>
	      A constant pointing to a mutable object will always
	      evaluate to the same object. But by e.g. pushing and
	      popping values from a mutable list the actual content of
	      the list may change - regardless of if we're accessin
	      the object through a constant.
	    </li>
	    <li>
	      A variable pointing to an imutable list may evaluate to
	      different lists at different points in time. But if you
	      take the value of the variable at one point in time, you
	      can be sure that that specific list object will not
	      change during the execution of a program.
	    </li>
	  </ul>

	  <h3><a name="mutability-next">Moving on</a></h3>
	  <ul>
	    <li>
	      For a few additional examples on how to use mutable
	      objects in Anna, see the
	      the <a href='#examples-mutable'>Mutable examples</a>.
	    </li>
	    <li>
	      For a few examples on how to define variables and constants, see the
	      the <a href='#examples-variables'>Variables examples</a>.
	    </li>
	  </ul>
	  <h2><a name="misc-aliases">Method resolution</a></h2>
	  <p>
	    Many statically typed computer languages allow you to
	    define multiple methods with the same name but different
	    argument lists. The compiler will at compile time figure
	    out the most suitable version of the function and make
	    sure that version is called. The benefit of this is
	    obvious, functions that perform the same operation using
	    slightly different inputs can be named the same thing,
	    which avoids having to come up with arbitrary minor
	    differences in function names. There are drawbacks with
	    allowing overloading of method names, though:
	  </p>
	  <ul>
	    <li>
	      If there are e.g. multiple functions
	      named <code class="anna-code">clyde</code>, then code
	      like <code class="anna-code">myVar := clyde</code>
	      becomes ambigous. We need a parameter list in order to
	      unambiously determine which 
	      <code class="anna-code">clyde</code> function we want.
	    </li>
	    <li>
	      It becomes impossible to use name based value lookup
	      when examining the contents of either the call stack or
	      a type with reflection. Any such reflection operations
	      become significantly more complex and bug prone.
	    </li>
	    <li>
	      Sometimes it is desirable to make explicit which version
	      of a function should be called. This can be done by
	      casting all function parameters to the correct type, but
	      it is a clumsy and error prone method.
	    </li>
	  </ul>
	  <p>
	    Anna works around these issues by introducing a second
	    type of name for a function. All type members and stack
	    values, including functions and methods, have exactly one
	    canonical name, which is unique within a specific
	    namespace (that is, the name is unique with that stack
	    frame or type). This is the «true» name of the function
	    and must be used in any situation where an unambigous name
	    is needed. But functions and methods can also have an
	    arbitrary number of aliases, specified using the alias
	    attribute in the function declaration. Such aliases are
	    also searched when performing lookup for function and
	    method calls. If multiple function matches are found, the
	    function with the most compatible type signature is
	    chosen. Aliases are only used when calling a function or
	    method.
	  </p>
	  <p>
	    Note:
	  </p>
	  <ul>
	    <li>
	      If a function definition is shadowed by another function
	      with the same canonical name, that function will not be
	      considered even if it has a matching alias.
	    </li>
	    <li>
	      Aliases are only used when resolving an identifier for a
	      function call. The alias attribute is ignored when
	      performing regular variable lookup.
	    </li>
	    <li>
	      If more than one function has a specified alias and a
	      compatible function signature, then the most suitable
	      function is determined by picking the function with the
	      smallest number of non-matching members in the
	      interface.
	    </li>
	  </ul>
	  <pre class="anna-code">
def outerFunction(Int value)
(
    alias(myAlias)
)
{
    print("outer %\n" % [value]);
}	    

{
    def innerFunction(Object value)
    (
        alias(myAlias)
    )
    {
        print("inner %\n" % [value]);
    }	    

    /*
      This will call outerFunction, which will
      print 'outer 7'
    */
    myAlias(7);

    /*
      This is an error - aliases can only be used when calling a function. 
      They are ignored when performing regular variable lookup.
    */
    print(myAlias, "\n");
}()
	  </pre>

	  <h2><a name="misc-casting-vs-converting">Casting and converting</a></h2>
	  <p>
	    In most C-like languages, the operation of casting a value
	    to a new type (an operation which does not create a new
	    object) and the operation of converting a value to a
	    different type (an operation which
	    <em>does</em> create a new object of a different type) use
	    the same syntax, even though they are fundamentally
	    different operations. This is not so in Anna.
	  </p>
	  <p>
	    The casting operator <code class="anna-code">as</code> can
	    never create a new object. It simply either returns
	    exactly the same object cast to a different type, or, if
	    the specified object can not be cast to that type, null is
	    returned. For example, to cast the value <code>7</code> to
	    a <code class="anna-code">Float</code>,
	    write <code class="anna-code">7 as Float</code>. This will
	    result in a null value, because Int objects do not have
	    all the members of a Float and can therefore not be cast
	    to Float.
	  </p>
	  <p>
	    Converting values is done using the
	    static <code>convert</code> methods. For example, to
	    convert a Float object to an Int, one would
	    write <code class="anna-code">Int::convert(7.1)</code>. This
	    will create a new Int object holding the closest integer
	    representation of the floating point number 7.1, which is 7.
	  </p>
	  <p>
	    Note that there is nothing magical about
	    a <code>convert</code> method. It is simply a naming
	    convention.
	  </p>
	  

	  <h2><a name="misc-internal-identifiers">Internal identifiers</a></h2>
	  <p>
	    There are various situations when writing Anna code where
	    one wishes to insert placeholders into the code that will
	    later on be replaced with something else, usually through
	    macros. In these situations, Anna uses so called internal
	    identifiers to make it more clear what parts wil be
	    replaced. An internal identifier is any regular
	    identifier, prefixed with a % symbol. Some examples:
	  </p>
	  <pre class="anna-code">

/*
  %A will get substituted with the relevant template type here.
*/
class Foo (template(%A:Int)) {
    def %A bar(%A a, %A b){
        a+b;
    }
}

/*
  The code in the first param will get generated once for each item in the 
  second parameter, substituting %var with a different item from the collection
  each time.
*/
expandCode(
    %var := getNextValue(someValue, someOtherValue),
    var: [first, second, third, fourth, fifth]);    

/**
  This (rather meaningless) macro turns a call like 

  setFooToValue(7)

  into

  foo = 7;

  It uses an internal identifier inside the ast macro to specify what piece of 
  code to replace.
*/
macro setFooToValue(call)
{
    return ast(foo = %value) % ["value": call[0]];
}
	  </pre>
	  <ul>
	    <li>
	      Just like with regular identifiers, Anna differentiates
	      between type identifiers and regular identifiers - the
	      first non-underscore character of an internal type
	      identifier needs to be upper case.
	    </li>
	    <li>
	      Not replacing an internal identifier with something else
	      will result in a compilation error.
	    </li>
	  </ul>
	  <p>
	    It should be noted that there are no technical reasons why
	    internal identifiers are actually needed in Anna, the
	    language would work just as well without them. The reason
	    why Anna requires the use of internal identifiers is for
	    clarity - it makes it obvious which parts of the code are
	    simply placeholders that are to be substituted with
	    something else.
	  </p>
	  <p>
	    The percent symbol, when not used as a prefix for an
	    identifier, is an operator called the format operator. You
	    can read more about the format operator in the following
	    section.
	  </p>

	  <h2><a name="misc-format">The % (format) operator</a></h2>
	  <p>
	    Various Anna types implement the <code>%</code> operator,
	    also called <code>__format__</code>. This operator should
	    be used for interpolating a collection of values into a
	    template containing placeholders. Some examples:
	  </p>
	  <pre class="anna-code">
// Prints «This string is used as a template»
print("This string is used as a %\n" % ["template"]);
// Prints «A fancy string uses fancy named placeholders»
print(
    "A %(quality) string uses %(quality) named placeholders\n"
     % ["quality": "fancy"]);

/*
  AST nodes also have a format operator, it works much the same way 
  as named placeholders in strings

  This will print «print(7)»
*/
print(ast(%someFunction(7)) % ["someVar": parser.identifier(?, "print")]);
	  </pre>
<!--
    <h1>A simple, annotated example</h1>
    <p>
      Ok, let's start putting Anna through her paces! Fire up the
      interactive Anna console by typing <code class="anna-code">anna</code> in your
      terminal and pressing enter. This is a minimal Anna program that
      you can then cut and paste into the interpreter:
    </p>
    <code class="anna-code">
/*
	Declare a function called mandelbrot, it accepts a complex number 
	(the coordinate) amd a maximum iteration count.
*/
function mandelbrot(Complex p0, Int maxStep)
{
    /*
	Declare two local variables. The first one is p, which is the same 
	type as p0 (a Complex) and has the initial value p0.
	The second one is step, which is the same type as 1 (an Int) and 
	has the initial value 1.
    */
    var p = p0;
    var step = 1;
    /*
	While the absolute value of p is less than two and we haven't run 
	into the maximum iteration count, run the loop block.
    */
    while(p.abs() &lt; 2.0, and step &lt;= maxStep) 
    {
	/*
	    Square p and add p0.
	*/
        p = p^2 + p0;
	step += 1;
    }
    /*
	Return the number of iterations used.
    */
    return step;
}
/*
    x:y..z defines a range of values from x to z using the step y. We set
    up such ranges for both the x and y direction, and call the mandebrot 
    function (defined above) with each input combination, and print either 
    a hash or a space depending on if the point was in the set.
*/
(-1.0:0.1..1.0).each(x){(-1.0:0.1..1.0).each(y){print(if(mandelbrot(Complex(x,y),32)==32){'#'}else{' '}}}}
    </code>
    <p>
      The above code will print a Mandelbrot set on your screen. Try
      reading the comments and check that you understand what the code
      does. There are a few things that are different from many other
      languages in the code above. We'll comment on them below.
    </p>
-->
          <h1><a name="microformats">Microformats</a></h1>
	  <p>
	    The Anna parser is written to be as accepting as possible of
	    weird elements, and instead offloads as much of the code
	    validation as possible to macros. This allows you to write
	    microformat macros. These are macros that take an AST subtree
	    and transform then into another subtree in order to allow you to
	    define your own compact data formats.  For example, JSON is a
	    valid subset of Anna, so one could write a JSON microformat
	    macro to transform an AST containing JSON into the Anna
	    equivalent, meaning one could insert JSON data verbatim into the
	    code, and make sure the JSON macro parses it to correct Anna
	    code:
	  </p> 
	  <pre class="anna-code">
m := json({data:[1,2,3,7], unit:"seconds", caption:null});
	  </pre>
	  <p>
	    Note: This macro has yet to be written. 
	    Another very practical use of this feature is date handling. There are
	    macros that make sure anything you send to the Date constructor, or
	    anything you add or remove from a date, is parsed using the standard
	    ISO date format: 
	  </p>
	  <pre class="anna-code">
// Create a new date from a specified date 
then := isoDate(2009-1-1, 12:30);

// Move ahead x years and one hour 
date += isoDateDelta(x-0-0, 1:00);
	  </pre>
	  
	  <h1><a name="collections">More about collections</a></h1>
	  <p>
	    The Anna standard library comes with three different collections built in,
	  </p>
	  <ul>
	    <li>
	      <code class="anna-code">List</code>, an ordered
	      collection using positive integer indices as keys, and
	      which comes in both
	      a <code class="anna-code">MutableList</code> and
	      an <code class="anna-code">ImutableList</code> flavor,
	      both of which are templates that can be specialized to
	      store any type.
	    </li>
	    <li>
	      <code class="anna-code">HashMap</code>, an unordered
	      collection using arbitrary objects as keys, and is a
	      template that can be specialized to store any key/value
	      type pair.
	    </li>
	    <li>
	      <code class="anna-code">Range</code>, which defines a
	      (possible infinite) sequence of equally spaced integer
	      values.
	    </li>
	  </ul>
	  <h2><a name="collections-list">Lists</a></h1>
	  <p>
	    Anna list objects use zero based offsets, and use a
	    dynamically allocated array to store it's values
	    internally, meaning that accessing any element in the
	    array by index will always be a fast operation. This also
	    means that if there are large gaps in the List, it will
	    take up more memory than it needs, and that inserting new
	    elements anywhere that is not near the end of the list is
	    an inherently slow operation.
	  </p>
	  <p>
	    Lists can be used as stacks by employing
	    the <code class="anna-code">push</code>
	    and <code class="anna-code">pop</code> methods and
	    checking the <code class="anna-code">empty?</code>
	    attribute.
	  </p>
	  <p>
	    When assigning beyond the last index of a list, it is
	    dynamically resized. All previously unassigned slots are
	    given the null value. Code
	    like <code class="anna-code">silly=[];silly[99999999999999999]=?;</code>
	    is an excellent way to run out of memory.
	  </p>
	  <p>
	    
	  </p>
	  <h2><a name="collections-hashmap">HashMaps</a></h1>
	  <p>
	    Anna hashmap objects are one-to-one mappings that use
	    the <code>hashCode</code> and <code>__eq__</code> methods
	    of the key object to find the corresponding
	    value. Hashmaps are unordered. That is, when iterating
	    over them, the elements may be presented in any order.
	  </p>
          <p>

	  </p>
	  <h1><a name="sugar">Sugar and spice - How the front end sugar works and what Anna looks like without makeup</a></h1>
	  <p>
	    The real syntax for Anna is painfully simple. There Anna AST
	    contains only three types of nodes:
	  </p>
	  <ol>
	    <li>
	      Literal values, such
	      as <code class="anna-code">?</code>, <code class="anna-code">3</code>, 
	      <code class="anna-code">1.0</code>
	      or <code class="anna-code">"foo"</code>.
	    </li>
	    <li>
	      Identifiers, such as <code class="anna-code">foo</code>,
	      <code class="anna-code">String</code> or <code class="anna-code">%bar</code>.
	    </li>
	    <li>
	      Function calls, such
	      as <code class="anna-code">X(Y,Z)</code>,
	      where <code class="anna-code">X</code>, <code class="anna-code">Y</code>
	      and <code class="anna-code">Z</code> are arbitrary other
	      AST nodes. In the above example, the AST
	      node <code class="anna-code">X</code> is invoked
	      with <code class="anna-code">Y</code>
	      and <code class="anna-code">Z</code> as input
	      parameters.
	    </li>
	  </ol>
	  <p>
	    That's it. Those are the only things needed to write Anna
	    programs. For somebody coming from a C background, that might seem
	    anemic for a programming language. Where are the code blocks?  Where
	    are the if/while/whenever statements? Function definitions?
	    Meanwhile, anybody with a LISP background will twiddle their
	    beards in boredom. They <em>know</em>.
	  </p>
	  <p>
	    The sugar front end of Anna is a simple language front end that
	    has a few keywords and special constructs such as operator
	    overloading that allow you to use a terser, C-like syntax. The
	    dot operator is used for setting and getting member values, we
	    have arithmetic operators with the usual precedence, we have
	    special language constructs to allow us to define types,
	    functions and variables with a little less verbosity, etc.  All
	    of this syntactic sugar is stripped away by the front end of the
	    compiler, and is converted into the basic AST node types
	    mentioned above. Below are some examples of these transformations.
	  </p>

	  <table class='anna-table'>
	    <caption>
	      Example snippets of Anna code and their sugar free equivalent
	    </caption>
	    <thead>
	      <tr>
		<th>
		  Regular
		</th>
		<th>
		  Sugar free
		</th>
	      </tr>
	    </thead>
	    <tbody>

	      <tr>
		<td>
		  <code class='anna-code'>
		    {foo}
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __block__(foo)
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    lst.count 
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __memberGet__(lst, count)
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    lst.count = 3
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __assign__(__memberGet__(lst, count), 3)
		  </code>
		</td>
	      </tr>


	      <tr>
		<td>
		  <code class='anna-code'>
		    lst.push(1)
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __memberGet__(lst, push)(1)
		  </code>
		</td>
	      </tr>


	      <tr>
		<td>
		  <code class='anna-code'>
		    lst[4]
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __memberGet__(lst, __get__)(4)
		  </code>
		</td>
	      </tr>


	      <tr>
		<td>
		  <code class='anna-code'>
		    lst[4] = 'X'
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __assign__(__memberGet__(lst, __get__)(4), 'X')
		  </code>
		</td>
	      </tr>


	      <tr>
		<td>
		  <code class='anna-code'>
		    1+2
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __memberGet__(1, __add__)(2)
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    foo = bar()
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __assign__(foo, bar())
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    foo := 3
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __var__(foo, ?, 3, __block__())
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    bar :== 3
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __const__(bar, ?, 3, __block__())
		  </code>
		</td>
	      </tr>


	      <tr>
		<td>
		  <code class='anna-code'>
		    def foo(){1}
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __const__(foo, ?, __def__(foo, ?, __block__(), __block__(), __block__(1)))
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    someCall(paramName: value)
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    someCall(__mapping__(paramName, value))
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    «Object»[1, 2, 3]
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __collection__(Object, 1, 2, 3)
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    [1, 2, 3]
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __collection__(?, 1, 2, 3)
		  </code>
		</td>
	      </tr>

	      <tr>
		<td>
		  <code class='anna-code'>
		    ["a":1, "b":2]
		  </code>
		</td>
		<td>
		  <code class='anna-code'>
		    __collection__(?, __mapping__("a", 1), __mapping__("b", 2))
		  </code>
		</td>
	      </tr>

<!--
	      <tr>
		<td>
		  <code class='anna-code'>

		  </code>
		</td>
		<td>
		  <code class='anna-code'>

		  </code>
		</td>
	      </tr>
-->

	    </tbody>
	  </table>

	  <h1><a name="libraries">Extending Anna through libraries</a></h1>
	  <p>
	    Anna has very simple library handling.  There is no
	    special language construct needed for using a library. If
	    a library named <code class="anna-code">fooBar</code>
	    exists, and has a member
	    named <code class="anna-code">baz</code>, simply
	    write <code class="anna-code">fooBar.baz</code> anywhere
	    in your code in order to access that member - the library
	    will be loaded as needed. If you want to use
	    the <code class="anna-code">baz</code> member often, and
	    don't want to use the full path of the member, use
	    the <code class="anna-code">use</code> expression,
	    e.g. <code class="anna-code">use(fooBar);</code>. In any
	    scope where a use expressioin is visible, the members of
	    the library can be used directly, e.g.  by
	    writing <code class="anna-code">baz</code>. The
	    <code class="anna-code">use</code> expression can be used
	    globally for a whole module, or it can be used locally
	    inside a single function block. For readability, it is
	    highly reccomended to use as few
	    global <code class="anna-code">use</code> expressions as
	    possible.
	  </p>
	  <pre class="anna-code">
def someFunction()
{
    use(math);
    // Because of the use expression, pi in the expression below will be
    // resolved to math.pi, e.g. the constant pi in the math library.
    print(pi, "\n");
}
	  </pre>
	  <ul>
	    <li>The <code class="anna-code">use</code> expression is more general than simply a short cut for libraries. If you want to find out more about it, read the <a href="#use">documentation on the use expression</a>.</li>
	    <li>If you want to find out more about how Anna locates the right library to load, continue reading.
	  </ul>

	  <h2><a name="libraries-loading">Loading a library</a></h2>
	  <p>
	    
	  </p>
	  <p>
	    Writing you own Anna library is extremely
	    simple. Libraries are nothing but regular Anna files.
	    When
	    loading a library, the colon-separated directories listed
	    in the ANNA_PATH environment variable is prepended to a
	    list containing ./lib and a compile time defined install
	    directory for the Anna standard library, usually
	    /usr/local/lib/anna. When searching for a library, the
	    above list is searched in order until a file with the same
	    name as the library is found, with either the .anna suffix
	    or the .so suffix. Files ending in .anna are assumed to be
	    source code library files, and are interpreted by the Anna
	    interpreter and loaded.
	  </p>

	  <h1><a name="use">The use expression</a></h1>
	  <p>
	    The use expression is a short hand convenience - any use:d
	    expressions are considered in scope and considered when
	    performing identifier lookup.
	  </p>

	  <pre class="anna-code">
    /*
      The use expression can be used for other things than just importing a 
      library.
    */
    lst := [];
    use(lst);
    /* These calls resolve to lst.push, because lst us use:d */
    push(1);
    push(2);
    push(3);
    print(pop(), ' ', pop(), ' ', pop(), '\n');
	  </pre>
	  <h1><a name="design">Design choices</a></h1>
	  <p>
	    The design goals of Anna include:
	  </p>
	  <ul>
	    <li>
	      An open ended language. Anna should provide the tools needed
	      to extend the language in new ways, and a syntax that makes
	      such extensions readable. 
	    </li>
	    <li>
	      A mostly C-like syntax. This brings instant familiarity
	      to a majority of the worlds programmers, allowing them
	      to pick up the basics of the language in a matter of
	      minutes, and can then concentrate on learning and
	      understanding the intricacies of macros, continuations
	      and other higher level features. If a basic C-like
	      syntax strikes a good balance between readbility,
	      terseness and expressiveness is subjective, but the
	      author of this text certainly feels so, and the
	      prevalence of C-like syntaxes, including most modern
	      computer languages as well as an array of computer
	      formats like CSS and JSON certainly suggest that many
	      others agree.
	    </li>
	    <li>
	      Easy (for a compiler) to parse. Anna source code should be
	      parsable by a traditional lexical analyzer plus LALR parser
	      combo. This has many advantages, it makes it easier to
	      standardize and define the language. It makes the
	      implementation of the language easier and perhaps most
	      importantly, it removes vast amounts of grey zones where it is
	      not clear what a piece of code should actually do.
	    </li>
	    <li>
	      Focus more on expressivness, but don't forget
	      efficency. Continuations, automatic garbage collection
	      and «everyting is an object» are all language choices
	      that make the langauge extremely expressive, but they
	      come with severe performance implications. A lot of the
	      time, the performance loss can be avoided through the
	      use of clever compiler tricks. So far, Anna includes no
	      such tricks, and is decidedly slow. That said, Anna is,
	      when possible with only a minimal cost to
	      expressiveness, designed to make it <em>possible</em> to
	      write a speedy compiler.
	    </li>
	  </ul>

	  <h2><a name="design-separators">Commas, semicolons and separating expressions</a></h2>
	  <p>
	    At the parser level, Anna is designed to be able to handle
	    as much input as possible in order to make it easier to
	    create microformats that feel natural to work with. Some
	    of the results of this are:
	  </p>
	  <ul>
	    <li>
	      Anna uses two different
	      separators, <code class="anna-code">,</code> (comma)
	      and <code class="anna-code">;</code> (semicolon). These
	      can be used interchangeably.
	    </li>
	    <li>
	      Multiple commas or semicolons separated by only
	      whitespace are treated as a single separator.
	    </li>
	    <li>
	      Expressions are actually <em>separated</em> by
	      separators, not terminated by them - so a trailing
	      semicolon after the last expression in a block is not
	      actually needed. But it is allowed.
	    </li>
	    <li>
	      All the above rules apply to code blocks, the parameter
	      list of a function call and the members in a collection
	      literal. In fact, exactly the same piece of code in the
	      Anna parser is responsible for parsing all these types
	      of code.
	    </li>
	  </ul>
	  <p>
	    As you can see, Anna leaves you with a lot of options when
	    it comes to separators. There are however very specific
	    coding conventions:
	  </p>
	  <pre class="anna-code">
/*
   Multiple-line expression groups should always have a trailing
   separator. The reason for that is to make it easier to comment or
   cut and paste lines without having to worry about trailing
   separators.

   For code blocks, only use the semicolon as a separator, for
   collection literals and function calls, only comma. The reason for
   this is historical - that's how code has traditionally been written
   in C-like languages.
*/
default
{
    foo;
    bar;
    baz;
}

someFunctionCall(
    arg1,
    arg2,
    arg3,
    );

literal := [
    "first",
    "second",
    "third",
    ];

/*
   The only exceptions to this rule is that it is ok to group together
   multiple variable declarations on a single line with commas.  
*/

foo := 1, bar := 2, baz := 3;

/*
   Single-line expression groups should never have a trailing
   separator. The reason is to keep down the amount of clutter.
*/
default { foo; bar }

someFunctionCall(arg1, arg2);

literal := ["first", "second"];
	  </pre>
	  
	  <h2><a name="design-naming">Naming of variables and types</a></h2>
	  <p>
	    Anna names may only contain the latin letters a-z in lower
	    and upper case as well as underscores, numbers and the ?
	    and ! characters.
	  </p>
	  <p>
	    Variable and constant names <em>must</em> have a lower
	    case letter as the first non-underscore letter,
	    like <code class="anna-code">desertSpoon</code>
	    or <code class="anna-code">_giantBanana</code>. Type names
	    <em>must</em> have an upper case letter as the first
	    non-underscore letter,
	    like <code class="anna-code">CrispyBacon</code>
	    or <code class="anna-code">_VeganApplePie</code>. The
	    reason for enforcing this is that it makes it
	    significantly easier to write an Anna parser.
	  </p>
	  <p>
	    In addition, the following conventions exist in regards to
	    naming:
	  </p>
	  <ul>
	    <li>
	      All names, both type names, variable names, module names
	      and constants should use CamelCase. Underscore should
	      never be used to separate words.
	    </li>
	    <li>
	      Neither constants nor private members have different
	      naming conventions from regular members or variables.
	    </li>
	    <li>
	      Names beginning and ending with a double underscore,
	      like <code class="anna-code">__someName__</code>, are
	      reserved by the implementation. You can override these
	      where it makes sense, e.g. implementing a new type that
	      has an <code class="anna-code">__add__</code> member in
	      order to allow the use of
	      the <code class="anna-code">+</code> operator, but you
	      should never make up new names in this namespace.
	    </li>
	    <li>
	      Names of things that hold yes/no values should end in a
	      question mark. For example, Range objects have
	      the <code class="anna-code">Range.open?</code> property,
	      which is non-null only for semi-infinite ranges.
	    </li>
	    <li>
	      Variables used in larger pieces of code should have
	      clear, descriptive names, preferably without
	      abbreviations,
	      like <code class="anna-code">documentationFragment</code>,
	      <code class="anna-code">callingFunction</code>
	      or <code class="anna-code">memberAttribute</code>.
	    </li>
	    <li>
	      Variables local to a specific function, especially if
	      their useage is reasonably clear, should have short
	      names like <code class="anna-code">doc</code>, 
	      <code class="anna-code">fun</code>
	      or <code class="anna-code">attr</code>.
	    </li>
	    <li>
	      Avoid using single letter names for anything other than
	      loop variables. (The <code class="anna-code">e</code>
	      constant in the <code class="anna-code">math</code>
	      module is an exception to this rule)
	    </li>
	  </ul>
	  <h2><a name="design-guidelines">Other coding conventions</a></h2>
	  <ul>
	    <li>
	      In multi-line function definitions,
	      the <code class="anna-code">return</code> expression
	      should be used to make it explicit what is returned -
	      unless the return value truly doesn't matter.
	    </li>
	  </ul>
	  <h2><a name="design-caveats">Caveats - no language is perfect</a></h2>
	  <p>
	    The «Easy to parse» design constraint has unfortunatly led
	    to a significant number of exceptions to the «C-like
	    syntax» rule. For example, Anna uses either
	    <code class="anna-code">List«Int»</code>
	    or <code class="anna-code">List&lt;&lt;Int&gt;&gt;</code> to
	    specialize a template, instead
	    of <code class="anna-code">List&lt;Int&gt;</code>, which is
	    used in C++, Java and C#. The reason is simple: It is
	    impossible to write a general parser that
	    uses <code class="anna-code">&lt;&gt;</code> both for
	    comparisons and for template specializations without
	    making very specific exceptions in the parser. Such
	    exceptions would also severly restrict what code can be
	    placed inside of a template specialization. In Anna,
	    templates can be used to insert any expression into a code
	    template, not just a Type.
	  </p>
	  <pre class="anna-code">
/*
  A small sample program using a template specialization
  that would be impossible to parse unambiguably if &lt;&gt; 
  was used for template specialization.
*/
class Foo (template(%op:?)) {

    def bar(Int a, Int b)
    {
        %op;
    }

}

def Int main()
{
    boo := Foo«a &gt; b»();
    print(boo.bar(3,4),"\n");
}
	  </pre>
	  <p>
	    It should be noted that the creators of D, another C-like
	    language which aims to be easier to parse than e.g. C++,
	    ran into the same problem with template
	    specialization. They chose instead to
	    use <code>List!(Int)</code> as the template specialization
	    syntax. Unfortunatly, that would be impossible in Anna,
	    since Anna is less picky with what can be specialized,
	    leading (again) to syntactic ambiguity. On the other hand, D
	    uses <code>&lt;&lt;</code> and <code>&gt;&gt;</code> for
	    bitshifting, just like C, meaning these symbols where not
	    available for template specialization. The solution that
	    works for one language does not always work for another.
	  </p>
	  <p>
	    One significant kludge in the Anna syntax is the
	    expression merge pass of compilation. It is used to move
	    expressions into the expression preceeding them, and is
	    useful in situations like the if/else expression
	    pair. While useful, it is definitely a rather large
	    syntactic wart. TODO: Explain more precisely how it works,
	    and how it can be used.
	  </p>
	  <h1><a name="implementation">Implementation details</a></h1>
	  <p>
	    This section gives an overview of the Anna interpreter
	    implementation. It is not important to read or understand
	    this section in order to begin programming in Anna. It is
	    intended as a starting point for those who wish to dig
	    into the source code.
	  </p>

	  <h2><a name="implementation-numbers">Numbers</a></h2>
	  <p>
	    At the language level, everything in Anna is an
	    Object. Types and functions are objects. There are also no
	    primitive data types, integers, characaters and floats are
	    also objects. This is not true at the implementation
	    level, though:
	  </p>
	  <ul>
	    <li>
	      Most integers (those whose abolute value is less than or
	      equal to 2<sup>29</sup>) are normally stored straight in
	      the call stack (or straight inside any object it is a
	      member of).
	    </li>
	    <li>
	      Characters are also normally stored straight in the call stack (or
	      straight inside any object it is a member of).
	    </li>
	    <li>
	      Floating point numbers use a separate memory allocation, but
	      still uses some optimizations to increase evaluation speed. A
	      future version of Anna will hopefully be able to store floats
	      without allocating any heap memory by creating holes in the stack.
	    </li>
	  </ul>
	  <p>
	    For a more complete description of the pointer magic used
	    to avoid memory allocations for integers and characters,
	    see for
	    example <a href="http://nikic.github.com/2012/02/02/Pointer-magic-for-efficient-dynamic-value-representations.html">this
	    article</a>.
	  </p>
	  <p>
	    The above holds true for as long as only common operations,
	    such as adding, subtracting, etc. are performed on the
	    values. If e.g. reflection is employed or any other operation
	    that requires access to the object type, then any object stored
	    directly in the stack is silently converted into a full fledged
	    object.
	  </p>
	  <p>
	    Aside from the performance increase and memory usage
	    reduction, there is no way to tell that this is happening
	    behind the scenes. This is possible because the above data
	    types are all imutable and no memory location pointer can
	    be obtained for an object. It is simply impossible to tell
	    e.g. two integers with the same value apart.
	  </p>

	  <h2><a name="implementation-object-model">The Anna object struct</a></h2>
	  <p>
	    The Anna implementation uses a very simplistic object
	    model. Objects in Anna are represented by a struct looking
	    like this:
	  </p>
	  <pre>
struct anna_object
{
    /**
       Various bit flags for this object. The first 8 bits of this
       flag are reserved by the memory allocator and should not be
       touched.
    */
    int flags;
    /**
       The type of this object
    */
    struct anna_type *type;
    /**
       All the non-static member values of this object. To decode what
       member lives at what offset, use the information stored in the
       type object.
    */
    anna_entry_t *member[];
};
	  </pre>
	  <p>
	    The memory overhead of an object (including the memory
	    overhead of the memory allocator and the garbage
	    collector, is one word (the flags) and one memory
	    address(the object type).
	  </p>
	  <ul>
	    <li>
	      Each <code>anna_entry_t</code> represents one non-static
	      member value of the object.
	    </li>
	    <li>
	      The member count of an object is stored in the object
	      type.
	    </li>
	    <li>
	      The lower bits of an anna_entry_t pointer can be used to
	      determine what type of entry is currently stored as the
	      current member value. The possible values are described
	      in the table below.
	    </li>
	  </ul>
	  
	  <table class='anna-table'>
	    <caption>
	      The possible values of the lower bits of an anna_entry_t pointer.
	    </caption>
	    <thead>
	      <tr>
		<th>
		  Bit pattern
		</th>
		<th>
		  Meaning
		</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>
		  *000
		</td>
		<td>
		  This entry is used to store a pointer to a
		  anna_object struct, which lives at the address
		  pointed to by this pointer.
		</td>
	      </tr>
	      <tr>
		<td>
		  *01
		</td>
		<td>
		  This entry is used to store a Char object. To get
		  the value of the object, right shift the entry two
		  bits.
		</td>
	      </tr>
	      <tr>
		<td>
		  *10
		</td>
		<td>
		  This entry is used to store a piece of memory that
		  should be garbage collected, but is not an
		  anna_object struct. The address of the object can be
		  found by stripping the last bit from the pointer.
		</td>
	      </tr>
	      <tr>
		<td>
		  *11
		</td>
		<td>
		  This entry is used to store an Int object. To get
		  the value of the object, right shift the entry two
		  bits.
		</td>
	      </tr>
	      <tr>
		<td>
		  *100
		</td>
		<td>
		  This entry is used to store a pointer to a floating
		  point number. It should be garbage collected. The
		  address of the floating point number can be found by
		  stripping the last three bits from the pointer.
		</td>
	      </tr>
	    </tbody>
	  </table>

	  <h2><a name="implementation-type-model">The Anna type struct</a></h2>
	  <p>
	    The type struct used to store information about a specific
	    type in Anna is rather complicated. In addition to storing
	    static member data, the type struct also stores data that
	    allows for introspection, efficient garbage collection,
	    etc.
	  </p>
	  
	  <h1><a name="tests">The Anna test suite</a></h1>
	  <p>
	    Anna ships with a test suite consisting of a series of
	    small Anna programs and their expected output and exit
	    status. Currently, the tests suite consists of ~250 tests
	    taking up over 4000 lines of code, which is about 9 % of
	    the total source code in the Anna distribution.
	  </p>
	  <p>
	    To run the Anna test suite, simply type <code>make
	    test</code> at the command line prompt. Don't be surprised
	    if a few tests fail, Anna is currently not 100 % finished.
	  </p>
	  <p>
	    The test suite has multiple goals, the most important of which are:
	  </p>
	  <ul>
	    <li>
	      Regression testing for old bugs. This is the most
	      central task for the test suite. Every major bug
	      discovered in anna should be turned into an Anna test,
	      so that if the same bug resurfaces, it can be quickly
	      fixed.
	    </li>
	    <li>
	      Coverage testing. Ideally, the test suite should cover
	      every single line of Anna code. That is nowhere near true
	      as of today.
	    </li>
	    <li>
	      Overall sanity checking. A small number of test programs
	      are computational programs that calculate e.g. the
	      mangelbrot set, digits of Pi, perform N-body
	      simulations, etc. The point of these programs is to
	      check that Anna runs well on slightly larger problem
	      sets, e.g. that the garbage collector isn't leaking too
	      much memory. They can also provide some small degree of
	      sanity checking on performance changes.
	    </li>
	  </ul>
	  <h1><a name="limitations">Known limitations</a></h1>
	  <p>
	    Anna is still a work in progress. As such, there are
	    various known issues with the current
	    implementation. These include:
	  </p>
	  <ul>
	    
	    <li>
	      It is currently impossible to make subclasses of the
	      following unspecialized types:
	      <code class="anna-code">MutableList</code>, 
	      <code class="anna-code">ImutableList</code>, 
	      <code class="anna-code">Pair</code>
	      and <code class="anna-code">HashMap</code>. Making
	      subclasses of specialized versions of these types,
	      e.g. <code class="anna-code">HashMap«Int, Char»</code>
	      works fine, as does subclassing any other unspecialized
	      types. 
	    </li>
	    
	    <li>
	      Anna is currently very slow; usually roughly 50 % slower
	      than an equivalet program written in Python.
	    </li>
	    <li>
	      The Anna compiler is fairly slow and memory hungry. It
	      will usually eat around ten megabytes of memory during
	      startup and will take around 0.1 seconds on a reasonably
	      modern processor. Part of this is because every
	      available Anna module is currently parsed and compiled
	      at startup, regardless of if it is used or not.
	    </li>
	    
	    <li>
	      The current garbage collection algorithm is rather
	      simplistic and slow.
	    </li>
	    
	    <li>
	      Calling of parent constructors in extended types is
	      currently poorly implemented. No parameter mangling or
	      calling of the correct constructors is done
	      automatically, meaning that handling of e.g. inheritance
	      diamonds must be done explicitly by the coder.
	    </li>
	  </ul>
	  <h1><a name="download">Getting Anna</a></h1>
	  <p>
	    Anna is open source and can be downloaded online. There is
	    still no actual Anna release, the source code is avaiable
	    <a href="http://www.github.com/liljencrantz/anna">on Github</a>.
	  </p>

	</div>
      </div>
      <div class="anna-left-menu">
	<div class="anna-left-menu-inner">
	  
	  <div>
	    <h2>Table of content</h2>
	    <div class="toc"></div>
	    
	  </div>
	</div>
      </div>
    </div>
  </body>
</html>

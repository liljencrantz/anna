attribute(internal, doc("Internal module for macros related to iteration."));

use(parser);

def isBlock(Node n) { (((n as Call).function as Identifier).name == "__block__") }

def Call mangleIterator(Call node)
{
    def Node iterDeclare(Node id, Node nodeType)
    {
	ast(
	    __var__(%id, %nodeType, ?, {})).replace(ast(id), id).replace(ast(nodeType) , nodeType);
    }
	    
    if( !(node.count in Range(2, 4, 1)) or !(node.function as Call) or !(node[0] as Identifier) or !(isBlock(node[-1])))
    {
	return node;
    }

    n := MutableList«Node»();  
    
    body := node[-1];

    if(node.count == 2)
    {
	n[0] = iterDeclare(
	    Identifier(body, "!unused"), 
	    ast(__staticTypeOf__(%iter.key)));
	n[1] = iterDeclare(
	    node[0],
	    ast(__staticTypeOf__(%iter.value)));
    } 
    else
    {
	checkNodeType(node[1], Identifier);
	n[0] = iterDeclare(
	    node[0],
	    ast(__staticTypeOf__(%iter.key)));
	n[1] = iterDeclare(
	    node[1],
	    ast(__staticTypeOf__(%iter.value)));
    }
    
    res := Call(
	node, 
	node.function,  
	Call(
	    body, 
	    Identifier(body, "__def__"),
	    Identifier(body, "!iterator"), 
	    NullLiteral(body),
	    Call(body, Identifier(body, "__block__"), n[0], n[1]),
	    ast({block, loop}), 
	    body););
    
    return res as Call;
}

def Node __iter__(Call node)
(
    doc("Internal helper method for each, map, and friends")
)
{
    def Node iterDeclare(Node id, Node nodeType)
    {
	ast(
	    __var__(%id, %nodeType, ?, {})).replace(ast(id), id).replace(ast(nodeType) , nodeType);
    }
	    
    node.expand? = ?;

    if( !(node.count in Range(2, 4, 1)) or !(node.function as Call) or !(node[0] as Identifier) or !(isBlock(node[-1])))
    {
	return node;
    }

    n := MutableList«Node»();  
    
    body := node[-1];

    if(node.count == 2)
    {
	n[0] = iterDeclare(
	    Identifier(body, "!unused"), 
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.each, 0),0)));
	n[1] = iterDeclare(
	    node[0],
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.each, 0), 1)));
    } 
    else
    {
	checkNodeType(node[1], Identifier);
	n[0] = iterDeclare(
	    node[0],
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.each, 0),0)));
	n[1] = iterDeclare(
	    node[1],
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.each, 0), 1)));
    }
    
    attr := ast({block, loop});
    decl := Call(body, Identifier(body, "__block__"), n[0], n[1]);    
    
    fun := node.function as Call;
    origName := fun[1] as Identifier;  

    fun[1] = origName;

    func := Call(
	body, 
	Identifier(body, "__def__"),
	Identifier(body, "!iterator"), 
	NullLiteral(body),
	decl,
	attr, 
	body);

    res := Call(
	node, 
	fun,  
	func);
    list := (fun as Call)[0];
    res.expand? = ?;
    if(origName.name == "map")
    {
//	print(list, "\n\n");
        res = ast(
	    {
		%body := %bodyValue;
	        %list := %listValue;
	        __res := %list.map(%body);
		__res as %nodeType;
	    }()).replace(ast(%bodyValue) , func) 
	    .replace(ast(listValue) , list) 
	    .replace(
		ast(nodeType) , 
		Call(?, ast(__specialize__), ast(__staticReturnTypeOf__(%list.map)), ast({__staticReturnTypeOf__(%body)}))) as Call;
    }
    else
    {
        res = ast(
	    {
 	        %list := %listValue;
		%body := %bodyValue;
	        %list.%fun(%body);
	    }()).replace(ast(fun) , fun[1])
	    .replace(ast(listValue) , list).replace(ast(bodyValue) , func) as Call;
    }
    res = res.replace(ast(body) , Identifier(?, identifier("body")))
	.replace(ast(list), Identifier(?, identifier("list"))) as Call;
    return res;
}

macro each(node)(doc("A macro adding a bit of syntactic sugar for each loops.")){__iter__(node)}
macro filter(node)(doc("A macro adding a bit of syntactic sugar for filter loops.")){__iter__(node)}
macro find(node)(doc("A macro adding a bit of syntactic sugar for find loops.")){__iter__(node)}
macro map(node)(doc("A macro adding a bit of syntactic sugar for map loops.")){__iter__(node)}

macro ieach(node)
{
    node = mangleIterator(node) as Call;
//    printInternal(node.toString());
    coll := (node.function as Call)[0];
    body := node[0];    

    res := ast(
	nothing(
	    %collVar := %coll;
	    %iter := %collVar.iterator,
	    %bodyVar := %body;
	    while(!%iter.empty?)
	    {
		%bodyVar(%iter.key, %iter.value);
		%iter++;
	    },
	    %collVar
	    );
	)
	.replace(ast(coll), coll)
	.replace(ast(body), body)
	.replace(ast(bodyVar), Identifier(?, parser.identifier("body")))
	.replace(ast(iter), Identifier(?, parser.identifier("iter")))
	.replace(ast(collVar), Identifier(?, parser.identifier("collection")));
//    printInternal(res.toString());
    return res;
}

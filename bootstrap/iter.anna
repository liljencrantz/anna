attribute(internal, doc("Internal module for macros related to iteration."));

use(parser);

def isBlock(Node n) { (((n as Call).function as Identifier).name == "__block__") }

def Call mangleIterator(Call node)
{
    def Node iterDeclare(Node id, Node nodeType)
    {
	ast(
	    __var__(%id, %nodeType, ?, {})).replace(ast(id), id).replace(ast(nodeType) , nodeType);
    }
	    
    if( !(node.count in Range(2, 4, 1)) or !(node.function as Call) or !(node[0] as Identifier) or !(isBlock(node[-1])))
    {
	return node;
    }

    n := MutableList«Node»();  
    
    body := node[-1];

    if(node.count == 2)
    {
	n[0] = iterDeclare(
	    Identifier(body, "!unused"), 
	    ast(__staticTypeOf__(%iter.key)));
	n[1] = iterDeclare(
	    node[0],
	    ast(__staticTypeOf__(%iter.value)));
    } 
    else
    {
	checkNodeType(node[1], Identifier);
	n[0] = iterDeclare(
	    node[0],
	    ast(__staticTypeOf__(%iter.key)));
	n[1] = iterDeclare(
	    node[1],
	    ast(__staticTypeOf__(%iter.value)));
    }
    
    res := Call(
	node, 
	node.function,  
	Call(
	    body, 
	    Identifier(body, "__def__"),
	    Identifier(body, parser.identifier("iterator")), 
	    NullLiteral(body),
	    Call(body, Identifier(body, "__block__"), n[0], n[1]),
	    ast(nothing(block)), 
	    body););
    
    return res as Call;
}

macro each(node)
{
    node = mangleIterator(node) as Call;
    
    if( (node.count != 1) or !(node.function as Call))
    {
	node.expand? = ?;
	return node;
    }
    
    coll := (node.function as Call)[0];
    
    iterFun := node[0] as Call;
    res := ? as Node;

    if((iterFun.function as Identifier).name == "__def__")
    {
        body := iterFun[4] as Call;
        decl := iterFun[2] as Call;
	body.function = ast(nothing);

	res = ast(
	    nothing(
		%collVar := %coll;
		%iter := %collVar.iterator,
		while(%iter.valid?)
		{
		    %keyVar := %iter.key as %keyType;
		    %valueVar := %iter.value as %valueType;
		    %iter++;
		    %body;
		},
		%collVar
		);
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(body), body)
	    .replace(ast(keyVar), (decl[0] as Call)[0])
	    .replace(ast(valueVar), (decl[1] as Call)[0])
	    .replace(ast(keyType), (decl[0] as Call)[1])
	    .replace(ast(valueType), (decl[1] as Call)[1])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(collVar), Identifier(?, parser.identifier("collection")));
    }
    else
    {
	res = ast(
	    nothing(
		%collVar := %coll;
		%iter := %collVar.iterator,
		%funVar := %fun;
		while(%iter.valid?)
		{
		    %funVar(%iter.key, %iter.value);
		    %iter++;
		},
		%collVar
		)
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(fun), node[0])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(collVar), Identifier(?, parser.identifier("collection")))
	    .replace(ast(funVar), Identifier(?, parser.identifier("funVar")));
    }
    return res;
}

macro filter(node)
{
    node = mangleIterator(node) as Call;
    
    if( (node.count != 1) or !(node.function as Call))
    {
	node.expand? = ?;
	return node;
    }
    
    coll := (node.function as Call)[0];
    
    iterFun := node[0] as Call;
    res := ? as Node;

    if((iterFun.function as Identifier).name == "__def__")
    {
        body := iterFun[4] as Call;
        decl := iterFun[2] as Call;
	body.function = ast(nothing);

	res = ast(
	    nothing(
		%iter := %coll.iterator,
		%res := «__staticTypeOf__(%iter.value)»[];
		while(%iter.valid?)
		{
		    %keyVar := %iter.key as %keyType;
		    %valueVar := %iter.value as %valueType;
		    %iter++;
		    (%body) and (%res.push(%valueVar));
		},
		%res;
		);
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(body), body)
	    .replace(ast(keyVar), (decl[0] as Call)[0])
	    .replace(ast(valueVar), (decl[1] as Call)[0])
	    .replace(ast(keyType), (decl[0] as Call)[1])
	    .replace(ast(valueType), (decl[1] as Call)[1])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(res), Identifier(?, parser.identifier("res")));
    }
    else
    {
	res = ast(
	    nothing(
		%iter := %coll.iterator,
		%res := «__staticTypeOf__(%iter.value)»[];
		%funVar := %fun;
		while(%iter.valid?)
		{
		    %funVar(%iter.key, %iter.value) and (%res.push(%valueVar));
		    %iter++;
		},
		%res;
		)
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(fun), node[0])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(funVar), Identifier(?, parser.identifier("funVar")))
	    .replace(ast(res), Identifier(?, parser.identifier("res")));
    }
    return res;
}

macro map(node)
{
    node = mangleIterator(node) as Call;
    
    if( (node.count != 1) or !(node.function as Call))
    {
	node.expand? = ?;
	return node;
    }
    
    coll := (node.function as Call)[0];
    
    iterFun := node[0] as Call;
    res := ? as Node;

    if((iterFun.function as Identifier).name == "__def__")
    {
      body := iterFun[4].copy() as Call;
        decl := iterFun[2] as Call;
	body.function = ast(nothing);

	res = ast(
	    nothing(
		%iter := %coll.iterator,
		%res := «__staticReturnTypeOf__(%iterFun)»[];
		while(%iter.valid?)
		{
		    %keyVar := %iter.key as %keyType;
		    %valueVar := %iter.value as %valueType;
		    %iter++;
		    %res.push(%body);
		},
		%res;
		);
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(body), body)
	    .replace(ast(keyVar), (decl[0] as Call)[0])
	    .replace(ast(valueVar), (decl[1] as Call)[0])
	    .replace(ast(keyType), (decl[0] as Call)[1])
	    .replace(ast(valueType), (decl[1] as Call)[1])
	    .replace(ast(iterFun), iterFun)
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(res), Identifier(?, parser.identifier("res")));
    }
    else
    {
	res = ast(
	    nothing(
		%iter := %coll.iterator,
		%iterFunVar := %iterFun;
		%res := «__staticReturnTypeOf__(%iterFunVar)»[];
		while(%iter.valid?)
		{
		    %res.push(%iterFunVar(%iter.key, %iter.value));
		    %iter++;
		},
		%res;
		);
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(iterFun), node[0])
	    .replace(ast(iterFunVar), Identifier(?, parser.identifier("iterFunVar")))
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(res), Identifier(?, parser.identifier("res")));
    }
    return res;
}

macro find(node)
{
    node = mangleIterator(node) as Call;
    
    if( (node.count != 1) or !(node.function as Call))
    {
	node.expand? = ?;
	return node;
    }
    
    coll := (node.function as Call)[0];
    
    iterFun := node[0] as Call;
    res := ? as Node;

    if((iterFun.function as Identifier).name == "__def__")
    {
        body := iterFun[4] as Call;
        decl := iterFun[2] as Call;
	body.function = ast(nothing);

	res = ast(
	    nothing(
		%iter := %coll.iterator,
		%res := ? as __staticTypeOf__(%iter.value);
		while(%iter.valid?)
		{
		    %keyVar := %iter.key as %keyType;
		    %valueVar := %iter.value as %valueType;
		    %iter++;
		    (%body) and (%res = %valueVar; break);
		},
		%res;
		);
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(body), body)
	    .replace(ast(keyVar), (decl[0] as Call)[0])
	    .replace(ast(valueVar), (decl[1] as Call)[0])
	    .replace(ast(keyType), (decl[0] as Call)[1])
	    .replace(ast(valueType), (decl[1] as Call)[1])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(res), Identifier(?, parser.identifier("res")));
    }
    else
    {
	res = ast(
	    nothing(
		%iter := %coll.iterator,
		%res := ? as __staticTypeOf__(%iter.value);
		%funVar := %fun;
		while(%iter.valid?)
		{
		    %funVar(%iter.key, %iter.value) and (%res = %valueVar; break);
		    %iter++;
		},
		%res;
		)
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(fun), node[0])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(funVar), Identifier(?, parser.identifier("funVar")))
	    .replace(ast(res), Identifier(?, parser.identifier("res")));
    }
    return res;
}

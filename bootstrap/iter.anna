attribute(internal, doc("Internal module for macros related to iteration."));

use(parser);

def isBlock(Node n) { (((n as Call).function as Identifier).name == "__block__") }

def Call mangleIterator(Call node)
{
    def Node iterDeclare(Node id, Node nodeType)
    {
	ast(
	    __var__(%id, %nodeType, ?, {})).replace(ast(id), id).replace(ast(nodeType) , nodeType);
    }
	    
    if( !(node.count in Range(2, 4, 1)) or !(node.function as Call) or !(node[0] as Identifier) or !(isBlock(node[-1])))
    {
	return node;
    }

    n := MutableList«Node»();  
    
    body := node[-1];

    if(node.count == 2)
    {
	n[0] = iterDeclare(
	    Identifier(body, "!unused"), 
	    ast(__staticTypeOf__(%iter.key)));
	n[1] = iterDeclare(
	    node[0],
	    ast(__staticTypeOf__(%iter.value)));
    } 
    else
    {
	checkNodeType(node[1], Identifier);
	n[0] = iterDeclare(
	    node[0],
	    ast(__staticTypeOf__(%iter.key)));
	n[1] = iterDeclare(
	    node[1],
	    ast(__staticTypeOf__(%iter.value)));
    }
    
    res := Call(
	node, 
	node.function,  
	Call(
	    body, 
	    Identifier(body, "__def__"),
	    Identifier(body, parser.identifier("iterator")), 
	    NullLiteral(body),
	    Call(body, Identifier(body, "__block__"), n[0], n[1]),
	    ast(nothing(block)), 
	    body););
    
    return res as Call;
}

def Node __iter__(Call node)
(
    doc("Internal helper method for each, map, and friends")
)
{
    def Node iterDeclare(Node id, Node nodeType)
    {
	ast(
	    __var__(%id, %nodeType, ?, {})).replace(ast(id), id).replace(ast(nodeType) , nodeType);
    }
	    
    node.expand? = ?;

    if( !(node.count in Range(2, 4, 1)) or !(node.function as Call) or !(node[0] as Identifier) or !(isBlock(node[-1])))
    {
	return node;
    }

    n := MutableList«Node»();  
    
    body := node[-1];

    if(node.count == 2)
    {
	n[0] = iterDeclare(
	    Identifier(body, "!unused"), 
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.map, 0),0)));
	n[1] = iterDeclare(
	    node[0],
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.map, 0), 1)));
    } 
    else
    {
	checkNodeType(node[1], Identifier);
	n[0] = iterDeclare(
	    node[0],
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.map, 0),0)));
	n[1] = iterDeclare(
	    node[1],
	    ast(__staticInputTypeOf__(__staticInputTypeOf__(%list.map, 0), 1)));
    }
    
    attr := ast({block, loop});
    decl := Call(body, Identifier(body, "__block__"), n[0], n[1]);    
    
    fun := node.function as Call;
    origName := fun[1] as Identifier;  

    fun[1] = origName;

    func := Call(
	body, 
	Identifier(body, "__def__"),
	Identifier(body, "!iterator"), 
	NullLiteral(body),
	decl,
	attr, 
	body);

    res := Call(
	node, 
	fun,  
	func);
    list := (fun as Call)[0];
    res.expand? = ?;
    if(origName.name == "map")
    {
//	print(list, "\n\n");
        res = ast(
	    {
		%body := %bodyValue;
	        %list := %listValue;
	        __res := %list.map(%body);
		__res as %nodeType;
	    }()).replace(ast(%bodyValue) , func) 
	    .replace(ast(listValue) , list) 
	    .replace(
		ast(nodeType) , 
		Call(?, ast(__specialize__), ast(__staticReturnTypeOf__(%list.map)), ast({__staticReturnTypeOf__(%body)}))) as Call;
    }
    else
    {
        res = ast(
	    {
 	        %list := %listValue;
		%body := %bodyValue;
	        %list.%fun(%body);
	    }()).replace(ast(fun) , fun[1])
	    .replace(ast(listValue) , list).replace(ast(bodyValue) , func) as Call;
    }
    res = res.replace(ast(body) , Identifier(?, identifier("body")))
	.replace(ast(list), Identifier(?, identifier("list"))) as Call;
    return res;
}

macro filter(node)(doc("A macro adding a bit of syntactic sugar for filter loops.")){__iter__(node)}
macro find(node)(doc("A macro adding a bit of syntactic sugar for find loops.")){__iter__(node)}
macro map(node)(doc("A macro adding a bit of syntactic sugar for map loops.")){__iter__(node)}

macro each(node)
{
    node = mangleIterator(node) as Call;
    
    if( (node.count != 1) or !(node.function as Call))
    {
	node.expand? = ?;
	return node;
    }
    
    coll := (node.function as Call)[0];
    
    iterFun := node[0] as Call;
    res := ? as Node;

    if((iterFun.function as Identifier).name == "__def__")
    {
        body := iterFun[4] as Call;
        decl := iterFun[2] as Call;
	body.function = ast(nothing);

	res = ast(
	    nothing(
		%collVar := %coll;
		%iter := %collVar.iterator,
		while(%iter.valid?)
		{
		    %keyVar := %iter.key as %keyType;
		    %valueVar := %iter.value as %valueType;
		    %iter++;
		    %body;
		},
		%collVar
		);
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(body), body)
	    .replace(ast(keyVar), (decl[0] as Call)[0])
	    .replace(ast(valueVar), (decl[1] as Call)[0])
	    .replace(ast(keyType), (decl[0] as Call)[1])
	    .replace(ast(valueType), (decl[1] as Call)[1])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(collVar), Identifier(?, parser.identifier("collection")));
    }
    else
    {
	res = ast(
	    nothing(
		%collVar := %coll;
		%iter := %collVar.iterator,
		while(%iter.valid?)
		{
		    %fun(%iter.key, %iter.value);
		    %iter++;
		},
		%collVar
		)
	    )
	    .replace(ast(coll), coll)
	    .replace(ast(fun), node[0])
	    .replace(ast(iter), Identifier(?, parser.identifier("iter")))
	    .replace(ast(collVar), Identifier(?, parser.identifier("collection")));
    }
    return res;
}

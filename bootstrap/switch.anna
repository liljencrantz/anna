
macro switch(node)
{
    checkCallCount(node, 2);
    checkNodeBlock(node[1]);
    switchBody := node[1] as Call;
//    print(node, '\n');
    switchBlock := Call(
	node, 
	Identifier(node, "__block__"),
	ast(%val := %input));
    lastIf := ? as Call;
    switchBody.each(idx, case)
    {
        caseCall := case as Call;
        next := ? as Call;
	if(caseCall.isCallTo("case"))
	{
	    checkCallCount(caseCall, 2);
	    checkNodeBlock(caseCall[1]);
//	print(caseCall[1]);
	    next =
		(
		    ast(
			__if__(%val == %cond, %caseBody, {})
			) % [
			    "cond": caseCall[0],
			    "caseBody": caseCall[1]
			    ]) as Call;
	} else
	{
	    if(caseCall.isCallTo("default"))
	    {
		if(idx != switchBody.count-1)
		{
		    caseCall.error("Invalid position for default");
		    return NullLiteral(node);
		}
		checkCallCount(caseCall, 1);
		checkNodeBlock(caseCall[0]);
		next = caseCall[0] as Call;
	    } else
	    {
		case.error("Expected a case or default statement");
		return NullLiteral(node);
	    }
	}
	if(lastIf)
	{
	    lastIf[2] = if(!next.isBlock())
	    {
		Call(node, Identifier(node, "__block__"), next);
	    } else 
	    {
		next;
	    }
	} else
	{
	    if(next.isBlock())
	    {
		next = Call(node, next);
	    }
	    switchBlock ~= [next];
	}
	lastIf = next;
    }
    
    res := Call(node, switchBlock) % [
	"val": Identifier(node, identifier("switchValue")), 
	"input": node[0]];
    return res;
}

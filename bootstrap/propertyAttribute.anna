attribute(internal, doc("Internal module for the propertyAttribute macro."));

use(parser);

def Call getAttributePayload(Call c)
{
    expandCode(
	if(c.callTo?(%name)) { return c },
	name: ["__constInternal__", "__varInternal__", "__typeInternal__", "__defInternal"]);
    if(c.count == 1 and c[0] as Call)
    {
	return getAttributePayload(c[0] as Call);
    }
    return ?
}

macro propertyAttribute(node)
{
    payload := getAttributePayload(node);
    if(payload.callTo?("__constInternal__"))
    {
        decl := payload as Call;
	if(decl[2].callTo?("__def__"))
	{
	    getter := decl[2] as Call;
	    propType := if(getter[1].__type__ != NullLiteral){getter[1]} else {ast(__staticReturnTypeOf__(%fun)) % ["fun": decl[2]];}
	    propName := (decl[0] as Identifier).name;
            getterName := "!" ~ propName ~ "Getter";
	    getter[0] = Identifier(getter[0], getterName);
	    decl[0] = Identifier(decl[0], getterName);
	    attr := decl[3] as Call;
  	    doc := (attr.filterByCall("doc")[0] as StringLiteral).payload or "";
	    decl[3] = ast({bound, doc(%doc)}) % ["doc": StringLiteral(attr, "Automatically generated getter method for the % property. For internal use only." % [propName])];
	    propDecl := ast(var %Type %name (property(%getterName), doc(%doc))) % [
		"Type": propType,
		"name": Identifier(node, propName),
		"getterName": Identifier(node, getterName),
		"doc": StringLiteral(attr, doc),
		];

	    res := ast(nothing(%property, %getter)) % [
		"property": propDecl,
		"getter": node[0] ];
	    return res;
	}
    }
    return node[0];
}

attribute(doc("
Helper commands for the anna repl (interactive prompt) implementation.
This module is automatically used by the anna interactive prompt, and
there is very rarely any reason to use it manually."));

enum HtmlMode{
    text, textSpace, tagName, tagContent, pre, li
}

def formatHtml(String input)
    (doc("Format the spcified HTML snippet into something suitable for printing in a terminal."), internal)
{
    
    mode := [HtmlMode::text];
    
    res := "".thaw;
    currentParagraph := "".thaw;
    currentTag := "".thaw;

    def handleTag(String currentTag)
    {
	switch(currentTag)
	{
	    case("p")
	    {
		mode[-1] = HtmlMode::text;
		
		res ~= linebreak(currentParagraph.split(" ", ?));
		res ~= "\n";
		currentParagraph.count=0;
	    }

	    case("li")
	    {
		mode.push(HtmlMode::li);
		
		res ~= linebreak(currentParagraph.split(" ", ?));
		res ~= "\n";
		currentParagraph.count=0;
	    }

	    case("/li")
	    {
		mode.pop();
		res ~= linebreak(currentParagraph.split(" ", ?), firstPrefix: " * ", prefix: "   ");
		currentParagraph.count=0;
	    }

	    case("pre")
	    {
		mode.push(HtmlMode::pre);		
		res ~= linebreak(currentParagraph.split(" ", ?));
		res ~= "\n";
		currentParagraph.count=0;
	    }

	    case("/pre")
	    {
		mode.pop();
		res ~= currentParagraph;
		currentParagraph.count=0;
	    }

	    default
	    {

	    }

	}
	currentTag.count=0;
    }

    input.each(idx, ch)
    {
	switch(mode[-1])
	{
	    case(HtmlMode::text, HtmlMode::li)
	    {
		switch(ch)
		{
		    case('<')
		    {
			mode.push(HtmlMode::tagName);
		    }

		    case('\n', '\t', '\r')
		    {
			mode.push(HtmlMode::textSpace);
			currentParagraph ~= ' ';
		    }

		    default
		    {
			currentParagraph ~= ch;
		    }
		}
	    }

	    case(HtmlMode::pre)
	    {
		switch(ch)
		{
		    case('<')
		    {
			mode.push(HtmlMode::tagName);
		    }


		    default
		    {
			currentParagraph ~= ch;
		    }
		}
		
	    }

	    case(HtmlMode::textSpace)
	    {
		switch(ch)
		{
		    case('<')
		    {
			mode[-1] = HtmlMode::tagName;
		    }

		    case('\n', '\t', '\r')
		    {
		    }

		    default
		    {
			mode.pop();
			currentParagraph ~= ch;
		    }
		}		
	    }

	    case(HtmlMode::tagName)
	    {
		switch(ch)
		{
		    case(' ')
		    {
			mode[-1] = HtmlMode::tagContent;
		    }

		    case('>')
		    {
			mode.pop();
			handleTag(currentTag);
		    }

		    default
		    {
			currentTag ~= ch;
		    }
		}
	    }

	    case(HtmlMode::tagContent)
	    {
		switch(ch)
		{
		    case('>')
		    {
			mode.pop();
			handleTag(currentTag);
		    }

		    default
		    {
			
		    }
		}

	    }

	}

    }

    res ~= "\n\n";
    res ~= linebreak(currentParagraph.split(" ", ?));

    return res;
}

def linebreak(List«Object» wordList, String prefix = "", String firstPrefix = "") 
(internal, doc("Internal helper method for dir and help, used to line break a list of strings."))
{    
    res := firstPrefix.thaw;
    col := res.count;        
    wordList.each(idx, wordObj)
    {
	word := wordObj.toString();
	if(idx == 0)
	{
	    res ~= word;
	    col += word.count;
	}
	else
	{
	    if(col + word.count + 1 > 80)
	    {
		res ~= "\n";
		res ~= prefix;
		res ~= word;
		col = word.count + prefix.count;
	    }
	    else
	    {
		res ~= " ";
		res ~= word;
		col += word.count+1;
	    }
	}
    }
    return res;
}



def help(Object object)
    (doc(
	"This is the main help function of the interactive Anna command line. It takes any object as a parameter and uses introspection to provide as much help as possible about that object to the user.",
	"If the object is a Type"))
{
    use(parser);
    use(reflection);

    res := "".thaw;

    /*
      The attribute list to extract documentation from. First we check
      if the object we want help on has it's own attribute list. If
      so, we use it. Otherwise, we show help on it's type. That way,
      we get the same help message for e.g. help(Int) and help(3),
      which is usually what we want.
    */
    class WithAttribute
    {
	const Call attribute;
    }
    attribute := (object as WithAttribute).attribute or object.__type__.attribute;
    doc := annaUtil.findAttribute(attribute, "doc");
    if(doc.empty?)
    {
	res ~= "No documentation available for object of type " ~ (object.__type__.name or "Null");
    }
    else
    {
	res ~= "".join(
	    doc.map(docFragment)
	    {
	      fragment := docFragment as StringLiteral;
	      formatHtml(fragment.payload);
	    });
    }
    if(object.__type__.module?)
    {

      smemb := object.__type__.member.filter(memb){!memb.internal?}.sort(def Int(Object first, Object second){(first as Member).name.__cmp__((second as Member).name)}).map(memb){memb as Member};


//	print(o.__type__.member.filter(memb){!memb.internal?});

        submodule := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.static? and val.__type__.module?;
	}
        subtype := smemb.filter(mem)
	{
	    val := mem.value(?);
	    mem.static? and (val as Type);
	}
        subother := smemb.filter(mem)
	{
	    val := mem.value(?);
	    !(val.__type__.module?) and !(val as Type) and (mem.type != Null);
	}
	
	if(!submodule.empty?)
	{
	    res ~= "\n\nThis module has the following submodules:\n";
	    res ~= linebreak(submodule);
	}

	if(!subtype.empty?)
	{
	    res ~= "\n\nThis module contains the following types:\n";
	    res ~= linebreak(subtype);
	}
    }

    return res;
}

def dir(Object object)
    (doc("This is an additional help function for the interactive Anna command line. If takes any object as a parameter and lists all members of that type ina a format suitable for the screen. This is just a very thin wrapper around the member property of the Type type."))
{
    return linebreak(((object as reflection.Type) or object.__type__).member);
}


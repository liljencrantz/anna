attribute(internal, doc("
The anna repl implementation."));

def repl(reflection.Continuation debugFrame = ?)
    (doc("
This is the so called repl of anna. Repl is short for Read, Evaluate
and Print-Loop, and is what implements the interactive prompt of a
programming language. If Anna is called without specifying an
application to run, a repl is invoked. It will show an interactive
prompt using the readLine library, and will then compile that line
into a function using the parser module, and will then execute that
function and print it's return value to screen.",
	 "If the repl is provided with a Continuation as a perameter, the repl
will include tools for debugging that frame."), internal)
{
    use(parser);

    doLoop := 1;
    
    print("Welcome to anna!

Type «help» for more information.");

    /*
      If the user writes e.g. a use clause or an extend clause, we
      don't actually execute it, we instead save that clause away in
      this list. On every subsequent call, we prepend these
      expressions to the one the user wrote.
     */
    globalClause :== «Node»[ast(use(replTool))];
    localClause :== «Node»[];
    
    saveHistory :== {
	if(readLine.history.write(historyFile))
	{
	    print("Failed to save history");
	    print(unix.error.errorString(unix.error.errno));
	}
    }

    /*
      Function for controlled exit
     */
    die :== {
	print("Bye!");
	saveHistory();
	doLoop = ?;
    }

    /*
      We use a continuation of the previous function call in order to
      sneak a peek of all the variables already declared and then add
      them to the new function used to evaluate the next statement.
    */
    previousContinuation := ? as reflection.Continuation;    

    /*
      Set up the history list
    */
    historyFile :== unix.env.getenv("HOME") ~ "/.anna_history";
    readLine.history.read(historyFile);

    /*
      Set up the various short cut actions available, such as showing
      a help text when the user writes «help».
    */

    helpText :== "Welcome to Anna!

If this is your first time using Anna, you might want to
check out the tutorial available at
http://liljencrantz.github.com/anna/tutorial.html

If you want to ask for help on a particular object directly from the
interpreter, you can type «help(OBJECT)». For example, to show help on
the lang module, type «help(lang)». 

If you want to list the contents of an object, type «dir(OBJECT)». For
example, to show the contents of the Int type, type «dir(Int)».";

    copyrightText :== "Copyright(C) 2005-2012 Axel Liljencrantz
All rights reserved.";
    helloText:= "Hi!";
    licenseText :== copyrightText ~ "

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";

    action :== «Node, reflection.Block»[
	ast(hello): {print(helloText)},
	ast(help): {print(helpText)},
	ast(copyright): {print(copyrightText)},
	ast(license): {print(licenseText)},
	ast(quit): die,
	ast(exit): die,
	];

    actionMapping :== «String, def Node (parser.Call input)»[];

    firstPrompt := "anna> ";

    if(debugFrame)
    {
	/*
	  Add some additional functionality for debugger prompts
	 */

	// continue exits the debugger
	action[ast(continue)] = die;

	// break someFunction:someLineNumber inserts a breakpoint
	actionMapping["break"] = def (parser.Call input){
	    use(parser);
	    if( input.count != 1 or !(input[0].callTo?("__mapping__")))
	    {
		print("Invalid breakpoint");
		return ?;
	    }
	    mapping := input[0] as Call;
	    ast(debug.breakpoint(%fun, %line)) % [
		"fun": mapping[0],
		"line": mapping[1],
		];
	}

	// Add a frame variable to the global scope, pointing to the current continuation frame
	globalClause.push(ast(frame :== %frame) % ["frame": parser.Dummy(?, debugFrame)]);

	// Create a struct of all the variables in the current continuation frame, 
	// and add that into a use clause in the function
	varStruct :== ast(struct());
	debugFrame.variable.each(val)
	{
	    el := ast(%name: %value) % [
		"name": Identifier(?, val.name),
		"value": (if(val.value){Dummy(?, val.value)} else {NullLiteral(?)}) as Node];
	    varStruct.push(el);
	}
	localClause.push(ast(use(%varStruct)) % ["varStruct": varStruct]);

	globalClause.push(ast(use(debug)));

	firstPrompt = "debug> ";
    }
    
    secondPrompt := " " * firstPrompt.count;

    prev := ? as Object;
    /*
      Start the main repl loop
    */
    while(doLoop)
    {
        line := "".thaw;
        parsedAst := ? as Call;
	
        prompt := firstPrompt;
	
        parseError :== collect(error.CompilationError)
	{
	    while(1)
	    {
	        lineElement :== readLine.readLine(prompt);
		prompt = secondPrompt;
		if(!lineElement)
		{
		    print();
		    die();
		}
		
		line ~= lineElement;
		
	        incompleteError :== collect(error.IncompleteError){
		    parsedAst = parse(line) as Call;
		}
		if(parsedAst or incompleteError.empty?)
		{
		    break
		}
		line ~= "\n";
	    }
	}
	parseError.each(error)
	{
	    print(error.message);
	}

	if(line.count > 0)
	{
	    readLine.history.add(line);
	    saveHistory();
	}
	      
	/*
	  If the user entered multiple expressions on a single line,
	  execute them one at a time. Stop the loop on error.
	*/
	parsedAst.each(ast)
	{
	    /*
	      Check if this is one of the short cut actions like
	      «help», and if so, execute the corresponding action.
	    */
	    if(ast in action)
	    {
		action[ast]();
		continue;
	    }

	    actionMapping.each(name, call){
		if(ast.callTo?(name))
		{
		    ast = call(ast as parser.Call);
		    print("LALALA", ast);
		}
	    }
	    
	    run := 1;
  	    isGlobal :== (ast.callTo?("use") or ast.callTo?("expand"));
	    
	    /*
	      Add all variables that have been previously declared by
	      the user. We do this by introspecting a continuation of
	      the previous function invocation and extracting all it's
	      variable names and values.
	    */
	    variableDeclaration := ast(nothing());
	    previousContinuation.variable.each(memb)
	    {
		if(memb.name != "ans")
		{
		    variableDeclaration.push(
			ast(%name := %value as %Type) % [
			    "name": Identifier(?, memb.name), 
			    "value": (if(memb.value){Dummy(?, memb.value)}else{ast(? as Object)}) as Node,
			    "Type": Dummy(?, memb.type),
			    ]
			);
		}
	    }
	    variableDeclaration ~= localClause;
	    /*
	      Make an ast representing an entire module with our fancy
	      function in it.
	    */
  	    moduleAst := ast(
		nothing(
		    var reflection.Continuation %cont;
		    def %fun()
		    {
			%cont = reflection.currentContinuation; 
			%variable; 
			ans := %ans;
			%ast;
		    })) % [
			"fun": Identifier(?, "!fun"), 
			"ast": ast, 
			"cont": Identifier(?, "!cont"), 
			"variable": variableDeclaration,
			"ans": (if(prev){Dummy(?, prev)}else{ast(? as Object)}) as Node,
			];
	    if(isGlobal)
	    {
		run = ?;
	        moduleAst = ast(nothing(%ast)) % ["ast": ast];
	    }
	    
	    /*
	      Add all use and extend clauses from previous function invocations
	    */
	    globalClause.each(node){
		(moduleAst as Call).push(node);
	    }

	    code :== compile(moduleAst);
	    if(code)
	    {
		if(isGlobal)
		{
		    globalClause.push(ast);
		}
		
		if(run)
		{
		    /*
		      Use reflection to find our function and run it,
		      then use reflecation to find the continuation of
		      the function invocation so we can introspect it
		      in the next lap.
		    */
//		    print(moduleAst);
		    funMemb :== code.__type__.member.find(memb){memb.name=="!fun"};
  		    fun :== funMemb.value(code);
		    prev = (fun as reflection.Block)();
		    prev and print(prev);
		    previousContinuation = code.__type__.member.find(memb){memb.name=="!cont"}.value(code) as reflection.Continuation;
		}
	    }
	    else
	    {
		/*
		  If we encounter an error, stop executing the rest of
		  the expressions on this line.
		*/
		break;
	    }
	}
    }
}

def debugRepl() 
(
    doc("
Don't use this function. It is used internally by the breakpoint bytecode in 
the VM."),
    internal)
{
    debugFrame := reflection.currentContinuation.dynamicFrame.dynamicFrame;    
    repl(debugFrame);
}

def main() (doc("Calls the repl function"), internal)
{
    repl();
}
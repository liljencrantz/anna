
/*
    DO NOT MANUALLY EDIT THIS FILE.

    This file has been automaticaly generated by the anna bind
    utility. If you manually edit it, your changes will eventually be
    lost. Not to mention the fact that staring at machine generated
    code rots your brain. If this file is incorrect, either update the
    bind utility or update the binding source, which is located in the
    file:

    bindings/unix.bind

 */

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>
#include <sys/wait.h>
#include <grp.h>
#include <stdint.h>
#include <poll.h>
#include <sys/select.h>

#include "anna/anna.h"

// Declare internal variables for all types defined in this module
anna_type_t *unix_stat_type;
anna_type_t *unix_f_lock_type;
anna_type_t *unix_fd_set_type;
anna_type_t *unix_r_limit_type;
anna_type_t *unix_time_val_type;
anna_type_t *unix_time_zone_type;


// Data used to initialize all types defined in this module
const static anna_type_data_t anna_unix_type_data[] = 
{
};

// This is the source code of the various wrapper functions
const static anna_type_data_t anna_io_type_data[] = 
{
    { &unix_stat_type, L"Stat" },
    { &unix_f_lock_type, L"FLock" },
    { &unix_fd_set_type, L"FdSet" },
};
const static anna_type_data_t anna_open_mode_type_data[] = 
{
};

void anna_open_mode_create(anna_stack_template_t *stack);
void anna_open_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_open_mode_type_data, stack);        
}
void anna_open_mode_load(anna_stack_template_t *stack);
void anna_open_mode_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"readOnly", O_RDONLY, L"Open file in read-only mode.");
    anna_module_const_int(stack, L"writeOnly", O_WRONLY, L"Open file in write-only mode.");
    anna_module_const_int(stack, L"readWrite", O_RDWR, L"Open file in read-write mode.");
    anna_module_const_int(stack, L"append", O_APPEND, L"The file is opened in append mode.");
    anna_module_const_int(stack, L"async", O_ASYNC, L"Enable signal-driven I/O.");
    anna_module_const_int(stack, L"create", O_CREAT, L"If the file does not exist it will be created.");
    anna_module_const_int(stack, L"closeOnExec", O_CLOEXEC, L"Enable the close-on-exec flag for the new file descriptor.");
    anna_module_const_int(stack, L"direct", O_DIRECT, L"Try to minimize cache effects of the I/O to and from this file.");
    anna_module_const_int(stack, L"directory", O_DIRECTORY, L"If pathname is not a directory, cause the open to fail.");
    anna_module_const_int(stack, L"exclusive", O_EXCL, L"Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail.");
    anna_module_const_int(stack, L"largeFile", O_LARGEFILE, L"(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.");
    anna_module_const_int(stack, L"noAccessTime", O_NOATIME, L"Do not update the file last access time (st_atime in the inode) when the file is read().");
    anna_module_const_int(stack, L"noControllingTTY", O_NOCTTY, L"If pathname refers to a terminal device - it will not become the process's controlling terminal even if the process does not have one.");
    anna_module_const_int(stack, L"noFollow", O_NOFOLLOW, L"If pathname is a symbolic link, then the open fails.");
    anna_module_const_int(stack, L"nonBlock", O_NONBLOCK, L"When possible, the file is opened in nonblocking mode.");
    anna_module_const_int(stack, L"synchronous", O_SYNC, L"The file is opened for synchronous I/O.");
    anna_module_const_int(stack, L"truncate", O_TRUNC, L"f the file already exists and is a regular file and the open mode allows writing (i.e., is writeOnly or readWrite) it will be truncated to length 0.");

     anna_type_data_register(anna_open_mode_type_data, stack);
}
const static anna_type_data_t anna_stat_mode_type_data[] = 
{
};

void anna_stat_mode_create(anna_stack_template_t *stack);
void anna_stat_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_stat_mode_type_data, stack);        
}
void anna_stat_mode_load(anna_stack_template_t *stack);
void anna_stat_mode_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"regular", S_IFREG, L"Regular file");
    anna_module_const_int(stack, L"socket", S_IFSOCK, L"Socket");
    anna_module_const_int(stack, L"link", S_IFLNK, L"Symbolic link.");
    anna_module_const_int(stack, L"block", S_IFBLK, L"Block device.");
    anna_module_const_int(stack, L"directory", S_IFDIR, L"Directory.");
    anna_module_const_int(stack, L"character", S_IFCHR, L"Character device.");
    anna_module_const_int(stack, L"fifo", S_IFIFO, L"FIFO.");
    anna_module_const_int(stack, L"suid", S_ISUID, L"Set UID bit.");
    anna_module_const_int(stack, L"sgid", S_ISGID, L"Set-group-ID bit.");
    anna_module_const_int(stack, L"sticky", S_ISVTX, L"Sticky bit.");
    anna_module_const_int(stack, L"userAll", S_IRWXU, L"Mask for all file owner permissions.");
    anna_module_const_int(stack, L"userRead", S_IRUSR, L"File owner read permission.");
    anna_module_const_int(stack, L"userwrite", S_IWUSR, L"File owner write permission.");
    anna_module_const_int(stack, L"userExecute", S_IXUSR, L"File owner execute permission.");
    anna_module_const_int(stack, L"groupAll", S_IRWXG, L"Mask for all group permissions.");
    anna_module_const_int(stack, L"groupRead", S_IRGRP, L"Group has read permission.");
    anna_module_const_int(stack, L"groupwrite", S_IWGRP, L"Group has write permission.");
    anna_module_const_int(stack, L"groupExecute", S_IXGRP, L"Group has execute permission.");
    anna_module_const_int(stack, L"otherAll", S_IRWXO, L"Mask for permissions for others (not in group).");
    anna_module_const_int(stack, L"otherRead", S_IROTH, L"Others have read permission.");
    anna_module_const_int(stack, L"otherwrite", S_IWOTH, L"Others have write permission.");
    anna_module_const_int(stack, L"otherExecute", S_IXOTH, L"Others have execute permission.");

     anna_type_data_register(anna_stat_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_io_open, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_flags = anna_as_int(param[1]);
    int native_param_mode = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(open(native_param_name, native_param_flags, native_param_mode));
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_creat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(creat(native_param_name, native_param_mode));
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_read, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    unsigned char *native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    int native_param_count = anna_as_int(param[2]);

    // Validate parameters
    
    if(anna_buffer_ensure_capacity(anna_as_obj(param[1]), native_param_count)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    }
    

    // Call the function
    anna_entry_t *result = anna_from_int(read(native_param_fd, native_param_buffer, native_param_count));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_write, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    unsigned char *native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    int native_param_count = anna_as_int(param[2]);

    // Validate parameters
    
    if(anna_buffer_ensure_capacity(anna_as_obj(param[1]), native_param_count)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    }
    

    // Call the function
    anna_entry_t *result = anna_from_int(write(native_param_fd, native_param_buffer, native_param_count));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_close, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = (close(native_param_fd))?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_dev_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_dev);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_ino_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_ino);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_mode_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_mode);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_nlink_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_nlink);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_uid_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_uid);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_gid_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_gid);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_rdev_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_rdev);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_size_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_size);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_blksize_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_blksize);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_blocks_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_blocks);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_atime_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_atime);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_mtime_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_mtime);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_ctime_getter, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_ctime);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_init, 1)
{
    struct stat *data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct stat));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_io_stat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));
    struct stat *native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = (stat(native_param_path, native_param_buf))?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lstat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));
    struct stat *native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = (lstat(native_param_path, native_param_buf))?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fstat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    struct stat *native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = (fstat(native_param_fd, native_param_buf))?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_mkdir, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = (mkdir(native_param_path, native_param_mode))?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_getcwd, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    unsigned char *native_param_buf = anna_buffer_get_payload(anna_as_obj(param[0]));
    int native_param_size = anna_as_int(param[1]);

    // Validate parameters
    if(anna_buffer_ensure_capacity(anna_as_obj(param[0]), native_param_size)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buf = anna_buffer_get_payload(anna_as_obj(param[0]));
    }
    

    // Call the function
    anna_entry_t *result = (getcwd(native_param_buf, native_param_size))?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chdir, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = (chdir(native_param_path))?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chroot, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = (chroot(native_param_path))?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchdir, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = (fchdir(native_param_fd))?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_type_getter, 1)
{
    struct flock *data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_type);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_whence_getter, 1)
{
    struct flock *data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_whence);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_start_getter, 1)
{
    struct flock *data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_start);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_len_getter, 1)
{
    struct flock *data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_len);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_pid_getter, 1)
{
    struct flock *data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_pid);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_init, 1)
{
    struct flock *data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct flock));
    return param[0];
}
const static anna_type_data_t anna_fcntl_mode_type_data[] = 
{
};

void anna_fcntl_mode_create(anna_stack_template_t *stack);
void anna_fcntl_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_fcntl_mode_type_data, stack);        
}
void anna_fcntl_mode_load(anna_stack_template_t *stack);
void anna_fcntl_mode_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"dupFd", F_DUPFD, 0);

     anna_type_data_register(anna_fcntl_mode_type_data, stack);
}
const static anna_type_data_t anna_seek_mode_type_data[] = 
{
};

void anna_seek_mode_create(anna_stack_template_t *stack);
void anna_seek_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_seek_mode_type_data, stack);        
}
void anna_seek_mode_load(anna_stack_template_t *stack);
void anna_seek_mode_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"set", SEEK_SET, 0);
    anna_module_const_int(stack, L"cur", SEEK_CUR, 0);
    anna_module_const_int(stack, L"end", SEEK_END, 0);

     anna_type_data_register(anna_seek_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_io_fcntl, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(fcntl(native_param_fd, native_param_cmd));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fcntl_int, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);
    int native_param_arg = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(fcntl(native_param_fd, native_param_cmd, native_param_arg));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fcntl_f_lock, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);
    struct flock *native_param_arg = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(fcntl(native_param_fd, native_param_cmd, native_param_arg));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_dup, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(dup(native_param_fd));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_dup2, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_oldfd = anna_as_int(param[0]);
    int native_param_newfd = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(dup2(native_param_oldfd, native_param_newfd));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chown, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(chown(native_param_path, native_param_owner, native_param_group));
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchown, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(fchown(native_param_fd, native_param_owner, native_param_group));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lchown, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(lchown(native_param_path, native_param_owner, native_param_group));
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chmod, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(chmod(native_param_path, native_param_mode));
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchmod, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(fchmod(native_param_fd, native_param_mode));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_symlink, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_oldpath = anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(symlink(native_param_oldpath, native_param_newpath));
    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_link, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_oldpath = anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(link(native_param_oldpath, native_param_newpath));
    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_unlink, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(unlink(native_param_path));
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_rmdir, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(rmdir(native_param_path));
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_rename, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_oldpath = anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(rename(native_param_oldpath, native_param_newpath));
    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_pipe, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    if(anna_list_ensure_capacity(anna_as_obj(param[0]), 2))
    {
        return null_entry;
    }
    size_t native_param_fd_count = anna_list_get_count(anna_as_obj(param[0]));
    int* native_param_fd = malloc(sizeof(int) * native_param_fd_count);
    if(!native_param_fd){ return null_entry; }
    int native_param_fd_idx;
    for(native_param_fd_idx=0; native_param_fd_idx < native_param_fd_count; native_param_fd_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[0]), native_param_fd_idx);
        if(tmp == null_entry)
        {
            native_param_fd[native_param_fd_idx] = 0;
        }
        else
        {
            int native_param_fd_val = anna_as_int(tmp);
            native_param_fd[native_param_fd_idx] = native_param_fd_val;
        }
    }


    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(pipe(native_param_fd));
    // Perform cleanup
    
    for(native_param_fd_idx=0; native_param_fd_idx < native_param_fd_count; native_param_fd_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_fd[native_param_fd_idx]);
        anna_list_set(anna_as_obj(param[0]), native_param_fd_idx, tmp);
        
    }
    free(native_param_fd);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lseek, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    uint64_t native_param_offset = anna_as_int(param[1]);
    int native_param_whence = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_uint64(lseek(native_param_fd, native_param_offset, native_param_whence));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_sync, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    sync(); anna_entry_t *result = null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fsync, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(fsync(native_param_fd));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fdatasync, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(fdatasync(native_param_fd));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_umask, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_mask = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(umask(native_param_mask));
    // Perform cleanup

    // Return result
    return result;
}

#define ANNA_FD_CLR(set, fd) FD_CLR(fd, set)
#define ANNA_FD_ISSET(set, fd) FD_ISSET(fd, set)
#define ANNA_FD_SET(set, fd) FD_SET(fd, set)

ANNA_VM_NATIVE(unix_i_clear, 2)
{
    // Validate parameters
if(param[0] == null_entry){return null_entry;}    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    ANNA_FD_CLR(native_param_this, native_param_fd); anna_entry_t *result = null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_set_check, 2)
{
    // Validate parameters
if(param[0] == null_entry){return null_entry;}    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(ANNA_FD_ISSET(native_param_this, native_param_fd));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_set, 2)
{
    // Validate parameters
if(param[0] == null_entry){return null_entry;}    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    ANNA_FD_SET(native_param_this, native_param_fd); anna_entry_t *result = null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_zero, 1)
{
    // Validate parameters
if(param[0] == null_entry){return null_entry;}
    // Mangle input parameters
    fd_set *native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    FD_ZERO(native_param_this); anna_entry_t *result = null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_init, 1)
{
    fd_set *data = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(fd_set));
    return param[0];
}

void anna_io_create(anna_stack_template_t *stack);
void anna_io_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_io_type_data, stack);        
}
void anna_io_load(anna_stack_template_t *stack);
void anna_io_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"openMode", anna_open_mode_create, anna_open_mode_load},
            { L"statMode", anna_stat_mode_create, anna_stat_mode_load},
            { L"fcntlMode", anna_fcntl_mode_create, anna_fcntl_mode_load},
            { L"seekMode", anna_seek_mode_create, anna_seek_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_io_open_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_open_argn[] = {L"name", L"flags", L"mode"};
    anna_module_function(stack, L"open", 0, &unix_i_io_open, int_type, 3, unix_i_io_open_argv, unix_i_io_open_argn, L"Open a file descriptor. Equivalent to the C open function.");

    anna_type_t *unix_i_io_creat_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_creat_argn[] = {L"name", L"mode"};
    anna_module_function(stack, L"creat", 0, &unix_i_io_creat, int_type, 2, unix_i_io_creat_argv, unix_i_io_creat_argn, L"Open a file descriptor. Equivalent to the C creat function.");

    anna_type_t *unix_i_io_read_argv[] = {int_type, buffer_type, int_type};
    wchar_t *unix_i_io_read_argn[] = {L"fd", L"buffer", L"count"};
    anna_module_function(stack, L"read", 0, &unix_i_io_read, int_type, 3, unix_i_io_read_argv, unix_i_io_read_argn, L"Read from a file descriptor. Equivalent to the C read function.");

    anna_type_t *unix_i_io_write_argv[] = {int_type, buffer_type, int_type};
    wchar_t *unix_i_io_write_argn[] = {L"fd", L"buffer", L"count"};
    anna_module_function(stack, L"write", 0, &unix_i_io_write, int_type, 3, unix_i_io_write_argv, unix_i_io_write_argn, L"Write to a file descriptor. Equivalent to the C write function.");

    anna_type_t *unix_i_io_close_argv[] = {int_type};
    wchar_t *unix_i_io_close_argn[] = {L"fd"};
    anna_module_function(stack, L"close", 0, &unix_i_io_close, object_type, 1, unix_i_io_close_argv, unix_i_io_close_argn, L"Close a file descriptor. Equivalent to the C close function.");

    anna_member_create_blob(unix_stat_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct stat));

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"dev"),
        int_type, unix_i_stat_dev_getter, 0, L"ID of device containing file");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"ino"),
        int_type, unix_i_stat_ino_getter, 0, L"Inode number");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"mode"),
        int_type, unix_i_stat_mode_getter, 0, L"File protection mask");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"nlink"),
        int_type, unix_i_stat_nlink_getter, 0, L"Number of hard links.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"uid"),
        int_type, unix_i_stat_uid_getter, 0, L"User ID of owner.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"gid"),
        int_type, unix_i_stat_gid_getter, 0, L"Group ID of owner.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"rdev"),
        int_type, unix_i_stat_rdev_getter, 0, L"Device ID.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"size"),
        int_type, unix_i_stat_size_getter, 0, L"Total size in bytes.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"blksize"),
        int_type, unix_i_stat_blksize_getter, 0, L"Block size for file system IO.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"blocks"),
        int_type, unix_i_stat_blocks_getter, 0, L"Number of 512 byte blocks allocated.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"atime"),
        int_type, unix_i_stat_atime_getter, 0, L"Time of latest acccess.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"mtime"),
        int_type, unix_i_stat_mtime_getter, 0, L"Time of latest modification.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"ctime"),
        int_type, unix_i_stat_ctime_getter, 0, L"Time of latest change.");
    anna_member_create_native_method(
	unix_stat_type, anna_mid_get(L"__init__"), 0,
	&unix_i_stat_init, object_type, 1, &unix_stat_type, this_argn, 0, 0);    

    anna_type_t *unix_i_io_stat_argv[] = {string_type, unix_stat_type};
    wchar_t *unix_i_io_stat_argn[] = {L"path", L"buf"};
    anna_module_function(stack, L"stat", 0, &unix_i_io_stat, object_type, 2, unix_i_io_stat_argv, unix_i_io_stat_argn, L"Check the status of file with the specified path. Equivalanet to the C stat function.");

    anna_type_t *unix_i_io_lstat_argv[] = {string_type, unix_stat_type};
    wchar_t *unix_i_io_lstat_argn[] = {L"path", L"buf"};
    anna_module_function(stack, L"lstat", 0, &unix_i_io_lstat, object_type, 2, unix_i_io_lstat_argv, unix_i_io_lstat_argn, L"Check the status of file with the specified path, without following symlinks. Equivalanet to the C lstat function.");

    anna_type_t *unix_i_io_fstat_argv[] = {int_type, unix_stat_type};
    wchar_t *unix_i_io_fstat_argn[] = {L"fd", L"buf"};
    anna_module_function(stack, L"fstat", 0, &unix_i_io_fstat, object_type, 2, unix_i_io_fstat_argv, unix_i_io_fstat_argn, L"Check the status of file with the specified file descriptor. Equivalanet to the C fstat function.");

    anna_type_t *unix_i_io_mkdir_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_mkdir_argn[] = {L"path", L"mode"};
    anna_module_function(stack, L"mkdir", 0, &unix_i_io_mkdir, object_type, 2, unix_i_io_mkdir_argv, unix_i_io_mkdir_argn, L"Create a new driectory with the specified path. Equivalanet to the C mkdir function.");
    anna_module_const_int(stack, L"standardInput", 0, L"File descriptor for standard input.");
    anna_module_const_int(stack, L"standardOutput", 1, L"File descriptor for standard output.");
    anna_module_const_int(stack, L"standardError", 2, L"File descriptor for error output");

    anna_type_t *unix_i_io_getcwd_argv[] = {buffer_type, int_type};
    wchar_t *unix_i_io_getcwd_argn[] = {L"buf", L"size"};
    anna_module_function(stack, L"getcwd", 0, &unix_i_io_getcwd, object_type, 2, unix_i_io_getcwd_argv, unix_i_io_getcwd_argn, 0);

    anna_type_t *unix_i_io_chdir_argv[] = {string_type};
    wchar_t *unix_i_io_chdir_argn[] = {L"path"};
    anna_module_function(stack, L"chdir", 0, &unix_i_io_chdir, object_type, 1, unix_i_io_chdir_argv, unix_i_io_chdir_argn, 0);

    anna_type_t *unix_i_io_chroot_argv[] = {string_type};
    wchar_t *unix_i_io_chroot_argn[] = {L"path"};
    anna_module_function(stack, L"chroot", 0, &unix_i_io_chroot, object_type, 1, unix_i_io_chroot_argv, unix_i_io_chroot_argn, 0);

    anna_type_t *unix_i_io_fchdir_argv[] = {int_type};
    wchar_t *unix_i_io_fchdir_argn[] = {L"fd"};
    anna_module_function(stack, L"fchdir", 0, &unix_i_io_fchdir, object_type, 1, unix_i_io_fchdir_argv, unix_i_io_fchdir_argn, 0);

    anna_member_create_blob(unix_f_lock_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct flock));

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"type"),
        int_type, unix_i_f_lock_type_getter, 0, L"Type of lock: F_RDLCK, F_WRLCK, F_UNLCK.");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"whence"),
        int_type, unix_i_f_lock_whence_getter, 0, L"How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END.");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"start"),
        int_type, unix_i_f_lock_start_getter, 0, L"Starting offset for lock");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"len"),
        int_type, unix_i_f_lock_len_getter, 0, L"Number of bytes to lock");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"pid"),
        int_type, unix_i_f_lock_pid_getter, 0, L"PID of process blocking our lock (F_GETLK only)");
    anna_member_create_native_method(
	unix_f_lock_type, anna_mid_get(L"__init__"), 0,
	&unix_i_f_lock_init, object_type, 1, &unix_f_lock_type, this_argn, 0, 0);    

    anna_type_t *unix_i_io_fcntl_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_fcntl_argn[] = {L"fd", L"cmd"};
    anna_module_function(stack, L"fcntl", 0, &unix_i_io_fcntl, int_type, 2, unix_i_io_fcntl_argv, unix_i_io_fcntl_argn, 0);

    anna_type_t *unix_i_io_fcntl_int_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_fcntl_int_argn[] = {L"fd", L"cmd", L"arg"};
    anna_module_function(stack, L"fcntlInt", 0, &unix_i_io_fcntl_int, int_type, 3, unix_i_io_fcntl_int_argv, unix_i_io_fcntl_int_argn, 0);

    anna_type_t *unix_i_io_fcntl_f_lock_argv[] = {int_type, int_type, unix_f_lock_type};
    wchar_t *unix_i_io_fcntl_f_lock_argn[] = {L"fd", L"cmd", L"arg"};
    anna_module_function(stack, L"fcntlFLock", 0, &unix_i_io_fcntl_f_lock, int_type, 3, unix_i_io_fcntl_f_lock_argv, unix_i_io_fcntl_f_lock_argn, 0);

    anna_type_t *unix_i_io_dup_argv[] = {int_type};
    wchar_t *unix_i_io_dup_argn[] = {L"fd"};
    anna_module_function(stack, L"dup", 0, &unix_i_io_dup, int_type, 1, unix_i_io_dup_argv, unix_i_io_dup_argn, 0);

    anna_type_t *unix_i_io_dup2_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_dup2_argn[] = {L"oldfd", L"newfd"};
    anna_module_function(stack, L"dup2", 0, &unix_i_io_dup2, int_type, 2, unix_i_io_dup2_argv, unix_i_io_dup2_argn, 0);

    anna_type_t *unix_i_io_chown_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_chown_argn[] = {L"path", L"owner", L"group"};
    anna_module_function(stack, L"chown", 0, &unix_i_io_chown, int_type, 3, unix_i_io_chown_argv, unix_i_io_chown_argn, 0);

    anna_type_t *unix_i_io_fchown_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_fchown_argn[] = {L"fd", L"owner", L"group"};
    anna_module_function(stack, L"fchown", 0, &unix_i_io_fchown, int_type, 3, unix_i_io_fchown_argv, unix_i_io_fchown_argn, 0);

    anna_type_t *unix_i_io_lchown_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_lchown_argn[] = {L"path", L"owner", L"group"};
    anna_module_function(stack, L"lchown", 0, &unix_i_io_lchown, int_type, 3, unix_i_io_lchown_argv, unix_i_io_lchown_argn, 0);

    anna_type_t *unix_i_io_chmod_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_chmod_argn[] = {L"path", L"mode"};
    anna_module_function(stack, L"chmod", 0, &unix_i_io_chmod, int_type, 2, unix_i_io_chmod_argv, unix_i_io_chmod_argn, 0);

    anna_type_t *unix_i_io_fchmod_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_fchmod_argn[] = {L"fd", L"mode"};
    anna_module_function(stack, L"fchmod", 0, &unix_i_io_fchmod, int_type, 2, unix_i_io_fchmod_argv, unix_i_io_fchmod_argn, 0);

    anna_type_t *unix_i_io_symlink_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_symlink_argn[] = {L"oldpath", L"newpath"};
    anna_module_function(stack, L"symlink", 0, &unix_i_io_symlink, int_type, 2, unix_i_io_symlink_argv, unix_i_io_symlink_argn, 0);

    anna_type_t *unix_i_io_link_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_link_argn[] = {L"oldpath", L"newpath"};
    anna_module_function(stack, L"link", 0, &unix_i_io_link, int_type, 2, unix_i_io_link_argv, unix_i_io_link_argn, 0);

    anna_type_t *unix_i_io_unlink_argv[] = {string_type};
    wchar_t *unix_i_io_unlink_argn[] = {L"path"};
    anna_module_function(stack, L"unlink", 0, &unix_i_io_unlink, int_type, 1, unix_i_io_unlink_argv, unix_i_io_unlink_argn, 0);

    anna_type_t *unix_i_io_rmdir_argv[] = {string_type};
    wchar_t *unix_i_io_rmdir_argn[] = {L"path"};
    anna_module_function(stack, L"rmdir", 0, &unix_i_io_rmdir, int_type, 1, unix_i_io_rmdir_argv, unix_i_io_rmdir_argn, 0);

    anna_type_t *unix_i_io_rename_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_rename_argn[] = {L"oldpath", L"newpath"};
    anna_module_function(stack, L"rename", 0, &unix_i_io_rename, int_type, 2, unix_i_io_rename_argv, unix_i_io_rename_argn, 0);

    anna_type_t *unix_i_io_pipe_argv[] = {anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_io_pipe_argn[] = {L"fd"};
    anna_module_function(stack, L"pipe", 0, &unix_i_io_pipe, int_type, 1, unix_i_io_pipe_argv, unix_i_io_pipe_argn, 0);

    anna_type_t *unix_i_io_lseek_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_lseek_argn[] = {L"fd", L"offset", L"whence"};
    anna_module_function(stack, L"lseek", 0, &unix_i_io_lseek, int_type, 3, unix_i_io_lseek_argv, unix_i_io_lseek_argn, 0);

    anna_type_t *unix_i_io_sync_argv[] = {};
    wchar_t *unix_i_io_sync_argn[] = {};
    anna_module_function(stack, L"sync", 0, &unix_i_io_sync, object_type, 0, unix_i_io_sync_argv, unix_i_io_sync_argn, 0);

    anna_type_t *unix_i_io_fsync_argv[] = {int_type};
    wchar_t *unix_i_io_fsync_argn[] = {L"fd"};
    anna_module_function(stack, L"fsync", 0, &unix_i_io_fsync, int_type, 1, unix_i_io_fsync_argv, unix_i_io_fsync_argn, 0);

    anna_type_t *unix_i_io_fdatasync_argv[] = {int_type};
    wchar_t *unix_i_io_fdatasync_argn[] = {L"fd"};
    anna_module_function(stack, L"fdatasync", 0, &unix_i_io_fdatasync, int_type, 1, unix_i_io_fdatasync_argv, unix_i_io_fdatasync_argn, 0);

    anna_type_t *unix_i_io_umask_argv[] = {int_type};
    wchar_t *unix_i_io_umask_argn[] = {L"mask"};
    anna_module_function(stack, L"umask", 0, &unix_i_io_umask, int_type, 1, unix_i_io_umask_argv, unix_i_io_umask_argn, 0);

    anna_member_create_blob(unix_fd_set_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(fd_set));

    anna_type_t *unix_i_clear_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_clear_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"clear"), 0, 
        &unix_i_clear, object_type, 2, unix_i_clear_argv, unix_i_clear_argn, 0, 0);

    anna_type_t *unix_i_set_check_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_set_check_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"set?"), 0, 
        &unix_i_set_check, int_type, 2, unix_i_set_check_argv, unix_i_set_check_argn, 0, 0);

    anna_type_t *unix_i_set_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_set_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"set"), 0, 
        &unix_i_set, object_type, 2, unix_i_set_argv, unix_i_set_argn, 0, 0);

    anna_type_t *unix_i_zero_argv[] = {unix_fd_set_type};
    wchar_t *unix_i_zero_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"zero"), 0, 
        &unix_i_zero, object_type, 1, unix_i_zero_argv, unix_i_zero_argn, 0, 0);
    anna_member_create_native_method(
	unix_fd_set_type, anna_mid_get(L"__init__"), 0,
	&unix_i_fd_set_init, object_type, 1, &unix_fd_set_type, this_argn, 0, 0);    

     anna_type_data_register(anna_io_type_data, stack);
}
const static anna_type_data_t anna_proc_type_data[] = 
{
};
const static anna_type_data_t anna_signal_type_data[] = 
{
};

void anna_signal_create(anna_stack_template_t *stack);
void anna_signal_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_signal_type_data, stack);        
}
void anna_signal_load(anna_stack_template_t *stack);
void anna_signal_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"hup", SIGHUP, L"The HUP signal");
    anna_module_const_int(stack, L"int", SIGINT, L"The INT signal");
    anna_module_const_int(stack, L"quit", SIGQUIT, L"The QUIT signal");
    anna_module_const_int(stack, L"ill", SIGILL, L"The ILL signal");
    anna_module_const_int(stack, L"abrt", SIGABRT, L"The ABRT signal");
    anna_module_const_int(stack, L"fpe", SIGFPE, L"The FPE signal");
    anna_module_const_int(stack, L"kill", SIGKILL, L"The KILL signal");
    anna_module_const_int(stack, L"segv", SIGSEGV, L"The SEGV signal");
    anna_module_const_int(stack, L"pipe", SIGPIPE, L"The PIPE signal");
    anna_module_const_int(stack, L"alrm", SIGALRM, L"The ALRM signal");
    anna_module_const_int(stack, L"term", SIGTERM, L"The TERM signal");
    anna_module_const_int(stack, L"usr1", SIGUSR1, L"The USR1 signal");
    anna_module_const_int(stack, L"usr2", SIGUSR2, L"The USR2 signal");
    anna_module_const_int(stack, L"chld", SIGCHLD, L"The CHLD signal");
    anna_module_const_int(stack, L"cont", SIGCONT, L"The CONT signal");
    anna_module_const_int(stack, L"stop", SIGSTOP, L"The STOP signal");
    anna_module_const_int(stack, L"tstp", SIGTSTP, L"The TSTP signal");
    anna_module_const_int(stack, L"ttin", SIGTTIN, L"The TTIN signal");
    anna_module_const_int(stack, L"ttou", SIGTTOU, L"The TTOU signal");
    anna_module_const_int(stack, L"bus", SIGBUS, L"The BUS signal");
    anna_module_const_int(stack, L"poll", SIGPOLL, L"The POLL signal");
    anna_module_const_int(stack, L"prof", SIGPROF, L"The PROF signal");
    anna_module_const_int(stack, L"sys", SIGSYS, L"The SYS signal");
    anna_module_const_int(stack, L"trap", SIGTRAP, L"The TRAP signal");
    anna_module_const_int(stack, L"urg", SIGURG, L"The URG signal");
    anna_module_const_int(stack, L"vtalrm", SIGVTALRM, L"The VTALRM signal");
    anna_module_const_int(stack, L"xcpu", SIGXCPU, L"The XCPU signal");
    anna_module_const_int(stack, L"xfsz", SIGXFSZ, L"The XFSZ signal");
    anna_module_const_int(stack, L"iot", SIGIOT, L"The IOT signal");
    anna_module_const_int(stack, L"stkflt", SIGSTKFLT, L"The STKFLT signal");
    anna_module_const_int(stack, L"io", SIGIO, L"The IO signal");
    anna_module_const_int(stack, L"cld", SIGCLD, L"The CLD signal");
    anna_module_const_int(stack, L"pwr", SIGPWR, L"The PWR signal");
    anna_module_const_int(stack, L"winch", SIGWINCH, L"The WINCH signal");
    anna_module_const_int(stack, L"unused", SIGUNUSED, L"The UNUSED signal");

     anna_type_data_register(anna_signal_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_proc_exec, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_filename = anna_string_payload_narrow(anna_as_obj(param[0]));
    size_t native_param_argv_count = anna_list_get_count(anna_as_obj(param[1]));
    char ** native_param_argv = malloc(sizeof(char *) * native_param_argv_count);
    if(!native_param_argv){ return null_entry; }
    int native_param_argv_idx;
    for(native_param_argv_idx=0; native_param_argv_idx < native_param_argv_count; native_param_argv_idx++)
    {
        char *native_param_argv_val = anna_string_payload_narrow(anna_as_obj(anna_list_get(anna_as_obj(param[1]), native_param_argv_idx)));
        native_param_argv[native_param_argv_idx] = native_param_argv_val;
    }

    size_t native_param_envp_count = anna_list_get_count(anna_as_obj(param[2]));
    char ** native_param_envp = malloc(sizeof(char *) * native_param_envp_count);
    if(!native_param_envp){ return null_entry; }
    int native_param_envp_idx;
    for(native_param_envp_idx=0; native_param_envp_idx < native_param_envp_count; native_param_envp_idx++)
    {
        char *native_param_envp_val = anna_string_payload_narrow(anna_as_obj(anna_list_get(anna_as_obj(param[2]), native_param_envp_idx)));
        native_param_envp[native_param_envp_idx] = native_param_envp_val;
    }


    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(execve(native_param_filename, native_param_argv, native_param_envp));
    // Perform cleanup
    free(native_param_filename);
    
    for(native_param_argv_idx=0; native_param_argv_idx < native_param_argv_count; native_param_argv_idx++)
    {
        free(native_param_argv[native_param_argv_idx]);
    }
    free(native_param_argv);

    
    for(native_param_envp_idx=0; native_param_envp_idx < native_param_envp_count; native_param_envp_idx++)
    {
        free(native_param_envp[native_param_envp_idx]);
    }
    free(native_param_envp);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_exit, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_status = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    exit(native_param_status); anna_entry_t *result = null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_fork, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(fork());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_kill, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    int native_param_sig = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(kill(native_param_pid, native_param_sig));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getsid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(getsid(native_param_pid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_setsid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(setsid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getpid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(getpid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getppid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(getppid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_wait, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    if(anna_list_ensure_capacity(anna_as_obj(param[0]), 1))
    {
        return null_entry;
    }
    size_t native_param_status_count = anna_list_get_count(anna_as_obj(param[0]));
    int* native_param_status = malloc(sizeof(int) * native_param_status_count);
    if(!native_param_status){ return null_entry; }
    int native_param_status_idx;
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[0]), native_param_status_idx);
        if(tmp == null_entry)
        {
            native_param_status[native_param_status_idx] = 0;
        }
        else
        {
            int native_param_status_val = anna_as_int(tmp);
            native_param_status[native_param_status_idx] = native_param_status_val;
        }
    }


    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(wait(native_param_status));
    // Perform cleanup
    
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_status[native_param_status_idx]);
        anna_list_set(anna_as_obj(param[0]), native_param_status_idx, tmp);
        
    }
    free(native_param_status);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_waitpid, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), 1))
    {
        return null_entry;
    }
    size_t native_param_status_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_status = malloc(sizeof(int) * native_param_status_count);
    if(!native_param_status){ return null_entry; }
    int native_param_status_idx;
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_status_idx);
        if(tmp == null_entry)
        {
            native_param_status[native_param_status_idx] = 0;
        }
        else
        {
            int native_param_status_val = anna_as_int(tmp);
            native_param_status[native_param_status_idx] = native_param_status_val;
        }
    }

    int native_param_options = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(waitpid(native_param_pid, native_param_status, native_param_options));
    // Perform cleanup
    
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_status[native_param_status_idx]);
        anna_list_set(anna_as_obj(param[1]), native_param_status_idx, tmp);
        
    }
    free(native_param_status);


    // Return result
    return result;
}

void anna_proc_create(anna_stack_template_t *stack);
void anna_proc_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_proc_type_data, stack);        
}
void anna_proc_load(anna_stack_template_t *stack);
void anna_proc_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"signal", anna_signal_create, anna_signal_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_proc_exec_argv[] = {string_type, anna_list_type_get_any(string_type), anna_list_type_get_any(string_type)};
    wchar_t *unix_i_proc_exec_argn[] = {L"filename", L"argv", L"envp"};
    anna_module_function(stack, L"exec", 0, &unix_i_proc_exec, int_type, 3, unix_i_proc_exec_argv, unix_i_proc_exec_argn, 0);

    anna_type_t *unix_i_proc_exit_argv[] = {int_type};
    wchar_t *unix_i_proc_exit_argn[] = {L"status"};
    anna_module_function(stack, L"exit", 0, &unix_i_proc_exit, object_type, 1, unix_i_proc_exit_argv, unix_i_proc_exit_argn, 0);

    anna_type_t *unix_i_proc_fork_argv[] = {};
    wchar_t *unix_i_proc_fork_argn[] = {};
    anna_module_function(stack, L"fork", 0, &unix_i_proc_fork, int_type, 0, unix_i_proc_fork_argv, unix_i_proc_fork_argn, 0);

    anna_type_t *unix_i_proc_kill_argv[] = {int_type, int_type};
    wchar_t *unix_i_proc_kill_argn[] = {L"pid", L"sig"};
    anna_module_function(stack, L"kill", 0, &unix_i_proc_kill, int_type, 2, unix_i_proc_kill_argv, unix_i_proc_kill_argn, 0);

    anna_type_t *unix_i_proc_getsid_argv[] = {int_type};
    wchar_t *unix_i_proc_getsid_argn[] = {L"pid"};
    anna_module_function(stack, L"getsid", 0, &unix_i_proc_getsid, int_type, 1, unix_i_proc_getsid_argv, unix_i_proc_getsid_argn, 0);

    anna_type_t *unix_i_proc_setsid_argv[] = {};
    wchar_t *unix_i_proc_setsid_argn[] = {};
    anna_module_function(stack, L"setsid", 0, &unix_i_proc_setsid, int_type, 0, unix_i_proc_setsid_argv, unix_i_proc_setsid_argn, 0);

    anna_type_t *unix_i_proc_getpid_argv[] = {};
    wchar_t *unix_i_proc_getpid_argn[] = {};
    anna_module_function(stack, L"getpid", 0, &unix_i_proc_getpid, int_type, 0, unix_i_proc_getpid_argv, unix_i_proc_getpid_argn, 0);

    anna_type_t *unix_i_proc_getppid_argv[] = {};
    wchar_t *unix_i_proc_getppid_argn[] = {};
    anna_module_function(stack, L"getppid", 0, &unix_i_proc_getppid, int_type, 0, unix_i_proc_getppid_argv, unix_i_proc_getppid_argn, 0);

    anna_type_t *unix_i_proc_wait_argv[] = {anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_proc_wait_argn[] = {L"status"};
    anna_module_function(stack, L"wait", 0, &unix_i_proc_wait, int_type, 1, unix_i_proc_wait_argv, unix_i_proc_wait_argn, 0);

    anna_type_t *unix_i_proc_waitpid_argv[] = {int_type, anna_list_type_get_mutable(int_type), int_type};
    wchar_t *unix_i_proc_waitpid_argn[] = {L"pid", L"status", L"options"};
    anna_module_function(stack, L"waitpid", 0, &unix_i_proc_waitpid, int_type, 3, unix_i_proc_waitpid_argv, unix_i_proc_waitpid_argn, 0);

     anna_type_data_register(anna_proc_type_data, stack);
}
const static anna_type_data_t anna_user_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_user_getuid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(getuid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_geteuid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(geteuid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getgid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(getgid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getegid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(getegid());
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setuid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(setuid(native_param_uid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_seteuid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(seteuid(native_param_uid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setegid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(setegid(native_param_uid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setgid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(setgid(native_param_uid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setpgid, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    int native_param_pgid = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(setpgid(native_param_pid, native_param_pgid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getpgid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(getpgid(native_param_pid));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getgroups, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_size = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), native_param_size))
    {
        return null_entry;
    }
    size_t native_param_list_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_list = malloc(sizeof(int) * native_param_list_count);
    if(!native_param_list){ return null_entry; }
    int native_param_list_idx;
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_list_idx);
        if(tmp == null_entry)
        {
            native_param_list[native_param_list_idx] = 0;
        }
        else
        {
            int native_param_list_val = anna_as_int(tmp);
            native_param_list[native_param_list_idx] = native_param_list_val;
        }
    }


    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(getgroups(native_param_size, native_param_list));
    // Perform cleanup
    
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_list[native_param_list_idx]);
        anna_list_set(anna_as_obj(param[1]), native_param_list_idx, tmp);
        
    }
    free(native_param_list);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setgroups, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_size = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), native_param_size))
    {
        return null_entry;
    }
    size_t native_param_list_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_list = malloc(sizeof(int) * native_param_list_count);
    if(!native_param_list){ return null_entry; }
    int native_param_list_idx;
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_list_idx);
        if(tmp == null_entry)
        {
            native_param_list[native_param_list_idx] = 0;
        }
        else
        {
            int native_param_list_val = anna_as_int(tmp);
            native_param_list[native_param_list_idx] = native_param_list_val;
        }
    }


    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(setgroups(native_param_size, native_param_list));
    // Perform cleanup
    
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_list[native_param_list_idx]);
        anna_list_set(anna_as_obj(param[1]), native_param_list_idx, tmp);
        
    }
    free(native_param_list);


    // Return result
    return result;
}

void anna_user_create(anna_stack_template_t *stack);
void anna_user_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_user_type_data, stack);        
}
void anna_user_load(anna_stack_template_t *stack);
void anna_user_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_user_getuid_argv[] = {};
    wchar_t *unix_i_user_getuid_argn[] = {};
    anna_module_function(stack, L"getuid", 0, &unix_i_user_getuid, int_type, 0, unix_i_user_getuid_argv, unix_i_user_getuid_argn, 0);

    anna_type_t *unix_i_user_geteuid_argv[] = {};
    wchar_t *unix_i_user_geteuid_argn[] = {};
    anna_module_function(stack, L"geteuid", 0, &unix_i_user_geteuid, int_type, 0, unix_i_user_geteuid_argv, unix_i_user_geteuid_argn, 0);

    anna_type_t *unix_i_user_getgid_argv[] = {};
    wchar_t *unix_i_user_getgid_argn[] = {};
    anna_module_function(stack, L"getgid", 0, &unix_i_user_getgid, int_type, 0, unix_i_user_getgid_argv, unix_i_user_getgid_argn, 0);

    anna_type_t *unix_i_user_getegid_argv[] = {};
    wchar_t *unix_i_user_getegid_argn[] = {};
    anna_module_function(stack, L"getegid", 0, &unix_i_user_getegid, int_type, 0, unix_i_user_getegid_argv, unix_i_user_getegid_argn, 0);

    anna_type_t *unix_i_user_setuid_argv[] = {int_type};
    wchar_t *unix_i_user_setuid_argn[] = {L"uid"};
    anna_module_function(stack, L"setuid", 0, &unix_i_user_setuid, int_type, 1, unix_i_user_setuid_argv, unix_i_user_setuid_argn, 0);

    anna_type_t *unix_i_user_seteuid_argv[] = {int_type};
    wchar_t *unix_i_user_seteuid_argn[] = {L"uid"};
    anna_module_function(stack, L"seteuid", 0, &unix_i_user_seteuid, int_type, 1, unix_i_user_seteuid_argv, unix_i_user_seteuid_argn, 0);

    anna_type_t *unix_i_user_setegid_argv[] = {int_type};
    wchar_t *unix_i_user_setegid_argn[] = {L"uid"};
    anna_module_function(stack, L"setegid", 0, &unix_i_user_setegid, int_type, 1, unix_i_user_setegid_argv, unix_i_user_setegid_argn, 0);

    anna_type_t *unix_i_user_setgid_argv[] = {int_type};
    wchar_t *unix_i_user_setgid_argn[] = {L"uid"};
    anna_module_function(stack, L"setgid", 0, &unix_i_user_setgid, int_type, 1, unix_i_user_setgid_argv, unix_i_user_setgid_argn, 0);

    anna_type_t *unix_i_user_setpgid_argv[] = {int_type, int_type};
    wchar_t *unix_i_user_setpgid_argn[] = {L"pid", L"pgid"};
    anna_module_function(stack, L"setpgid", 0, &unix_i_user_setpgid, int_type, 2, unix_i_user_setpgid_argv, unix_i_user_setpgid_argn, 0);

    anna_type_t *unix_i_user_getpgid_argv[] = {int_type};
    wchar_t *unix_i_user_getpgid_argn[] = {L"pid"};
    anna_module_function(stack, L"getpgid", 0, &unix_i_user_getpgid, int_type, 1, unix_i_user_getpgid_argv, unix_i_user_getpgid_argn, 0);

    anna_type_t *unix_i_user_getgroups_argv[] = {int_type, anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_user_getgroups_argn[] = {L"size", L"list"};
    anna_module_function(stack, L"getgroups", 0, &unix_i_user_getgroups, int_type, 2, unix_i_user_getgroups_argv, unix_i_user_getgroups_argn, 0);

    anna_type_t *unix_i_user_setgroups_argv[] = {int_type, anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_user_setgroups_argn[] = {L"size", L"list"};
    anna_module_function(stack, L"setgroups", 0, &unix_i_user_setgroups, int_type, 2, unix_i_user_setgroups_argv, unix_i_user_setgroups_argn, 0);

     anna_type_data_register(anna_user_type_data, stack);
}
const static anna_type_data_t anna_r_limit_type_data[] = 
{
    { &unix_r_limit_type, L"RLimit" },
};
const static anna_type_data_t anna_r_limit_mode_type_data[] = 
{
};

void anna_r_limit_mode_create(anna_stack_template_t *stack);
void anna_r_limit_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_r_limit_mode_type_data, stack);        
}
void anna_r_limit_mode_load(anna_stack_template_t *stack);
void anna_r_limit_mode_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"as", RLIMIT_AS, L"The AS limit");
    anna_module_const_int(stack, L"core", RLIMIT_CORE, L"The CORE limit");
    anna_module_const_int(stack, L"cpu", RLIMIT_CPU, L"The CPU limit");
    anna_module_const_int(stack, L"data", RLIMIT_DATA, L"The DATA limit");
    anna_module_const_int(stack, L"fsize", RLIMIT_FSIZE, L"The FSIZE limit");
    anna_module_const_int(stack, L"memlock", RLIMIT_MEMLOCK, L"The MEMLOCK limit");
    anna_module_const_int(stack, L"msgqueue", RLIMIT_MSGQUEUE, L"The MSGQUEUE limit");
    anna_module_const_int(stack, L"nice", RLIMIT_NICE, L"The NICE limit");
    anna_module_const_int(stack, L"nofile", RLIMIT_NOFILE, L"The NOFILE limit");
    anna_module_const_int(stack, L"nproc", RLIMIT_NPROC, L"The NPROC limit");
    anna_module_const_int(stack, L"rss", RLIMIT_RSS, L"The RSS limit");
    anna_module_const_int(stack, L"rtprio", RLIMIT_RTPRIO, L"The RTPRIO limit");
    anna_module_const_int(stack, L"sigpending", RLIMIT_SIGPENDING, L"The SIGPENDING limit");
    anna_module_const_int(stack, L"stack", RLIMIT_STACK, L"The STACK limit");

     anna_type_data_register(anna_r_limit_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_r_limit_cur_getter, 1)
{
    struct rlimit *data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->rlim_cur);
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_max_getter, 1)
{
    struct rlimit *data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->rlim_max);
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_init, 1)
{
    struct rlimit *data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct rlimit));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_r_limit_get_r_limit, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_resource = anna_as_int(param[0]);
    struct rlimit *native_param_rlim = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(getrlimit(native_param_resource, native_param_rlim));
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_set_r_limit, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_resource = anna_as_int(param[0]);
    struct rlimit *native_param_rlim = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(setrlimit(native_param_resource, native_param_rlim));
    // Perform cleanup

    // Return result
    return result;
}

void anna_r_limit_create(anna_stack_template_t *stack);
void anna_r_limit_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_r_limit_type_data, stack);        
}
void anna_r_limit_load(anna_stack_template_t *stack);
void anna_r_limit_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"rLimitMode", anna_r_limit_mode_create, anna_r_limit_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_r_limit_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct rlimit));

    anna_member_create_native_property(
        unix_r_limit_type, anna_mid_get(L"cur"),
        int_type, unix_i_r_limit_cur_getter, 0, L"Currently enforced limit (soft limit)");

    anna_member_create_native_property(
        unix_r_limit_type, anna_mid_get(L"max"),
        int_type, unix_i_r_limit_max_getter, 0, L"Maximum value of limit (hard limit)");
    anna_member_create_native_method(
	unix_r_limit_type, anna_mid_get(L"__init__"), 0,
	&unix_i_r_limit_init, object_type, 1, &unix_r_limit_type, this_argn, 0, 0);    
    anna_type_document(
            unix_r_limit_type, L"A structure representing the current and maximum value of a system resource usage limit.");

    anna_type_t *unix_i_r_limit_get_r_limit_argv[] = {int_type, unix_r_limit_type};
    wchar_t *unix_i_r_limit_get_r_limit_argn[] = {L"resource", L"rlim"};
    anna_module_function(stack, L"getRLimit", 0, &unix_i_r_limit_get_r_limit, int_type, 2, unix_i_r_limit_get_r_limit_argv, unix_i_r_limit_get_r_limit_argn, 0);

    anna_type_t *unix_i_r_limit_set_r_limit_argv[] = {int_type, unix_r_limit_type};
    wchar_t *unix_i_r_limit_set_r_limit_argn[] = {L"resource", L"rlim"};
    anna_module_function(stack, L"setRLimit", 0, &unix_i_r_limit_set_r_limit, int_type, 2, unix_i_r_limit_set_r_limit_argv, unix_i_r_limit_set_r_limit_argn, 0);

     anna_type_data_register(anna_r_limit_type_data, stack);
}
const static anna_type_data_t anna_env_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_env_getenv, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = (getenv(native_param_name)) ? anna_from_obj(anna_string_create_narrow(strlen(getenv(native_param_name)), getenv(native_param_name))) : null_entry;
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_setenv, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_value = anna_string_payload_narrow(anna_as_obj(param[1]));
    int native_param_overwrite = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    anna_entry_t *result = anna_from_int(setenv(native_param_name, native_param_value, native_param_overwrite));
    // Perform cleanup
    free(native_param_name);
    free(native_param_value);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_unsetenv, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(unsetenv(native_param_name));
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_clearenv, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    anna_entry_t *result = anna_from_int(clearenv());
    // Perform cleanup

    // Return result
    return result;
}

void anna_env_create(anna_stack_template_t *stack);
void anna_env_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_env_type_data, stack);        
}
void anna_env_load(anna_stack_template_t *stack);
void anna_env_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_env_getenv_argv[] = {string_type};
    wchar_t *unix_i_env_getenv_argn[] = {L"name"};
    anna_module_function(stack, L"getenv", 0, &unix_i_env_getenv, string_type, 1, unix_i_env_getenv_argv, unix_i_env_getenv_argn, L"Return the current value of the given environment variable. Equivalanet to the C getenv function.");

    anna_type_t *unix_i_env_setenv_argv[] = {string_type, string_type, int_type};
    wchar_t *unix_i_env_setenv_argn[] = {L"name", L"value", L"overwrite"};
    anna_module_function(stack, L"setenv", 0, &unix_i_env_setenv, int_type, 3, unix_i_env_setenv_argv, unix_i_env_setenv_argn, L"Assign a new value to the environment variable with the given name. Equivalanet to the C setenv function.");

    anna_type_t *unix_i_env_unsetenv_argv[] = {string_type};
    wchar_t *unix_i_env_unsetenv_argn[] = {L"name"};
    anna_module_function(stack, L"unsetenv", 0, &unix_i_env_unsetenv, int_type, 1, unix_i_env_unsetenv_argv, unix_i_env_unsetenv_argn, L"Delete the specified environment variable. Equivalanet to the C unsetenv function.");

    anna_type_t *unix_i_env_clearenv_argv[] = {};
    wchar_t *unix_i_env_clearenv_argn[] = {};
    anna_module_function(stack, L"clearenv", 0, &unix_i_env_clearenv, int_type, 0, unix_i_env_clearenv_argv, unix_i_env_clearenv_argn, L"Removes all environemnt variables. Equivalanet to the C clearenv function.");

     anna_type_data_register(anna_env_type_data, stack);
}
const static anna_type_data_t anna_sleep_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_sleep_sleep, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_seconds = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    anna_entry_t *result = anna_from_int(sleep(native_param_seconds));
    // Perform cleanup

    // Return result
    return result;
}

void anna_sleep_create(anna_stack_template_t *stack);
void anna_sleep_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_sleep_type_data, stack);        
}
void anna_sleep_load(anna_stack_template_t *stack);
void anna_sleep_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_sleep_sleep_argv[] = {int_type};
    wchar_t *unix_i_sleep_sleep_argn[] = {L"seconds"};
    anna_module_function(stack, L"sleep", 0, &unix_i_sleep_sleep, int_type, 1, unix_i_sleep_sleep_argv, unix_i_sleep_sleep_argn, L"Sleep for the specified number of seconds");

     anna_type_data_register(anna_sleep_type_data, stack);
}
const static anna_type_data_t anna_time_type_data[] = 
{
    { &unix_time_val_type, L"TimeVal" },
    { &unix_time_zone_type, L"TimeZone" },
};

ANNA_VM_NATIVE(unix_i_time_val_sec_getter, 1)
{
    struct timeval *data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->tv_sec);
    return result;
}

ANNA_VM_NATIVE(unix_i_time_val_sec_setter, 2)
{
    struct timeval *data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->tv_sec = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_time_val_usec_getter, 1)
{
    struct timeval *data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->tv_usec);
    return result;
}

ANNA_VM_NATIVE(unix_i_time_val_usec_setter, 2)
{
    struct timeval *data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->tv_usec = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_time_val_init, 1)
{
    struct timeval *data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct timeval));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_time_zone_init, 1)
{
    struct timezone *data = (struct timezone *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct timezone));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_time_gettimeofday, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    struct timeval *native_param_tv = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    struct timezone *native_param_tz = (struct timezone *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    anna_entry_t *result = (gettimeofday(native_param_tv, native_param_tz))?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

void anna_time_create(anna_stack_template_t *stack);
void anna_time_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_time_type_data, stack);        
}
void anna_time_load(anna_stack_template_t *stack);
void anna_time_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_time_val_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct timeval));

    anna_member_create_native_property(
        unix_time_val_type, anna_mid_get(L"sec"),
        int_type, unix_i_time_val_sec_getter, unix_i_time_val_sec_setter, L"Seconds");

    anna_member_create_native_property(
        unix_time_val_type, anna_mid_get(L"usec"),
        int_type, unix_i_time_val_usec_getter, unix_i_time_val_usec_setter, L"Microseconds.");
    anna_member_create_native_method(
	unix_time_val_type, anna_mid_get(L"__init__"), 0,
	&unix_i_time_val_init, object_type, 1, &unix_time_val_type, this_argn, 0, 0);    
    anna_type_document(
            unix_time_val_type, L"A data structure representing a point in time as the amount of time that has elapsed since the epoch.");

    anna_member_create_blob(unix_time_zone_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct timezone));
    anna_member_create_native_method(
	unix_time_zone_type, anna_mid_get(L"__init__"), 0,
	&unix_i_time_zone_init, object_type, 1, &unix_time_zone_type, this_argn, 0, 0);    
    anna_type_document(
            unix_time_zone_type, L"A deprecated data structure that used to be used for representing a time zone.");

    anna_type_t *unix_i_time_gettimeofday_argv[] = {unix_time_val_type, unix_time_zone_type};
    wchar_t *unix_i_time_gettimeofday_argn[] = {L"tv", L"tz"};
    anna_module_function(stack, L"gettimeofday", 0, &unix_i_time_gettimeofday, object_type, 2, unix_i_time_gettimeofday_argv, unix_i_time_gettimeofday_argn, L"Gets the current system time. Equivalanet to the C gettimeofday function.");

     anna_type_data_register(anna_time_type_data, stack);
}


// This function is called to create all types defined in this module

void anna_unix_create(anna_stack_template_t *stack);
void anna_unix_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_unix_type_data, stack);        
}

// This function is called to load all functions and other declarations into the module

void anna_unix_load(anna_stack_template_t *stack);
void anna_unix_load(anna_stack_template_t *stack)
{
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"io", anna_io_create, anna_io_load},
            { L"proc", anna_proc_create, anna_proc_load},
            { L"user", anna_user_create, anna_user_load},
            { L"rLimit", anna_r_limit_create, anna_r_limit_load},
            { L"env", anna_env_create, anna_env_load},
            { L"sleep", anna_sleep_create, anna_sleep_load},
            { L"time", anna_time_create, anna_time_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


     anna_type_data_register(anna_unix_type_data, stack);
}


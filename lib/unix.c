
/*
    DO NOT MANUALLY EDIT THIS FILE.

    This file has been automaticaly generated by the anna bind
    utility. If you manually edit it, your changes will eventually be
    lost. Not to mention the fact that staring at machine generated
    code rots your brain. If this file is incorrect, either update the
    bind utility or update the binding source, which is located in the
    file:

    internalBindings/unix.bind

 */
#include "anna/config.h"

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>
#include <pthread.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>
#include <sys/wait.h>
#include <grp.h>
#include <stdint.h>
#include <poll.h>
#include <sys/select.h>
#include <locale.h>
#include <termios.h>
#include <sys/signalfd.h>

#include "anna/anna.h"

// Declare internal variables for all types defined in this module
anna_type_t *unix_time_val_type;
anna_type_t *unix_time_zone_type;
anna_type_t *unix_stat_type;
anna_type_t *unix_f_lock_type;
anna_type_t *unix_fd_set_type;
anna_type_t *unix_signal_set_type;
anna_type_t *unix_r_limit_type;
anna_type_t *unix_locale_conv_type;
anna_type_t *unix_termios_type;


// Data used to initialize all types defined in this module
const static anna_type_data_t anna_unix_type_data[] = 
{
};

// This is the source code of the various wrapper functions
const static anna_type_data_t anna_time_type_data[] = 
{
    { &unix_time_val_type, L"TimeVal" },
    { &unix_time_zone_type, L"TimeZone" },
};

ANNA_VM_NATIVE(unix_i_time_val_sec_getter, 1)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->tv_sec);

    return result;
}

ANNA_VM_NATIVE(unix_i_time_val_sec_setter, 2)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        int tmp = anna_as_int(param[1]);

    data->tv_sec = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_time_val_usec_getter, 1)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->tv_usec);

    return result;
}

ANNA_VM_NATIVE(unix_i_time_val_usec_setter, 2)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        int tmp = anna_as_int(param[1]);

    data->tv_usec = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_time_val_init, 1)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct timeval));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_time_zone_init, 1)
{
    struct timezone *data;
    data = (struct timezone *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct timezone));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_time_gettimeofday, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
struct timeval *native_param_tv;
    native_param_tv = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);struct timezone *native_param_tz;
    native_param_tz = (struct timezone *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_1 = gettimeofday(native_param_tv, native_param_tz);
    anna_entry_t *result = (tmp_var_1)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

void anna_time_create(anna_stack_template_t *stack);
void anna_time_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_time_type_data, stack);        
}
void anna_time_load(anna_stack_template_t *stack);
void anna_time_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_time_val_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct timeval));

    anna_member_create_native_property(
        unix_time_val_type, anna_mid_get(L"sec"),
        int_type, unix_i_time_val_sec_getter, unix_i_time_val_sec_setter, L"Seconds");

    anna_member_create_native_property(
        unix_time_val_type, anna_mid_get(L"usec"),
        int_type, unix_i_time_val_usec_getter, unix_i_time_val_usec_setter, L"Microseconds.");
    anna_member_create_native_method(
	unix_time_val_type, anna_mid_get(L"__init__"), 0,
	&unix_i_time_val_init, object_type, 1, &unix_time_val_type, this_argn, 0, 0);    
    anna_type_document(
            unix_time_val_type, L"A data structure representing a point in time as the amount of time that has elapsed since the epoch.");

    anna_member_create_blob(unix_time_zone_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct timezone));
    anna_member_create_native_method(
	unix_time_zone_type, anna_mid_get(L"__init__"), 0,
	&unix_i_time_zone_init, object_type, 1, &unix_time_zone_type, this_argn, 0, 0);    
    anna_type_document(
            unix_time_zone_type, L"A deprecated data structure that used to be used for representing a time zone.");

    anna_type_t *unix_i_time_gettimeofday_argv[] = {unix_time_val_type, unix_time_zone_type};
    wchar_t *unix_i_time_gettimeofday_argn[] = {L"tv", L"tz"};
    latest_function = anna_module_function(stack, L"gettimeofday", 0, &unix_i_time_gettimeofday, object_type, 2, unix_i_time_gettimeofday_argv, unix_i_time_gettimeofday_argn, 0, L"Gets the current system time. Equivalanet to the C gettimeofday function.");
    anna_stack_document(stack, L"The unix.time module contains low level wrappers for basic unix functionality revolving around timekeeping.");

    anna_type_data_register(anna_time_type_data, stack);
}
const static anna_type_data_t anna_io_type_data[] = 
{
    { &unix_stat_type, L"Stat" },
    { &unix_f_lock_type, L"FLock" },
    { &unix_fd_set_type, L"FdSet" },
};
const static anna_type_data_t anna_open_mode_type_data[] = 
{
};

void anna_open_mode_create(anna_stack_template_t *stack);
void anna_open_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_open_mode_type_data, stack);        
}
void anna_open_mode_load(anna_stack_template_t *stack);
void anna_open_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef O_RDONLY
    anna_module_const_int(stack, L"readOnly", O_RDONLY, L"Open file in read-only mode.");
#else
    anna_module_const(stack, L"readOnly", int_type, null_entry, L"Open file in read-only mode.");
#endif

#ifdef O_WRONLY
    anna_module_const_int(stack, L"writeOnly", O_WRONLY, L"Open file in write-only mode.");
#else
    anna_module_const(stack, L"writeOnly", int_type, null_entry, L"Open file in write-only mode.");
#endif

#ifdef O_RDWR
    anna_module_const_int(stack, L"readWrite", O_RDWR, L"Open file in read-write mode.");
#else
    anna_module_const(stack, L"readWrite", int_type, null_entry, L"Open file in read-write mode.");
#endif

#ifdef O_APPEND
    anna_module_const_int(stack, L"append", O_APPEND, L"The file is opened in append mode.");
#else
    anna_module_const(stack, L"append", int_type, null_entry, L"The file is opened in append mode.");
#endif

#ifdef O_ASYNC
    anna_module_const_int(stack, L"async", O_ASYNC, L"Enable signal-driven I/O.");
#else
    anna_module_const(stack, L"async", int_type, null_entry, L"Enable signal-driven I/O.");
#endif

#ifdef O_CREAT
    anna_module_const_int(stack, L"create", O_CREAT, L"If the file does not exist it will be created.");
#else
    anna_module_const(stack, L"create", int_type, null_entry, L"If the file does not exist it will be created.");
#endif

#ifdef O_CLOEXEC
    anna_module_const_int(stack, L"closeOnExec", O_CLOEXEC, L"Enable the close-on-exec flag for the new file descriptor.");
#else
    anna_module_const(stack, L"closeOnExec", int_type, null_entry, L"Enable the close-on-exec flag for the new file descriptor.");
#endif

#ifdef O_DIRECT
    anna_module_const_int(stack, L"direct", O_DIRECT, L"Try to minimize cache effects of the I/O to and from this file.");
#else
    anna_module_const(stack, L"direct", int_type, null_entry, L"Try to minimize cache effects of the I/O to and from this file.");
#endif

#ifdef O_DIRECTORY
    anna_module_const_int(stack, L"directory", O_DIRECTORY, L"If pathname is not a directory, cause the open to fail.");
#else
    anna_module_const(stack, L"directory", int_type, null_entry, L"If pathname is not a directory, cause the open to fail.");
#endif

#ifdef O_EXCL
    anna_module_const_int(stack, L"exclusive", O_EXCL, L"Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail.");
#else
    anna_module_const(stack, L"exclusive", int_type, null_entry, L"Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail.");
#endif

#ifdef O_LARGEFILE
    anna_module_const_int(stack, L"largeFile", O_LARGEFILE, L"(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.");
#else
    anna_module_const(stack, L"largeFile", int_type, null_entry, L"(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.");
#endif

#ifdef O_NOATIME
    anna_module_const_int(stack, L"noAccessTime", O_NOATIME, L"Do not update the file last access time (st_atime in the inode) when the file is read().");
#else
    anna_module_const(stack, L"noAccessTime", int_type, null_entry, L"Do not update the file last access time (st_atime in the inode) when the file is read().");
#endif

#ifdef O_NOCTTY
    anna_module_const_int(stack, L"noControllingTTY", O_NOCTTY, L"If pathname refers to a terminal device - it will not become the process's controlling terminal even if the process does not have one.");
#else
    anna_module_const(stack, L"noControllingTTY", int_type, null_entry, L"If pathname refers to a terminal device - it will not become the process's controlling terminal even if the process does not have one.");
#endif

#ifdef O_NOFOLLOW
    anna_module_const_int(stack, L"noFollow", O_NOFOLLOW, L"If pathname is a symbolic link, then the open fails.");
#else
    anna_module_const(stack, L"noFollow", int_type, null_entry, L"If pathname is a symbolic link, then the open fails.");
#endif

#ifdef O_NONBLOCK
    anna_module_const_int(stack, L"nonBlock", O_NONBLOCK, L"When possible, the file is opened in nonblocking mode.");
#else
    anna_module_const(stack, L"nonBlock", int_type, null_entry, L"When possible, the file is opened in nonblocking mode.");
#endif

#ifdef O_SYNC
    anna_module_const_int(stack, L"synchronous", O_SYNC, L"The file is opened for synchronous I/O.");
#else
    anna_module_const(stack, L"synchronous", int_type, null_entry, L"The file is opened for synchronous I/O.");
#endif

#ifdef O_TRUNC
    anna_module_const_int(stack, L"truncate", O_TRUNC, L"f the file already exists and is a regular file and the open mode allows writing (i.e., is writeOnly or readWrite) it will be truncated to length 0.");
#else
    anna_module_const(stack, L"truncate", int_type, null_entry, L"f the file already exists and is a regular file and the open mode allows writing (i.e., is writeOnly or readWrite) it will be truncated to length 0.");
#endif

    anna_stack_document(stack, L"Flags determining the mode for unix.io.open");

    anna_type_data_register(anna_open_mode_type_data, stack);
}
const static anna_type_data_t anna_stat_mode_type_data[] = 
{
};

void anna_stat_mode_create(anna_stack_template_t *stack);
void anna_stat_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_stat_mode_type_data, stack);        
}
void anna_stat_mode_load(anna_stack_template_t *stack);
void anna_stat_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef S_IFREG
    anna_module_const_int(stack, L"regular", S_IFREG, L"Regular file");
#else
    anna_module_const(stack, L"regular", int_type, null_entry, L"Regular file");
#endif

#ifdef S_IFSOCK
    anna_module_const_int(stack, L"socket", S_IFSOCK, L"Socket");
#else
    anna_module_const(stack, L"socket", int_type, null_entry, L"Socket");
#endif

#ifdef S_IFLNK
    anna_module_const_int(stack, L"link", S_IFLNK, L"Symbolic link.");
#else
    anna_module_const(stack, L"link", int_type, null_entry, L"Symbolic link.");
#endif

#ifdef S_IFBLK
    anna_module_const_int(stack, L"block", S_IFBLK, L"Block device.");
#else
    anna_module_const(stack, L"block", int_type, null_entry, L"Block device.");
#endif

#ifdef S_IFDIR
    anna_module_const_int(stack, L"directory", S_IFDIR, L"Directory.");
#else
    anna_module_const(stack, L"directory", int_type, null_entry, L"Directory.");
#endif

#ifdef S_IFCHR
    anna_module_const_int(stack, L"character", S_IFCHR, L"Character device.");
#else
    anna_module_const(stack, L"character", int_type, null_entry, L"Character device.");
#endif

#ifdef S_IFIFO
    anna_module_const_int(stack, L"fifo", S_IFIFO, L"FIFO.");
#else
    anna_module_const(stack, L"fifo", int_type, null_entry, L"FIFO.");
#endif

#ifdef S_ISUID
    anna_module_const_int(stack, L"suid", S_ISUID, L"Set UID bit.");
#else
    anna_module_const(stack, L"suid", int_type, null_entry, L"Set UID bit.");
#endif

#ifdef S_ISGID
    anna_module_const_int(stack, L"sgid", S_ISGID, L"Set-group-ID bit.");
#else
    anna_module_const(stack, L"sgid", int_type, null_entry, L"Set-group-ID bit.");
#endif

#ifdef S_ISVTX
    anna_module_const_int(stack, L"sticky", S_ISVTX, L"Sticky bit.");
#else
    anna_module_const(stack, L"sticky", int_type, null_entry, L"Sticky bit.");
#endif

#ifdef S_IRWXU
    anna_module_const_int(stack, L"userAll", S_IRWXU, L"Mask for all file owner permissions.");
#else
    anna_module_const(stack, L"userAll", int_type, null_entry, L"Mask for all file owner permissions.");
#endif

#ifdef S_IRUSR
    anna_module_const_int(stack, L"userRead", S_IRUSR, L"File owner read permission.");
#else
    anna_module_const(stack, L"userRead", int_type, null_entry, L"File owner read permission.");
#endif

#ifdef S_IWUSR
    anna_module_const_int(stack, L"userwrite", S_IWUSR, L"File owner write permission.");
#else
    anna_module_const(stack, L"userwrite", int_type, null_entry, L"File owner write permission.");
#endif

#ifdef S_IXUSR
    anna_module_const_int(stack, L"userExecute", S_IXUSR, L"File owner execute permission.");
#else
    anna_module_const(stack, L"userExecute", int_type, null_entry, L"File owner execute permission.");
#endif

#ifdef S_IRWXG
    anna_module_const_int(stack, L"groupAll", S_IRWXG, L"Mask for all group permissions.");
#else
    anna_module_const(stack, L"groupAll", int_type, null_entry, L"Mask for all group permissions.");
#endif

#ifdef S_IRGRP
    anna_module_const_int(stack, L"groupRead", S_IRGRP, L"Group has read permission.");
#else
    anna_module_const(stack, L"groupRead", int_type, null_entry, L"Group has read permission.");
#endif

#ifdef S_IWGRP
    anna_module_const_int(stack, L"groupwrite", S_IWGRP, L"Group has write permission.");
#else
    anna_module_const(stack, L"groupwrite", int_type, null_entry, L"Group has write permission.");
#endif

#ifdef S_IXGRP
    anna_module_const_int(stack, L"groupExecute", S_IXGRP, L"Group has execute permission.");
#else
    anna_module_const(stack, L"groupExecute", int_type, null_entry, L"Group has execute permission.");
#endif

#ifdef S_IRWXO
    anna_module_const_int(stack, L"otherAll", S_IRWXO, L"Mask for permissions for others (not in group).");
#else
    anna_module_const(stack, L"otherAll", int_type, null_entry, L"Mask for permissions for others (not in group).");
#endif

#ifdef S_IROTH
    anna_module_const_int(stack, L"otherRead", S_IROTH, L"Others have read permission.");
#else
    anna_module_const(stack, L"otherRead", int_type, null_entry, L"Others have read permission.");
#endif

#ifdef S_IWOTH
    anna_module_const_int(stack, L"otherwrite", S_IWOTH, L"Others have write permission.");
#else
    anna_module_const(stack, L"otherwrite", int_type, null_entry, L"Others have write permission.");
#endif

#ifdef S_IXOTH
    anna_module_const_int(stack, L"otherExecute", S_IXOTH, L"Others have execute permission.");
#else
    anna_module_const(stack, L"otherExecute", int_type, null_entry, L"Others have execute permission.");
#endif

    anna_stack_document(stack, L"Flags used for identifying file status together with a unix.io.Stat object.");

    anna_type_data_register(anna_stat_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_io_open, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_flags = anna_as_int(param[1]);
    int native_param_mode = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    int tmp_var_2 = open(native_param_name, native_param_flags, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_2);

    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_creat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_3 = creat(native_param_name, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_3);

    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_read, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    unsigned char *native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    int native_param_count = anna_as_int(param[2]);

    // Validate parameters
    if(anna_buffer_ensure_capacity(anna_as_obj(param[1]), native_param_count)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    }

    // Call the function
    int tmp_var_4 = read(native_param_fd, native_param_buffer, native_param_count);
    anna_entry_t *result = anna_from_int(tmp_var_4);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_write, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    unsigned char *native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    int native_param_count = anna_as_int(param[2]);

    // Validate parameters
    if(anna_buffer_ensure_capacity(anna_as_obj(param[1]), native_param_count)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    }

    // Call the function
    int tmp_var_5 = write(native_param_fd, native_param_buffer, native_param_count);
    anna_entry_t *result = anna_from_int(tmp_var_5);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_close, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_6 = close(native_param_fd);
    anna_entry_t *result = (tmp_var_6)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_dev_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_dev);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_ino_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_ino);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_mode_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_mode);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_nlink_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_nlink);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_uid_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_uid);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_gid_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_gid);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_rdev_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_rdev);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_size_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_size);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_blksize_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_blksize);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_blocks_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_blocks);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_atime_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_atime);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_mtime_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_mtime);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_ctime_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->st_ctime);

    return result;
}

ANNA_VM_NATIVE(unix_i_stat_init, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct stat));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_io_stat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
struct stat *native_param_buf;
    native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_7 = stat(native_param_path, native_param_buf);
    anna_entry_t *result = (tmp_var_7)?anna_from_int(1):null_entry;

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lstat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
struct stat *native_param_buf;
    native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_8 = lstat(native_param_path, native_param_buf);
    anna_entry_t *result = (tmp_var_8)?anna_from_int(1):null_entry;

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fstat, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
struct stat *native_param_buf;
    native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_9 = fstat(native_param_fd, native_param_buf);
    anna_entry_t *result = (tmp_var_9)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_mkdir, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_10 = mkdir(native_param_path, native_param_mode);
    anna_entry_t *result = (tmp_var_10)?anna_from_int(1):null_entry;

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_getcwd, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    unsigned char *native_param_buf = anna_buffer_get_payload(anna_as_obj(param[0]));
    int native_param_size = anna_as_int(param[1]);

    // Validate parameters
    if(anna_buffer_ensure_capacity(anna_as_obj(param[0]), native_param_size)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buf = anna_buffer_get_payload(anna_as_obj(param[0]));
    }

    // Call the function
    int tmp_var_11 = getcwd(native_param_buf, native_param_size);
    anna_entry_t *result = (tmp_var_11)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chdir, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters

    // Call the function
    int tmp_var_12 = chdir(native_param_path);
    anna_entry_t *result = (tmp_var_12)?anna_from_int(1):null_entry;

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chroot, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters

    // Call the function
    int tmp_var_13 = chroot(native_param_path);
    anna_entry_t *result = (tmp_var_13)?anna_from_int(1):null_entry;

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchdir, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_14 = fchdir(native_param_fd);
    anna_entry_t *result = (tmp_var_14)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_type_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->l_type);

    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_whence_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->l_whence);

    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_start_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->l_start);

    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_len_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->l_len);

    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_pid_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->l_pid);

    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_init, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct flock));
    return param[0];
}
const static anna_type_data_t anna_fcntl_mode_type_data[] = 
{
};

void anna_fcntl_mode_create(anna_stack_template_t *stack);
void anna_fcntl_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_fcntl_mode_type_data, stack);        
}
void anna_fcntl_mode_load(anna_stack_template_t *stack);
void anna_fcntl_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"dupFd", F_DUPFD, L"Duplicate file descriptor.");
    anna_stack_document(stack, L"Flags specifying file descriptor manipulations for unix.io.fcntl");

    anna_type_data_register(anna_fcntl_mode_type_data, stack);
}
const static anna_type_data_t anna_seek_mode_type_data[] = 
{
};

void anna_seek_mode_create(anna_stack_template_t *stack);
void anna_seek_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_seek_mode_type_data, stack);        
}
void anna_seek_mode_load(anna_stack_template_t *stack);
void anna_seek_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef SEEK_SET
    anna_module_const_int(stack, L"set", SEEK_SET, L"Seek to absolute file offset.");
#else
    anna_module_const(stack, L"set", int_type, null_entry, L"Seek to absolute file offset.");
#endif

#ifdef SEEK_CUR
    anna_module_const_int(stack, L"cur", SEEK_CUR, L"Seek to file offset relative current position.");
#else
    anna_module_const(stack, L"cur", int_type, null_entry, L"Seek to file offset relative current position.");
#endif

#ifdef SEEK_END
    anna_module_const_int(stack, L"end", SEEK_END, L"Seek to file offset relative to end of file.");
#else
    anna_module_const(stack, L"end", int_type, null_entry, L"Seek to file offset relative to end of file.");
#endif

    anna_stack_document(stack, L"Different seek modes for use with the unix.io.seek function");

    anna_type_data_register(anna_seek_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_io_fcntl_void, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_15 = fcntl(native_param_fd, native_param_cmd);
    anna_entry_t *result = anna_from_int(tmp_var_15);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fcntl_int, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);
    int native_param_arg = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    int tmp_var_16 = fcntl(native_param_fd, native_param_cmd, native_param_arg);
    anna_entry_t *result = anna_from_int(tmp_var_16);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fcntl_f_lock, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);
struct flock *native_param_arg;
    native_param_arg = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_17 = fcntl(native_param_fd, native_param_cmd, native_param_arg);
    anna_entry_t *result = anna_from_int(tmp_var_17);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_dup, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_18 = dup(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_18);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_dup2, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_oldfd = anna_as_int(param[0]);
    int native_param_newfd = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_19 = dup2(native_param_oldfd, native_param_newfd);
    anna_entry_t *result = anna_from_int(tmp_var_19);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chown, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    int tmp_var_20 = chown(native_param_path, native_param_owner, native_param_group);
    anna_entry_t *result = anna_from_int(tmp_var_20);

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchown, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    int tmp_var_21 = fchown(native_param_fd, native_param_owner, native_param_group);
    anna_entry_t *result = anna_from_int(tmp_var_21);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lchown, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    int tmp_var_22 = lchown(native_param_path, native_param_owner, native_param_group);
    anna_entry_t *result = anna_from_int(tmp_var_22);

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chmod, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_23 = chmod(native_param_path, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_23);

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchmod, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_24 = fchmod(native_param_fd, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_24);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_symlink, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_oldpath = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters

    // Call the function
    int tmp_var_25 = symlink(native_param_oldpath, native_param_newpath);
    anna_entry_t *result = anna_from_int(tmp_var_25);

    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_link, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_oldpath = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters

    // Call the function
    int tmp_var_26 = link(native_param_oldpath, native_param_newpath);
    anna_entry_t *result = anna_from_int(tmp_var_26);

    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_unlink, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters

    // Call the function
    int tmp_var_27 = unlink(native_param_path);
    anna_entry_t *result = anna_from_int(tmp_var_27);

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_rmdir, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters

    // Call the function
    int tmp_var_28 = rmdir(native_param_path);
    anna_entry_t *result = anna_from_int(tmp_var_28);

    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_rename, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_oldpath = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters

    // Call the function
    int tmp_var_29 = rename(native_param_oldpath, native_param_newpath);
    anna_entry_t *result = anna_from_int(tmp_var_29);

    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_pipe, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    if(anna_list_ensure_capacity(anna_as_obj(param[0]), 2))
    {
        return null_entry;
    }
    size_t native_param_fd_count = anna_list_get_count(anna_as_obj(param[0]));
    int* native_param_fd = malloc(sizeof(int) * native_param_fd_count);
    if(!native_param_fd){ return null_entry; }
    int native_param_fd_idx;
    for(native_param_fd_idx=0; native_param_fd_idx < native_param_fd_count; native_param_fd_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[0]), native_param_fd_idx);
        if(tmp == null_entry)
        {
            native_param_fd[native_param_fd_idx] = 0;
        }
        else
        {
                int native_param_fd_val = anna_as_int(tmp);

            native_param_fd[native_param_fd_idx] = native_param_fd_val;
        }
    }

    // Validate parameters

    // Call the function
    int tmp_var_30 = pipe(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_30);

    // Perform cleanup
    for(native_param_fd_idx=0; native_param_fd_idx < native_param_fd_count; native_param_fd_idx++)
    {
            anna_entry_t *tmp = anna_from_int(native_param_fd[native_param_fd_idx]);

        anna_list_set(anna_as_obj(param[0]), native_param_fd_idx, tmp);
        
    }
    free(native_param_fd);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lseek, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    uint64_t native_param_offset = anna_as_int(param[1]);
    int native_param_whence = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    uint64_t tmp_var_31 = lseek(native_param_fd, native_param_offset, native_param_whence);
    anna_entry_t *result = anna_from_uint64(tmp_var_31);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_sync, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    sync();
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fsync, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_32 = fsync(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_32);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fdatasync, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_33 = fdatasync(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_33);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_umask, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_mask = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_34 = umask(native_param_mask);
    anna_entry_t *result = anna_from_int(tmp_var_34);

    // Perform cleanup

    // Return result
    return result;
}

#define ANNA_FD_CLR(set, fd) FD_CLR(fd, set)
#define ANNA_FD_ISSET(set, fd) FD_ISSET(fd, set)
#define ANNA_FD_SET(set, fd) FD_SET(fd, set)

static int anna_fd_set_value(fd_set *set, int fd, int val)
{
    if(val)
    {
        FD_SET(fd, set);
    }
    else
    {
        FD_CLR(fd, set);
    }
    return val;
}

ANNA_VM_NATIVE(unix_i_fd_set_init, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    FD_ZERO(native_param_this);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return param[0];
}

ANNA_VM_NATIVE(unix_i_fd_set_remove, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    ANNA_FD_CLR(native_param_this, native_param_fd);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_in, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_35 = ANNA_FD_ISSET(native_param_this, native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_35);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_get, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_36 = ANNA_FD_ISSET(native_param_this, native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_36);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_set, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);
    int native_param_value = (param[2] != null_entry);

    // Validate parameters

    // Call the function
    int tmp_var_37 = anna_fd_set_value(native_param_this, native_param_fd, native_param_value);
    anna_entry_t *result = (tmp_var_37)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_add, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    ANNA_FD_SET(native_param_this, native_param_fd);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_clear, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    FD_ZERO(native_param_this);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_select, 5)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_nfds = anna_as_int(param[0]);
fd_set *native_param_readfds;
    native_param_readfds = ((param[1]) == null_entry) ? 0 : (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);fd_set *native_param_writefds;
    native_param_writefds = ((param[2]) == null_entry) ? 0 : (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);fd_set *native_param_exceptfds;
    native_param_exceptfds = ((param[3]) == null_entry) ? 0 : (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[3]), ANNA_MID_CSTRUCT_PAYLOAD);struct timeval *native_param_timeout;
    native_param_timeout = ((param[4]) == null_entry) ? 0 : (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[4]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_38 = select(native_param_nfds, native_param_readfds, native_param_writefds, native_param_exceptfds, native_param_timeout);
    anna_entry_t *result = anna_from_int(tmp_var_38);

    // Perform cleanup

    // Return result
    return result;
}

void anna_io_create(anna_stack_template_t *stack);
void anna_io_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_io_type_data, stack);        
}
void anna_io_load(anna_stack_template_t *stack);
void anna_io_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"openMode", anna_open_mode_create, anna_open_mode_load},
            { L"statMode", anna_stat_mode_create, anna_stat_mode_load},
            { L"fcntlMode", anna_fcntl_mode_create, anna_fcntl_mode_load},
            { L"seekMode", anna_seek_mode_create, anna_seek_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_io_open_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_open_argn[] = {L"name", L"flags", L"mode"};
    latest_function = anna_module_function(stack, L"open", 0, &unix_i_io_open, int_type, 3, unix_i_io_open_argv, unix_i_io_open_argn, 0, L"Open a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C open function."));

    anna_type_t *unix_i_io_creat_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_creat_argn[] = {L"name", L"mode"};
    latest_function = anna_module_function(stack, L"creat", 0, &unix_i_io_creat, int_type, 2, unix_i_io_creat_argv, unix_i_io_creat_argn, 0, L"Open a file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"creat"), L"create");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C creat function."));

    anna_type_t *unix_i_io_read_argv[] = {int_type, buffer_type, int_type};
    wchar_t *unix_i_io_read_argn[] = {L"fd", L"buffer", L"count"};
    latest_function = anna_module_function(stack, L"read", 0, &unix_i_io_read, int_type, 3, unix_i_io_read_argv, unix_i_io_read_argn, 0, L"Read from a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C read function."));

    anna_type_t *unix_i_io_write_argv[] = {int_type, buffer_type, int_type};
    wchar_t *unix_i_io_write_argn[] = {L"fd", L"buffer", L"count"};
    latest_function = anna_module_function(stack, L"write", 0, &unix_i_io_write, int_type, 3, unix_i_io_write_argv, unix_i_io_write_argn, 0, L"Write to a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C write function."));

    anna_type_t *unix_i_io_close_argv[] = {int_type};
    wchar_t *unix_i_io_close_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"close", 0, &unix_i_io_close, object_type, 1, unix_i_io_close_argv, unix_i_io_close_argn, 0, L"Close a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C close function."));

    anna_member_create_blob(unix_stat_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct stat));

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"dev"),
        int_type, unix_i_stat_dev_getter, 0, L"ID of device containing file");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"ino"),
        int_type, unix_i_stat_ino_getter, 0, L"Inode number");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"mode"),
        int_type, unix_i_stat_mode_getter, 0, L"File protection mask");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"nlink"),
        int_type, unix_i_stat_nlink_getter, 0, L"Number of hard links.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"uid"),
        int_type, unix_i_stat_uid_getter, 0, L"User ID of owner.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"gid"),
        int_type, unix_i_stat_gid_getter, 0, L"Group ID of owner.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"rdev"),
        int_type, unix_i_stat_rdev_getter, 0, L"Device ID.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"size"),
        int_type, unix_i_stat_size_getter, 0, L"Total size in bytes.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"blksize"),
        int_type, unix_i_stat_blksize_getter, 0, L"Block size for file system IO.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"blocks"),
        int_type, unix_i_stat_blocks_getter, 0, L"Number of 512 byte blocks allocated.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"atime"),
        int_type, unix_i_stat_atime_getter, 0, L"Time of latest acccess.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"mtime"),
        int_type, unix_i_stat_mtime_getter, 0, L"Time of latest modification.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"ctime"),
        int_type, unix_i_stat_ctime_getter, 0, L"Time of latest change.");
    anna_member_create_native_method(
	unix_stat_type, anna_mid_get(L"__init__"), 0,
	&unix_i_stat_init, object_type, 1, &unix_stat_type, this_argn, 0, 0);    
    anna_type_document(
            unix_stat_type, L"A structure representing the status of a file.");
    anna_type_document(
            unix_stat_type, L"This is a straight conversion of the C struct stat.");

    anna_type_t *unix_i_io_stat_argv[] = {string_type, unix_stat_type};
    wchar_t *unix_i_io_stat_argn[] = {L"path", L"buf"};
    latest_function = anna_module_function(stack, L"stat", 0, &unix_i_io_stat, object_type, 2, unix_i_io_stat_argv, unix_i_io_stat_argn, 0, L"Check the status of file with the specified path. Equivalanet to the C stat function.");

    anna_type_t *unix_i_io_lstat_argv[] = {string_type, unix_stat_type};
    wchar_t *unix_i_io_lstat_argn[] = {L"path", L"buf"};
    latest_function = anna_module_function(stack, L"lstat", 0, &unix_i_io_lstat, object_type, 2, unix_i_io_lstat_argv, unix_i_io_lstat_argn, 0, L"Check the status of file with the specified path, without following symlinks. Equivalanet to the C lstat function.");

    anna_type_t *unix_i_io_fstat_argv[] = {int_type, unix_stat_type};
    wchar_t *unix_i_io_fstat_argn[] = {L"fd", L"buf"};
    latest_function = anna_module_function(stack, L"fstat", 0, &unix_i_io_fstat, object_type, 2, unix_i_io_fstat_argv, unix_i_io_fstat_argn, 0, L"Check the status of file with the specified file descriptor. Equivalanet to the C fstat function.");

    anna_type_t *unix_i_io_mkdir_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_mkdir_argn[] = {L"path", L"mode"};
    latest_function = anna_module_function(stack, L"mkdir", 0, &unix_i_io_mkdir, object_type, 2, unix_i_io_mkdir_argv, unix_i_io_mkdir_argn, 0, L"Create a new driectory with the specified path. Equivalanet to the C mkdir function.");
    anna_module_const_int(stack, L"standardInput", 0, L"File descriptor for standard input.");
    anna_module_const_int(stack, L"standardOutput", 1, L"File descriptor for standard output.");
    anna_module_const_int(stack, L"standardError", 2, L"File descriptor for error output");

    anna_type_t *unix_i_io_getcwd_argv[] = {buffer_type, int_type};
    wchar_t *unix_i_io_getcwd_argn[] = {L"buf", L"size"};
    latest_function = anna_module_function(stack, L"getcwd", 0, &unix_i_io_getcwd, object_type, 2, unix_i_io_getcwd_argv, unix_i_io_getcwd_argn, 0, L"Get current working directory.");

    anna_type_t *unix_i_io_chdir_argv[] = {string_type};
    wchar_t *unix_i_io_chdir_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"chdir", 0, &unix_i_io_chdir, object_type, 1, unix_i_io_chdir_argv, unix_i_io_chdir_argn, 0, L"Change working directory.");

    anna_type_t *unix_i_io_chroot_argv[] = {string_type};
    wchar_t *unix_i_io_chroot_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"chroot", 0, &unix_i_io_chroot, object_type, 1, unix_i_io_chroot_argv, unix_i_io_chroot_argn, 0, L"Change root directory.");

    anna_type_t *unix_i_io_fchdir_argv[] = {int_type};
    wchar_t *unix_i_io_fchdir_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"fchdir", 0, &unix_i_io_fchdir, object_type, 1, unix_i_io_fchdir_argv, unix_i_io_fchdir_argn, 0, L"Change working directory.");

    anna_member_create_blob(unix_f_lock_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct flock));

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"type"),
        int_type, unix_i_f_lock_type_getter, 0, L"Type of lock: F_RDLCK, F_WRLCK, F_UNLCK.");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"whence"),
        int_type, unix_i_f_lock_whence_getter, 0, L"How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END.");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"start"),
        int_type, unix_i_f_lock_start_getter, 0, L"Starting offset for lock");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"len"),
        int_type, unix_i_f_lock_len_getter, 0, L"Number of bytes to lock");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"pid"),
        int_type, unix_i_f_lock_pid_getter, 0, L"PID of process blocking our lock (F_GETLK only)");
    anna_member_create_native_method(
	unix_f_lock_type, anna_mid_get(L"__init__"), 0,
	&unix_i_f_lock_init, object_type, 1, &unix_f_lock_type, this_argn, 0, 0);    
    anna_type_document(
            unix_f_lock_type, L"File lock information");

    anna_type_t *unix_i_io_fcntl_void_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_fcntl_void_argn[] = {L"fd", L"cmd"};
    latest_function = anna_module_function(stack, L"fcntlVoid", 0, &unix_i_io_fcntl_void, int_type, 2, unix_i_io_fcntl_void_argv, unix_i_io_fcntl_void_argn, 0, L"Manipulate file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"fcntlVoid"), L"fcntl");

    anna_type_t *unix_i_io_fcntl_int_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_fcntl_int_argn[] = {L"fd", L"cmd", L"arg"};
    latest_function = anna_module_function(stack, L"fcntlInt", 0, &unix_i_io_fcntl_int, int_type, 3, unix_i_io_fcntl_int_argv, unix_i_io_fcntl_int_argn, 0, L"Manipulate file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"fcntlInt"), L"fcntl");

    anna_type_t *unix_i_io_fcntl_f_lock_argv[] = {int_type, int_type, unix_f_lock_type};
    wchar_t *unix_i_io_fcntl_f_lock_argn[] = {L"fd", L"cmd", L"arg"};
    latest_function = anna_module_function(stack, L"fcntlFLock", 0, &unix_i_io_fcntl_f_lock, int_type, 3, unix_i_io_fcntl_f_lock_argv, unix_i_io_fcntl_f_lock_argn, 0, L"Manipulate file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"fcntlFLock"), L"fcntl");

    anna_type_t *unix_i_io_dup_argv[] = {int_type};
    wchar_t *unix_i_io_dup_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"dup", 0, &unix_i_io_dup, int_type, 1, unix_i_io_dup_argv, unix_i_io_dup_argn, 0, L"Duplicate a file descriptor.");

    anna_type_t *unix_i_io_dup2_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_dup2_argn[] = {L"oldfd", L"newfd"};
    latest_function = anna_module_function(stack, L"dup2", 0, &unix_i_io_dup2, int_type, 2, unix_i_io_dup2_argv, unix_i_io_dup2_argn, 0, L"Duplicate a file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"dup2"), L"dup");

    anna_type_t *unix_i_io_chown_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_chown_argn[] = {L"path", L"owner", L"group"};
    latest_function = anna_module_function(stack, L"chown", 0, &unix_i_io_chown, int_type, 3, unix_i_io_chown_argv, unix_i_io_chown_argn, 0, L"Change file owner and group.");

    anna_type_t *unix_i_io_fchown_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_fchown_argn[] = {L"fd", L"owner", L"group"};
    latest_function = anna_module_function(stack, L"fchown", 0, &unix_i_io_fchown, int_type, 3, unix_i_io_fchown_argv, unix_i_io_fchown_argn, 0, L"Change file owner and group.");

    anna_type_t *unix_i_io_lchown_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_lchown_argn[] = {L"path", L"owner", L"group"};
    latest_function = anna_module_function(stack, L"lchown", 0, &unix_i_io_lchown, int_type, 3, unix_i_io_lchown_argv, unix_i_io_lchown_argn, 0, L"Change file owner and group.");

    anna_type_t *unix_i_io_chmod_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_chmod_argn[] = {L"path", L"mode"};
    latest_function = anna_module_function(stack, L"chmod", 0, &unix_i_io_chmod, int_type, 2, unix_i_io_chmod_argv, unix_i_io_chmod_argn, 0, L"Change permissions of a file.");

    anna_type_t *unix_i_io_fchmod_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_fchmod_argn[] = {L"fd", L"mode"};
    latest_function = anna_module_function(stack, L"fchmod", 0, &unix_i_io_fchmod, int_type, 2, unix_i_io_fchmod_argv, unix_i_io_fchmod_argn, 0, L"Change permissions of a file.");

    anna_type_t *unix_i_io_symlink_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_symlink_argn[] = {L"oldpath", L"newpath"};
    latest_function = anna_module_function(stack, L"symlink", 0, &unix_i_io_symlink, int_type, 2, unix_i_io_symlink_argv, unix_i_io_symlink_argn, 0, L"Create a symbolic link to a file.");

    anna_type_t *unix_i_io_link_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_link_argn[] = {L"oldpath", L"newpath"};
    latest_function = anna_module_function(stack, L"link", 0, &unix_i_io_link, int_type, 2, unix_i_io_link_argv, unix_i_io_link_argn, 0, L"Create anew name for a file.");

    anna_type_t *unix_i_io_unlink_argv[] = {string_type};
    wchar_t *unix_i_io_unlink_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"unlink", 0, &unix_i_io_unlink, int_type, 1, unix_i_io_unlink_argv, unix_i_io_unlink_argn, 0, L"Remove a name and possibly a file.");

    anna_type_t *unix_i_io_rmdir_argv[] = {string_type};
    wchar_t *unix_i_io_rmdir_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"rmdir", 0, &unix_i_io_rmdir, int_type, 1, unix_i_io_rmdir_argv, unix_i_io_rmdir_argn, 0, L"Remove a directory.");

    anna_type_t *unix_i_io_rename_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_rename_argn[] = {L"oldpath", L"newpath"};
    latest_function = anna_module_function(stack, L"rename", 0, &unix_i_io_rename, int_type, 2, unix_i_io_rename_argv, unix_i_io_rename_argn, 0, L"Rename a file.");

    anna_type_t *unix_i_io_pipe_argv[] = {anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_io_pipe_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"pipe", 0, &unix_i_io_pipe, int_type, 1, unix_i_io_pipe_argv, unix_i_io_pipe_argn, 0, L"Create a pipe.");
   anna_function_document(latest_function,anna_intern_static(L"The input and output ends of the pipe are stored in the first two elements of the list fd. If fd is not large enough to hold two elements, it will be enlarged."));

    anna_type_t *unix_i_io_lseek_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_lseek_argn[] = {L"fd", L"offset", L"whence"};
    latest_function = anna_module_function(stack, L"lseek", 0, &unix_i_io_lseek, int_type, 3, unix_i_io_lseek_argv, unix_i_io_lseek_argn, 0, L"Reposition read/write file offset.");

    anna_type_t *unix_i_io_sync_argv[] = {};
    wchar_t *unix_i_io_sync_argn[] = {};
    latest_function = anna_module_function(stack, L"sync", 0, &unix_i_io_sync, object_type, 0, unix_i_io_sync_argv, unix_i_io_sync_argn, 0, L"Flush file system buffers.");

    anna_type_t *unix_i_io_fsync_argv[] = {int_type};
    wchar_t *unix_i_io_fsync_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"fsync", 0, &unix_i_io_fsync, int_type, 1, unix_i_io_fsync_argv, unix_i_io_fsync_argn, 0, L"Synchronize a file's in-core state with storage device.");

    anna_type_t *unix_i_io_fdatasync_argv[] = {int_type};
    wchar_t *unix_i_io_fdatasync_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"fdatasync", 0, &unix_i_io_fdatasync, int_type, 1, unix_i_io_fdatasync_argv, unix_i_io_fdatasync_argn, 0, L"Synchronize a file's in-core state with storage device.");

    anna_type_t *unix_i_io_umask_argv[] = {int_type};
    wchar_t *unix_i_io_umask_argn[] = {L"mask"};
    latest_function = anna_module_function(stack, L"umask", 0, &unix_i_io_umask, int_type, 1, unix_i_io_umask_argv, unix_i_io_umask_argn, 0, L"Set a new value for file mode creation mask and return the old value.");

    anna_member_create_blob(unix_fd_set_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(fd_set));

    anna_type_t *unix_i_fd_set_init_argv[] = {unix_fd_set_type};
    wchar_t *unix_i_fd_set_init_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__init__"), 0, 
        &unix_i_fd_set_init, object_type, 1, unix_i_fd_set_init_argv, unix_i_fd_set_init_argn, 0, L"Create an empty new file descriptor set.");

    anna_type_t *unix_i_fd_set_remove_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_remove_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"remove"), 0, 
        &unix_i_fd_set_remove, object_type, 2, unix_i_fd_set_remove_argv, unix_i_fd_set_remove_argn, 0, L"Remove the specified file descriptor from the set.");

    anna_type_t *unix_i_fd_set_in_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_in_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__in__"), 0, 
        &unix_i_fd_set_in, int_type, 2, unix_i_fd_set_in_argv, unix_i_fd_set_in_argn, 0, L"Check if the specified file descriptor is in the set.");

    anna_type_t *unix_i_fd_set_get_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_get_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__get__"), 0, 
        &unix_i_fd_set_get, int_type, 2, unix_i_fd_set_get_argv, unix_i_fd_set_get_argn, 0, L"Check if the specified file descriptor is in the set.");

    anna_type_t *unix_i_fd_set_set_argv[] = {unix_fd_set_type, int_type, object_type};
    wchar_t *unix_i_fd_set_set_argn[] = {L"this", L"fd", L"value"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__set__"), 0, 
        &unix_i_fd_set_set, object_type, 3, unix_i_fd_set_set_argv, unix_i_fd_set_set_argn, 0, L"If value is non-null, add the specified file descriptor to the set. Otherwise, remove it.");

    anna_type_t *unix_i_fd_set_add_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_add_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"add"), 0, 
        &unix_i_fd_set_add, object_type, 2, unix_i_fd_set_add_argv, unix_i_fd_set_add_argn, 0, L"Add the specified file descriptor to the set.");

    anna_type_t *unix_i_fd_set_clear_argv[] = {unix_fd_set_type};
    wchar_t *unix_i_fd_set_clear_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"clear"), 0, 
        &unix_i_fd_set_clear, object_type, 1, unix_i_fd_set_clear_argv, unix_i_fd_set_clear_argn, 0, L"Remove all file descriptors from this set.");
    anna_type_document(
            unix_fd_set_type, L"A set of file descriptors. Used by unix.io.select.");

    anna_type_t *unix_i_io_select_argv[] = {int_type, unix_fd_set_type, unix_fd_set_type, unix_fd_set_type, unix_time_val_type};
    wchar_t *unix_i_io_select_argn[] = {L"nfds", L"readfds", L"writefds", L"exceptfds", L"timeout"};
    latest_function = anna_module_function(stack, L"select", 0, &unix_i_io_select, int_type, 5, unix_i_io_select_argv, unix_i_io_select_argn, 0, L"Select allows a program to monitor multiple file descriptors");
   anna_function_document(latest_function,anna_intern_static(L"Calling select will cause the process to wait until one \nor more of the file descriptors become ready for some class of I/O operation, \nor optionally, until the specified amount of time has passed."));
    anna_stack_document(stack, L"The unix.io module contains low level wrappers for basic unix functionality revolving around input and output.");
    anna_stack_document(stack, L"Unix input/output centers around file descriptors. File descriptors are small, positive integers that can represent open files, directories, pipes or even network sockets.");

    anna_type_data_register(anna_io_type_data, stack);
}
const static anna_type_data_t anna_proc_type_data[] = 
{
    { &unix_signal_set_type, L"SignalSet" },
};
const static anna_type_data_t anna_signal_type_data[] = 
{
};

void anna_signal_create(anna_stack_template_t *stack);
void anna_signal_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_signal_type_data, stack);        
}
void anna_signal_load(anna_stack_template_t *stack);
void anna_signal_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef SIGHUP
    anna_module_const_int(stack, L"hup", SIGHUP, L"The HUP signal");
#else
    anna_module_const(stack, L"hup", int_type, null_entry, L"The HUP signal");
#endif

#ifdef SIGINT
    anna_module_const_int(stack, L"int", SIGINT, L"The INT signal");
#else
    anna_module_const(stack, L"int", int_type, null_entry, L"The INT signal");
#endif

#ifdef SIGQUIT
    anna_module_const_int(stack, L"quit", SIGQUIT, L"The QUIT signal");
#else
    anna_module_const(stack, L"quit", int_type, null_entry, L"The QUIT signal");
#endif

#ifdef SIGILL
    anna_module_const_int(stack, L"ill", SIGILL, L"The ILL signal");
#else
    anna_module_const(stack, L"ill", int_type, null_entry, L"The ILL signal");
#endif

#ifdef SIGABRT
    anna_module_const_int(stack, L"abrt", SIGABRT, L"The ABRT signal");
#else
    anna_module_const(stack, L"abrt", int_type, null_entry, L"The ABRT signal");
#endif

#ifdef SIGFPE
    anna_module_const_int(stack, L"fpe", SIGFPE, L"The FPE signal");
#else
    anna_module_const(stack, L"fpe", int_type, null_entry, L"The FPE signal");
#endif

#ifdef SIGKILL
    anna_module_const_int(stack, L"kill", SIGKILL, L"The KILL signal");
#else
    anna_module_const(stack, L"kill", int_type, null_entry, L"The KILL signal");
#endif

#ifdef SIGSEGV
    anna_module_const_int(stack, L"segv", SIGSEGV, L"The SEGV signal");
#else
    anna_module_const(stack, L"segv", int_type, null_entry, L"The SEGV signal");
#endif

#ifdef SIGPIPE
    anna_module_const_int(stack, L"pipe", SIGPIPE, L"The PIPE signal");
#else
    anna_module_const(stack, L"pipe", int_type, null_entry, L"The PIPE signal");
#endif

#ifdef SIGALRM
    anna_module_const_int(stack, L"alrm", SIGALRM, L"The ALRM signal");
#else
    anna_module_const(stack, L"alrm", int_type, null_entry, L"The ALRM signal");
#endif

#ifdef SIGTERM
    anna_module_const_int(stack, L"term", SIGTERM, L"The TERM signal");
#else
    anna_module_const(stack, L"term", int_type, null_entry, L"The TERM signal");
#endif

#ifdef SIGUSR1
    anna_module_const_int(stack, L"usr1", SIGUSR1, L"The USR1 signal");
#else
    anna_module_const(stack, L"usr1", int_type, null_entry, L"The USR1 signal");
#endif

#ifdef SIGUSR2
    anna_module_const_int(stack, L"usr2", SIGUSR2, L"The USR2 signal");
#else
    anna_module_const(stack, L"usr2", int_type, null_entry, L"The USR2 signal");
#endif

#ifdef SIGCHLD
    anna_module_const_int(stack, L"chld", SIGCHLD, L"The CHLD signal");
#else
    anna_module_const(stack, L"chld", int_type, null_entry, L"The CHLD signal");
#endif

#ifdef SIGCONT
    anna_module_const_int(stack, L"cont", SIGCONT, L"The CONT signal");
#else
    anna_module_const(stack, L"cont", int_type, null_entry, L"The CONT signal");
#endif

#ifdef SIGSTOP
    anna_module_const_int(stack, L"stop", SIGSTOP, L"The STOP signal");
#else
    anna_module_const(stack, L"stop", int_type, null_entry, L"The STOP signal");
#endif

#ifdef SIGTSTP
    anna_module_const_int(stack, L"tstp", SIGTSTP, L"The TSTP signal");
#else
    anna_module_const(stack, L"tstp", int_type, null_entry, L"The TSTP signal");
#endif

#ifdef SIGTTIN
    anna_module_const_int(stack, L"ttin", SIGTTIN, L"The TTIN signal");
#else
    anna_module_const(stack, L"ttin", int_type, null_entry, L"The TTIN signal");
#endif

#ifdef SIGTTOU
    anna_module_const_int(stack, L"ttou", SIGTTOU, L"The TTOU signal");
#else
    anna_module_const(stack, L"ttou", int_type, null_entry, L"The TTOU signal");
#endif

#ifdef SIGBUS
    anna_module_const_int(stack, L"bus", SIGBUS, L"The BUS signal");
#else
    anna_module_const(stack, L"bus", int_type, null_entry, L"The BUS signal");
#endif

#ifdef SIGPOLL
    anna_module_const_int(stack, L"poll", SIGPOLL, L"The POLL signal");
#else
    anna_module_const(stack, L"poll", int_type, null_entry, L"The POLL signal");
#endif

#ifdef SIGPROF
    anna_module_const_int(stack, L"prof", SIGPROF, L"The PROF signal");
#else
    anna_module_const(stack, L"prof", int_type, null_entry, L"The PROF signal");
#endif

#ifdef SIGSYS
    anna_module_const_int(stack, L"sys", SIGSYS, L"The SYS signal");
#else
    anna_module_const(stack, L"sys", int_type, null_entry, L"The SYS signal");
#endif

#ifdef SIGTRAP
    anna_module_const_int(stack, L"trap", SIGTRAP, L"The TRAP signal");
#else
    anna_module_const(stack, L"trap", int_type, null_entry, L"The TRAP signal");
#endif

#ifdef SIGURG
    anna_module_const_int(stack, L"urg", SIGURG, L"The URG signal");
#else
    anna_module_const(stack, L"urg", int_type, null_entry, L"The URG signal");
#endif

#ifdef SIGVTALRM
    anna_module_const_int(stack, L"vtalrm", SIGVTALRM, L"The VTALRM signal");
#else
    anna_module_const(stack, L"vtalrm", int_type, null_entry, L"The VTALRM signal");
#endif

#ifdef SIGXCPU
    anna_module_const_int(stack, L"xcpu", SIGXCPU, L"The XCPU signal");
#else
    anna_module_const(stack, L"xcpu", int_type, null_entry, L"The XCPU signal");
#endif

#ifdef SIGXFSZ
    anna_module_const_int(stack, L"xfsz", SIGXFSZ, L"The XFSZ signal");
#else
    anna_module_const(stack, L"xfsz", int_type, null_entry, L"The XFSZ signal");
#endif

#ifdef SIGIOT
    anna_module_const_int(stack, L"iot", SIGIOT, L"The IOT signal");
#else
    anna_module_const(stack, L"iot", int_type, null_entry, L"The IOT signal");
#endif

#ifdef SIGEMT
    anna_module_const_int(stack, L"emt", SIGEMT, L"The EMT signal");
#else
    anna_module_const(stack, L"emt", int_type, null_entry, L"The EMT signal");
#endif

#ifdef SIGSTKFLT
    anna_module_const_int(stack, L"stkflt", SIGSTKFLT, L"The STKFLT signal");
#else
    anna_module_const(stack, L"stkflt", int_type, null_entry, L"The STKFLT signal");
#endif

#ifdef SIGIO
    anna_module_const_int(stack, L"io", SIGIO, L"The IO signal");
#else
    anna_module_const(stack, L"io", int_type, null_entry, L"The IO signal");
#endif

#ifdef SIGCLD
    anna_module_const_int(stack, L"cld", SIGCLD, L"The CLD signal");
#else
    anna_module_const(stack, L"cld", int_type, null_entry, L"The CLD signal");
#endif

#ifdef SIGPWR
    anna_module_const_int(stack, L"pwr", SIGPWR, L"The PWR signal");
#else
    anna_module_const(stack, L"pwr", int_type, null_entry, L"The PWR signal");
#endif

#ifdef SIGINFO
    anna_module_const_int(stack, L"info", SIGINFO, L"The INFO signal");
#else
    anna_module_const(stack, L"info", int_type, null_entry, L"The INFO signal");
#endif

#ifdef SIGLOST
    anna_module_const_int(stack, L"lost", SIGLOST, L"The LOST signal");
#else
    anna_module_const(stack, L"lost", int_type, null_entry, L"The LOST signal");
#endif

#ifdef SIGWINCH
    anna_module_const_int(stack, L"winch", SIGWINCH, L"The WINCH signal");
#else
    anna_module_const(stack, L"winch", int_type, null_entry, L"The WINCH signal");
#endif

#ifdef SIGUNUSED
    anna_module_const_int(stack, L"unused", SIGUNUSED, L"The UNUSED signal");
#else
    anna_module_const(stack, L"unused", int_type, null_entry, L"The UNUSED signal");
#endif

    anna_stack_document(stack, L"All known signals");

    anna_type_data_register(anna_signal_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_proc_exec, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_filename = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    size_t native_param_argv_count = anna_list_get_count(anna_as_obj(param[1]));
    char ** native_param_argv = malloc(sizeof(char *) * native_param_argv_count);
    if(!native_param_argv){ return null_entry; }
    int native_param_argv_idx;
    for(native_param_argv_idx=0; native_param_argv_idx < native_param_argv_count; native_param_argv_idx++)
    {
            char *native_param_argv_val = (anna_list_get(anna_as_obj(param[1]), native_param_argv_idx) == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(anna_list_get(anna_as_obj(param[1]), native_param_argv_idx)));

        native_param_argv[native_param_argv_idx] = native_param_argv_val;
    }
    size_t native_param_envp_count = anna_list_get_count(anna_as_obj(param[2]));
    char ** native_param_envp = malloc(sizeof(char *) * native_param_envp_count);
    if(!native_param_envp){ return null_entry; }
    int native_param_envp_idx;
    for(native_param_envp_idx=0; native_param_envp_idx < native_param_envp_count; native_param_envp_idx++)
    {
            char *native_param_envp_val = (anna_list_get(anna_as_obj(param[2]), native_param_envp_idx) == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(anna_list_get(anna_as_obj(param[2]), native_param_envp_idx)));

        native_param_envp[native_param_envp_idx] = native_param_envp_val;
    }

    // Validate parameters

    // Call the function
    int tmp_var_39 = execve(native_param_filename, native_param_argv, native_param_envp);
    anna_entry_t *result = anna_from_int(tmp_var_39);

    // Perform cleanup
    free(native_param_filename);
    for(native_param_argv_idx=0; native_param_argv_idx < native_param_argv_count; native_param_argv_idx++)
    {
            free(native_param_argv[native_param_argv_idx]);

    }
    free(native_param_argv);
    for(native_param_envp_idx=0; native_param_envp_idx < native_param_envp_count; native_param_envp_idx++)
    {
            free(native_param_envp[native_param_envp_idx]);

    }
    free(native_param_envp);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_exit, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_status = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    exit(native_param_status);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_fork, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_40 = fork();
    anna_entry_t *result = anna_from_int(tmp_var_40);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_kill, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    int native_param_sig = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_41 = kill(native_param_pid, native_param_sig);
    anna_entry_t *result = anna_from_int(tmp_var_41);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getsid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_42 = getsid(native_param_pid);
    anna_entry_t *result = anna_from_int(tmp_var_42);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_setsid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_43 = setsid();
    anna_entry_t *result = anna_from_int(tmp_var_43);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getpid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_44 = getpid();
    anna_entry_t *result = anna_from_int(tmp_var_44);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getppid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_45 = getppid();
    anna_entry_t *result = anna_from_int(tmp_var_45);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_wait, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    if(anna_list_ensure_capacity(anna_as_obj(param[0]), 1))
    {
        return null_entry;
    }
    size_t native_param_status_count = anna_list_get_count(anna_as_obj(param[0]));
    int* native_param_status = malloc(sizeof(int) * native_param_status_count);
    if(!native_param_status){ return null_entry; }
    int native_param_status_idx;
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[0]), native_param_status_idx);
        if(tmp == null_entry)
        {
            native_param_status[native_param_status_idx] = 0;
        }
        else
        {
                int native_param_status_val = anna_as_int(tmp);

            native_param_status[native_param_status_idx] = native_param_status_val;
        }
    }

    // Validate parameters

    // Call the function
    int tmp_var_46 = wait(native_param_status);
    anna_entry_t *result = anna_from_int(tmp_var_46);

    // Perform cleanup
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
            anna_entry_t *tmp = anna_from_int(native_param_status[native_param_status_idx]);

        anna_list_set(anna_as_obj(param[0]), native_param_status_idx, tmp);
        
    }
    free(native_param_status);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_waitpid, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), 1))
    {
        return null_entry;
    }
    size_t native_param_status_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_status = malloc(sizeof(int) * native_param_status_count);
    if(!native_param_status){ return null_entry; }
    int native_param_status_idx;
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_status_idx);
        if(tmp == null_entry)
        {
            native_param_status[native_param_status_idx] = 0;
        }
        else
        {
                int native_param_status_val = anna_as_int(tmp);

            native_param_status[native_param_status_idx] = native_param_status_val;
        }
    }
    int native_param_options = anna_as_int(param[2]);

    // Validate parameters

    // Call the function
    int tmp_var_47 = waitpid(native_param_pid, native_param_status, native_param_options);
    anna_entry_t *result = anna_from_int(tmp_var_47);

    // Perform cleanup
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
            anna_entry_t *tmp = anna_from_int(native_param_status[native_param_status_idx]);

        anna_list_set(anna_as_obj(param[1]), native_param_status_idx, tmp);
        
    }
    free(native_param_status);

    // Return result
    return result;
}

static int anna_signalset_set(sigset_t *set, int signal, int value)
{
    if(value)
    {
        sigaddset(set, signal);
    }
    else
    {
        sigdelset(set, signal);
    }
    return value;
}

ANNA_VM_NATIVE(unix_i_signal_set_init, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    sigemptyset(native_param_this);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return param[0];
}

ANNA_VM_NATIVE(unix_i_signal_set_clear, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    int tmp_var_48 = sigemptyset(native_param_this);
    anna_entry_t *result = anna_from_int(tmp_var_48);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_all, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    int tmp_var_49 = sigfillset(native_param_this);
    anna_entry_t *result = anna_from_int(tmp_var_49);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_add, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_50 = sigaddset(native_param_this, native_param_signal);
    anna_entry_t *result = anna_from_int(tmp_var_50);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_remove, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_51 = sigdelset(native_param_this, native_param_signal);
    anna_entry_t *result = anna_from_int(tmp_var_51);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_in, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_52 = sigismember(native_param_this, native_param_signal);
    anna_entry_t *result = (tmp_var_52)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_get, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_53 = sigismember(native_param_this, native_param_signal);
    anna_entry_t *result = (tmp_var_53)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_set, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);
    int native_param_value = (param[2] != null_entry);

    // Validate parameters

    // Call the function
    int tmp_var_54 = anna_signalset_set(native_param_this, native_param_signal, native_param_value);
    anna_entry_t *result = (tmp_var_54)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}
const static anna_type_data_t anna_sigprocmask_flag_type_data[] = 
{
};

void anna_sigprocmask_flag_create(anna_stack_template_t *stack);
void anna_sigprocmask_flag_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_sigprocmask_flag_type_data, stack);        
}
void anna_sigprocmask_flag_load(anna_stack_template_t *stack);
void anna_sigprocmask_flag_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef SIG_BLOCK
    anna_module_const_int(stack, L"block", SIG_BLOCK, L"Block all the specified signals in addition to signals currently blocked.");
#else
    anna_module_const(stack, L"block", int_type, null_entry, L"Block all the specified signals in addition to signals currently blocked.");
#endif

#ifdef SIG_UNBLOCK
    anna_module_const_int(stack, L"unblock", SIG_UNBLOCK, L"Stop blocking the specified signals.");
#else
    anna_module_const(stack, L"unblock", int_type, null_entry, L"Stop blocking the specified signals.");
#endif

#ifdef SIG_SETMASK
    anna_module_const_int(stack, L"setMask", SIG_SETMASK, L"Set the exact new signal block mask.");
#else
    anna_module_const(stack, L"setMask", int_type, null_entry, L"Set the exact new signal block mask.");
#endif

    anna_stack_document(stack, L"Flags determining the mode for unix.iosigprocmask");

    anna_type_data_register(anna_sigprocmask_flag_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_proc_sigprocmask, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_how = anna_as_int(param[0]);
sigset_t *native_param_set;
    native_param_set = ((param[1]) == null_entry) ? 0 : (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);sigset_t *native_param_old;
    native_param_old = ((param[2]) == null_entry) ? 0 : (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_55 = sigprocmask(native_param_how, native_param_set, native_param_old);
    anna_entry_t *result = anna_from_int(tmp_var_55);

    // Perform cleanup

    // Return result
    return result;
}

int anna_read_signal(int fd, struct signalfd_siginfo *info)
{
    return read(fd, info, sizeof(struct signalfd_siginfo)) <= 0;
}

void anna_proc_create(anna_stack_template_t *stack);
void anna_proc_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_proc_type_data, stack);        
}
void anna_proc_load(anna_stack_template_t *stack);
void anna_proc_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"signal", anna_signal_create, anna_signal_load},
            { L"sigprocmaskFlag", anna_sigprocmask_flag_create, anna_sigprocmask_flag_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_proc_exec_argv[] = {string_type, anna_list_type_get_any(string_type), anna_list_type_get_any(string_type)};
    wchar_t *unix_i_proc_exec_argn[] = {L"filename", L"argv", L"envp"};
    latest_function = anna_module_function(stack, L"exec", 0, &unix_i_proc_exec, int_type, 3, unix_i_proc_exec_argv, unix_i_proc_exec_argn, 0, L"Execute the specified program.");

    anna_type_t *unix_i_proc_exit_argv[] = {int_type};
    wchar_t *unix_i_proc_exit_argn[] = {L"status"};
    latest_function = anna_module_function(stack, L"exit", 0, &unix_i_proc_exit, object_type, 1, unix_i_proc_exit_argv, unix_i_proc_exit_argn, 0, L"Terminate the calling process.");

    anna_type_t *unix_i_proc_fork_argv[] = {};
    wchar_t *unix_i_proc_fork_argn[] = {};
    latest_function = anna_module_function(stack, L"fork", 0, &unix_i_proc_fork, int_type, 0, unix_i_proc_fork_argv, unix_i_proc_fork_argn, 0, L"Create a child process.");

    anna_type_t *unix_i_proc_kill_argv[] = {int_type, int_type};
    wchar_t *unix_i_proc_kill_argn[] = {L"pid", L"sig"};
    latest_function = anna_module_function(stack, L"kill", 0, &unix_i_proc_kill, int_type, 2, unix_i_proc_kill_argv, unix_i_proc_kill_argn, 0, L"Send a signal to a process.");

    anna_type_t *unix_i_proc_getsid_argv[] = {int_type};
    wchar_t *unix_i_proc_getsid_argn[] = {L"pid"};
    latest_function = anna_module_function(stack, L"getsid", 0, &unix_i_proc_getsid, int_type, 1, unix_i_proc_getsid_argv, unix_i_proc_getsid_argn, 0, L"Get session ID.");

    anna_type_t *unix_i_proc_setsid_argv[] = {};
    wchar_t *unix_i_proc_setsid_argn[] = {};
    latest_function = anna_module_function(stack, L"setsid", 0, &unix_i_proc_setsid, int_type, 0, unix_i_proc_setsid_argv, unix_i_proc_setsid_argn, 0, L"Set session ID.");

    anna_type_t *unix_i_proc_getpid_argv[] = {};
    wchar_t *unix_i_proc_getpid_argn[] = {};
    latest_function = anna_module_function(stack, L"getpid", 0, &unix_i_proc_getpid, int_type, 0, unix_i_proc_getpid_argv, unix_i_proc_getpid_argn, 0, L"Get process ID.");

    anna_type_t *unix_i_proc_getppid_argv[] = {};
    wchar_t *unix_i_proc_getppid_argn[] = {};
    latest_function = anna_module_function(stack, L"getppid", 0, &unix_i_proc_getppid, int_type, 0, unix_i_proc_getppid_argv, unix_i_proc_getppid_argn, 0, L"Get parent process ID.");

    anna_type_t *unix_i_proc_wait_argv[] = {anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_proc_wait_argn[] = {L"status"};
    latest_function = anna_module_function(stack, L"wait", 0, &unix_i_proc_wait, int_type, 1, unix_i_proc_wait_argv, unix_i_proc_wait_argn, 0, L"Wait for a process to change state.");

    anna_type_t *unix_i_proc_waitpid_argv[] = {int_type, anna_list_type_get_mutable(int_type), int_type};
    wchar_t *unix_i_proc_waitpid_argn[] = {L"pid", L"status", L"options"};
    latest_function = anna_module_function(stack, L"waitpid", 0, &unix_i_proc_waitpid, int_type, 3, unix_i_proc_waitpid_argv, unix_i_proc_waitpid_argn, 0, L"Wait for a process to change state.");

    anna_member_create_blob(unix_signal_set_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(sigset_t));

    anna_type_t *unix_i_signal_set_init_argv[] = {unix_signal_set_type};
    wchar_t *unix_i_signal_set_init_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__init__"), 0, 
        &unix_i_signal_set_init, object_type, 1, unix_i_signal_set_init_argv, unix_i_signal_set_init_argn, 0, L"Create an empty new set");

    anna_type_t *unix_i_signal_set_clear_argv[] = {unix_signal_set_type};
    wchar_t *unix_i_signal_set_clear_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"clear"), 0, 
        &unix_i_signal_set_clear, int_type, 1, unix_i_signal_set_clear_argv, unix_i_signal_set_clear_argn, 0, L"Remove all signals from the set");

    anna_type_t *unix_i_signal_set_all_argv[] = {unix_signal_set_type};
    wchar_t *unix_i_signal_set_all_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"all"), 0, 
        &unix_i_signal_set_all, int_type, 1, unix_i_signal_set_all_argv, unix_i_signal_set_all_argn, 0, L"Add all signals to the set");

    anna_type_t *unix_i_signal_set_add_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_add_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"add"), 0, 
        &unix_i_signal_set_add, int_type, 2, unix_i_signal_set_add_argv, unix_i_signal_set_add_argn, 0, L"Add the specified signal to the set");

    anna_type_t *unix_i_signal_set_remove_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_remove_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"remove"), 0, 
        &unix_i_signal_set_remove, int_type, 2, unix_i_signal_set_remove_argv, unix_i_signal_set_remove_argn, 0, L"Remove the specified signal from the set.");

    anna_type_t *unix_i_signal_set_in_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_in_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__in__"), 0, 
        &unix_i_signal_set_in, object_type, 2, unix_i_signal_set_in_argv, unix_i_signal_set_in_argn, 0, L"Check if the specified signal is in the set");

    anna_type_t *unix_i_signal_set_get_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_get_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__get__"), 0, 
        &unix_i_signal_set_get, object_type, 2, unix_i_signal_set_get_argv, unix_i_signal_set_get_argn, 0, L"Check if the specified signal is in the set");

    anna_type_t *unix_i_signal_set_set_argv[] = {unix_signal_set_type, int_type, object_type};
    wchar_t *unix_i_signal_set_set_argn[] = {L"this", L"signal", L"value"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__set__"), 0, 
        &unix_i_signal_set_set, object_type, 3, unix_i_signal_set_set_argv, unix_i_signal_set_set_argn, 0, L"If value is non-null, add the specified signal to the set. Otherwise, remove it.");
    anna_type_document(
            unix_signal_set_type, L"A set of signals. Used by the unix.proc.signalfd and unix.proc.sigprocmask functions.");

    anna_type_t *unix_i_proc_sigprocmask_argv[] = {int_type, unix_signal_set_type, unix_signal_set_type};
    wchar_t *unix_i_proc_sigprocmask_argn[] = {L"how", L"set", L"old"};
    latest_function = anna_module_function(stack, L"sigprocmask", 0, &unix_i_proc_sigprocmask, int_type, 3, unix_i_proc_sigprocmask_argv, unix_i_proc_sigprocmask_argn, 0, L"Examine and change what signals are currently blocked by this process.");
    anna_stack_document(stack, L"The unix.proc module contains low level wrappers for basic unix functionality revolving around processes and signals.");

    anna_type_data_register(anna_proc_type_data, stack);
}
const static anna_type_data_t anna_user_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_user_getuid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_56 = getuid();
    anna_entry_t *result = anna_from_int(tmp_var_56);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_geteuid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_57 = geteuid();
    anna_entry_t *result = anna_from_int(tmp_var_57);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getgid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_58 = getgid();
    anna_entry_t *result = anna_from_int(tmp_var_58);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getegid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_59 = getegid();
    anna_entry_t *result = anna_from_int(tmp_var_59);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setuid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_60 = setuid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_60);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_seteuid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_61 = seteuid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_61);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setegid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_62 = setegid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_62);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setgid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_63 = setgid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_63);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setpgid, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    int native_param_pgid = anna_as_int(param[1]);

    // Validate parameters

    // Call the function
    int tmp_var_64 = setpgid(native_param_pid, native_param_pgid);
    anna_entry_t *result = anna_from_int(tmp_var_64);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getpgid, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_65 = getpgid(native_param_pid);
    anna_entry_t *result = anna_from_int(tmp_var_65);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getgroups, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_size = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), native_param_size))
    {
        return null_entry;
    }
    size_t native_param_list_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_list = malloc(sizeof(int) * native_param_list_count);
    if(!native_param_list){ return null_entry; }
    int native_param_list_idx;
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_list_idx);
        if(tmp == null_entry)
        {
            native_param_list[native_param_list_idx] = 0;
        }
        else
        {
                int native_param_list_val = anna_as_int(tmp);

            native_param_list[native_param_list_idx] = native_param_list_val;
        }
    }

    // Validate parameters

    // Call the function
    int tmp_var_66 = getgroups(native_param_size, native_param_list);
    anna_entry_t *result = anna_from_int(tmp_var_66);

    // Perform cleanup
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
            anna_entry_t *tmp = anna_from_int(native_param_list[native_param_list_idx]);

        anna_list_set(anna_as_obj(param[1]), native_param_list_idx, tmp);
        
    }
    free(native_param_list);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setgroups, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_size = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), native_param_size))
    {
        return null_entry;
    }
    size_t native_param_list_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_list = malloc(sizeof(int) * native_param_list_count);
    if(!native_param_list){ return null_entry; }
    int native_param_list_idx;
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_list_idx);
        if(tmp == null_entry)
        {
            native_param_list[native_param_list_idx] = 0;
        }
        else
        {
                int native_param_list_val = anna_as_int(tmp);

            native_param_list[native_param_list_idx] = native_param_list_val;
        }
    }

    // Validate parameters

    // Call the function
    int tmp_var_67 = setgroups(native_param_size, native_param_list);
    anna_entry_t *result = anna_from_int(tmp_var_67);

    // Perform cleanup
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
            anna_entry_t *tmp = anna_from_int(native_param_list[native_param_list_idx]);

        anna_list_set(anna_as_obj(param[1]), native_param_list_idx, tmp);
        
    }
    free(native_param_list);

    // Return result
    return result;
}

void anna_user_create(anna_stack_template_t *stack);
void anna_user_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_user_type_data, stack);        
}
void anna_user_load(anna_stack_template_t *stack);
void anna_user_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_user_getuid_argv[] = {};
    wchar_t *unix_i_user_getuid_argn[] = {};
    latest_function = anna_module_function(stack, L"getuid", 0, &unix_i_user_getuid, int_type, 0, unix_i_user_getuid_argv, unix_i_user_getuid_argn, 0, L"Get the real user ID of the calling process.");

    anna_type_t *unix_i_user_geteuid_argv[] = {};
    wchar_t *unix_i_user_geteuid_argn[] = {};
    latest_function = anna_module_function(stack, L"geteuid", 0, &unix_i_user_geteuid, int_type, 0, unix_i_user_geteuid_argv, unix_i_user_geteuid_argn, 0, L"Get the effective user ID of the calling process.");

    anna_type_t *unix_i_user_getgid_argv[] = {};
    wchar_t *unix_i_user_getgid_argn[] = {};
    latest_function = anna_module_function(stack, L"getgid", 0, &unix_i_user_getgid, int_type, 0, unix_i_user_getgid_argv, unix_i_user_getgid_argn, 0, L"Get the real group ID of the calling process.");

    anna_type_t *unix_i_user_getegid_argv[] = {};
    wchar_t *unix_i_user_getegid_argn[] = {};
    latest_function = anna_module_function(stack, L"getegid", 0, &unix_i_user_getegid, int_type, 0, unix_i_user_getegid_argv, unix_i_user_getegid_argn, 0, L"Get the effective group ID of the calling process.");

    anna_type_t *unix_i_user_setuid_argv[] = {int_type};
    wchar_t *unix_i_user_setuid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"setuid", 0, &unix_i_user_setuid, int_type, 1, unix_i_user_setuid_argv, unix_i_user_setuid_argn, 0, L"Set the effective user ID of the calling process. If the calling user is root, the real user ID is also set.");

    anna_type_t *unix_i_user_seteuid_argv[] = {int_type};
    wchar_t *unix_i_user_seteuid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"seteuid", 0, &unix_i_user_seteuid, int_type, 1, unix_i_user_seteuid_argv, unix_i_user_seteuid_argn, 0, L"Set the effective user ID of the calling process.");

    anna_type_t *unix_i_user_setegid_argv[] = {int_type};
    wchar_t *unix_i_user_setegid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"setegid", 0, &unix_i_user_setegid, int_type, 1, unix_i_user_setegid_argv, unix_i_user_setegid_argn, 0, L"Set the effective group ID of the calling process.");

    anna_type_t *unix_i_user_setgid_argv[] = {int_type};
    wchar_t *unix_i_user_setgid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"setgid", 0, &unix_i_user_setgid, int_type, 1, unix_i_user_setgid_argv, unix_i_user_setgid_argn, 0, L"Set the effective group ID of the calling process. If the calling user is root, the real group ID is also set.");

    anna_type_t *unix_i_user_setpgid_argv[] = {int_type, int_type};
    wchar_t *unix_i_user_setpgid_argn[] = {L"pid", L"pgid"};
    latest_function = anna_module_function(stack, L"setpgid", 0, &unix_i_user_setpgid, int_type, 2, unix_i_user_setpgid_argv, unix_i_user_setpgid_argn, 0, L"Set process group.");

    anna_type_t *unix_i_user_getpgid_argv[] = {int_type};
    wchar_t *unix_i_user_getpgid_argn[] = {L"pid"};
    latest_function = anna_module_function(stack, L"getpgid", 0, &unix_i_user_getpgid, int_type, 1, unix_i_user_getpgid_argv, unix_i_user_getpgid_argn, 0, L"Get process group.");

    anna_type_t *unix_i_user_getgroups_argv[] = {int_type, anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_user_getgroups_argn[] = {L"size", L"list"};
    latest_function = anna_module_function(stack, L"getgroups", 0, &unix_i_user_getgroups, int_type, 2, unix_i_user_getgroups_argv, unix_i_user_getgroups_argn, 0, L"Get list of supplamentary group IDs.");

    anna_type_t *unix_i_user_setgroups_argv[] = {int_type, anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_user_setgroups_argn[] = {L"size", L"list"};
    latest_function = anna_module_function(stack, L"setgroups", 0, &unix_i_user_setgroups, int_type, 2, unix_i_user_setgroups_argv, unix_i_user_setgroups_argn, 0, L"Set list of supplamentary group IDs.");
    anna_stack_document(stack, L"The unix.user module contains low level wrappers for basic unix functionality revolving around users and groups.");

    anna_type_data_register(anna_user_type_data, stack);
}
const static anna_type_data_t anna_r_limit_type_data[] = 
{
    { &unix_r_limit_type, L"RLimit" },
};
const static anna_type_data_t anna_r_limit_mode_type_data[] = 
{
};

void anna_r_limit_mode_create(anna_stack_template_t *stack);
void anna_r_limit_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_r_limit_mode_type_data, stack);        
}
void anna_r_limit_mode_load(anna_stack_template_t *stack);
void anna_r_limit_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef RLIMIT_AS
    anna_module_const_int(stack, L"as", RLIMIT_AS, L"The AS limit");
#else
    anna_module_const(stack, L"as", int_type, null_entry, L"The AS limit");
#endif

#ifdef RLIMIT_CORE
    anna_module_const_int(stack, L"core", RLIMIT_CORE, L"The CORE limit");
#else
    anna_module_const(stack, L"core", int_type, null_entry, L"The CORE limit");
#endif

#ifdef RLIMIT_CPU
    anna_module_const_int(stack, L"cpu", RLIMIT_CPU, L"The CPU limit");
#else
    anna_module_const(stack, L"cpu", int_type, null_entry, L"The CPU limit");
#endif

#ifdef RLIMIT_DATA
    anna_module_const_int(stack, L"data", RLIMIT_DATA, L"The DATA limit");
#else
    anna_module_const(stack, L"data", int_type, null_entry, L"The DATA limit");
#endif

#ifdef RLIMIT_FSIZE
    anna_module_const_int(stack, L"fsize", RLIMIT_FSIZE, L"The FSIZE limit");
#else
    anna_module_const(stack, L"fsize", int_type, null_entry, L"The FSIZE limit");
#endif

#ifdef RLIMIT_MEMLOCK
    anna_module_const_int(stack, L"memlock", RLIMIT_MEMLOCK, L"The MEMLOCK limit");
#else
    anna_module_const(stack, L"memlock", int_type, null_entry, L"The MEMLOCK limit");
#endif

#ifdef RLIMIT_MSGQUEUE
    anna_module_const_int(stack, L"msgqueue", RLIMIT_MSGQUEUE, L"The MSGQUEUE limit");
#else
    anna_module_const(stack, L"msgqueue", int_type, null_entry, L"The MSGQUEUE limit");
#endif

#ifdef RLIMIT_NICE
    anna_module_const_int(stack, L"nice", RLIMIT_NICE, L"The NICE limit");
#else
    anna_module_const(stack, L"nice", int_type, null_entry, L"The NICE limit");
#endif

#ifdef RLIMIT_NOFILE
    anna_module_const_int(stack, L"nofile", RLIMIT_NOFILE, L"The NOFILE limit");
#else
    anna_module_const(stack, L"nofile", int_type, null_entry, L"The NOFILE limit");
#endif

#ifdef RLIMIT_NPROC
    anna_module_const_int(stack, L"nproc", RLIMIT_NPROC, L"The NPROC limit");
#else
    anna_module_const(stack, L"nproc", int_type, null_entry, L"The NPROC limit");
#endif

#ifdef RLIMIT_RSS
    anna_module_const_int(stack, L"rss", RLIMIT_RSS, L"The RSS limit");
#else
    anna_module_const(stack, L"rss", int_type, null_entry, L"The RSS limit");
#endif

#ifdef RLIMIT_RTPRIO
    anna_module_const_int(stack, L"rtprio", RLIMIT_RTPRIO, L"The RTPRIO limit");
#else
    anna_module_const(stack, L"rtprio", int_type, null_entry, L"The RTPRIO limit");
#endif

#ifdef RLIMIT_RTTIME
    anna_module_const_int(stack, L"rttime", RLIMIT_RTTIME, L"The RTTIME limit");
#else
    anna_module_const(stack, L"rttime", int_type, null_entry, L"The RTTIME limit");
#endif

#ifdef RLIMIT_SIGPENDING
    anna_module_const_int(stack, L"sigpending", RLIMIT_SIGPENDING, L"The SIGPENDING limit");
#else
    anna_module_const(stack, L"sigpending", int_type, null_entry, L"The SIGPENDING limit");
#endif

#ifdef RLIMIT_STACK
    anna_module_const_int(stack, L"stack", RLIMIT_STACK, L"The STACK limit");
#else
    anna_module_const(stack, L"stack", int_type, null_entry, L"The STACK limit");
#endif

    anna_stack_document(stack, L"The different limits that can be queried with getRLimit and stRLimit.");

    anna_type_data_register(anna_r_limit_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_r_limit_cur_getter, 1)
{
    struct rlimit *data;
    data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->rlim_cur);

    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_max_getter, 1)
{
    struct rlimit *data;
    data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->rlim_max);

    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_init, 1)
{
    struct rlimit *data;
    data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct rlimit));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_r_limit_get_r_limit, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_resource = anna_as_int(param[0]);
struct rlimit *native_param_rlim;
    native_param_rlim = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_68 = getrlimit(native_param_resource, native_param_rlim);
    anna_entry_t *result = anna_from_int(tmp_var_68);

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_set_r_limit, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_resource = anna_as_int(param[0]);
struct rlimit *native_param_rlim;
    native_param_rlim = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_69 = setrlimit(native_param_resource, native_param_rlim);
    anna_entry_t *result = anna_from_int(tmp_var_69);

    // Perform cleanup

    // Return result
    return result;
}

void anna_r_limit_create(anna_stack_template_t *stack);
void anna_r_limit_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_r_limit_type_data, stack);        
}
void anna_r_limit_load(anna_stack_template_t *stack);
void anna_r_limit_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"rLimitMode", anna_r_limit_mode_create, anna_r_limit_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_r_limit_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct rlimit));

    anna_member_create_native_property(
        unix_r_limit_type, anna_mid_get(L"cur"),
        int_type, unix_i_r_limit_cur_getter, 0, L"Currently enforced limit (soft limit)");

    anna_member_create_native_property(
        unix_r_limit_type, anna_mid_get(L"max"),
        int_type, unix_i_r_limit_max_getter, 0, L"Maximum value of limit (hard limit)");
    anna_member_create_native_method(
	unix_r_limit_type, anna_mid_get(L"__init__"), 0,
	&unix_i_r_limit_init, object_type, 1, &unix_r_limit_type, this_argn, 0, 0);    
    anna_type_document(
            unix_r_limit_type, L"A structure representing the current and maximum value of a system resource usage limit.");

    anna_type_t *unix_i_r_limit_get_r_limit_argv[] = {int_type, unix_r_limit_type};
    wchar_t *unix_i_r_limit_get_r_limit_argn[] = {L"resource", L"rlim"};
    latest_function = anna_module_function(stack, L"getRLimit", 0, &unix_i_r_limit_get_r_limit, int_type, 2, unix_i_r_limit_get_r_limit_argv, unix_i_r_limit_get_r_limit_argn, 0, L"Get resource limit.");

    anna_type_t *unix_i_r_limit_set_r_limit_argv[] = {int_type, unix_r_limit_type};
    wchar_t *unix_i_r_limit_set_r_limit_argn[] = {L"resource", L"rlim"};
    latest_function = anna_module_function(stack, L"setRLimit", 0, &unix_i_r_limit_set_r_limit, int_type, 2, unix_i_r_limit_set_r_limit_argv, unix_i_r_limit_set_r_limit_argn, 0, L"Set resource limit.");
    anna_stack_document(stack, L"The unix.rLimit module contains low level wrappers for basic unix functionality revolving around system resource limits.");

    anna_type_data_register(anna_r_limit_type_data, stack);
}
const static anna_type_data_t anna_env_type_data[] = 
{
};

#define ANNA_SETENV(name, value) setenv(name, value, 1)

ANNA_VM_NATIVE(unix_i_env_get, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters

    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);
    // Call the function
    char * tmp_var_70 = getenv(native_param_name);
    anna_entry_t *result = (tmp_var_70) ? anna_from_obj(anna_string_create_narrow(strlen(tmp_var_70), tmp_var_70)) : null_entry;

    // Perform cleanup
    free(native_param_name);

    pthread_mutex_unlock(&lock);
    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_set2, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_value = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));
    int native_param_overwrite = (param[2] != null_entry);

    // Validate parameters

    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);
    // Call the function
    int tmp_var_71 = setenv(native_param_name, native_param_value, native_param_overwrite);
    anna_entry_t *result = anna_from_int(tmp_var_71);

    // Perform cleanup
    free(native_param_name);
    free(native_param_value);

    pthread_mutex_unlock(&lock);
    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_set, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_value = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters

    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);
    // Call the function
    int tmp_var_72 = ANNA_SETENV(native_param_name, native_param_value);
    anna_entry_t *result = anna_from_int(tmp_var_72);

    // Perform cleanup
    free(native_param_name);
    free(native_param_value);

    pthread_mutex_unlock(&lock);
    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_remove, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters

    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);
    // Call the function
    int tmp_var_73 = unsetenv(native_param_name);
    anna_entry_t *result = anna_from_int(tmp_var_73);

    // Perform cleanup
    free(native_param_name);

    pthread_mutex_unlock(&lock);
    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_clear, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);
    // Call the function
    int tmp_var_74 = clearenv();
    anna_entry_t *result = anna_from_int(tmp_var_74);

    // Perform cleanup

    pthread_mutex_unlock(&lock);
    // Return result
    return result;
}

void anna_env_create(anna_stack_template_t *stack);
void anna_env_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_env_type_data, stack);        
}
void anna_env_load(anna_stack_template_t *stack);
void anna_env_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_env_get_argv[] = {string_type};
    wchar_t *unix_i_env_get_argn[] = {L"name"};
    latest_function = anna_module_function(stack, L"__get__", 0, &unix_i_env_get, string_type, 1, unix_i_env_get_argv, unix_i_env_get_argn, 0, L"Return the current value of the given environment variable. Equivalanet to the C getenv function.");

    anna_type_t *unix_i_env_set2_argv[] = {string_type, string_type, object_type};
    wchar_t *unix_i_env_set2_argn[] = {L"name", L"value", L"overwrite"};
    latest_function = anna_module_function(stack, L"set2", 0, &unix_i_env_set2, int_type, 3, unix_i_env_set2_argv, unix_i_env_set2_argn, 0, L"Assign a new value to the environment variable with the given name. Equivalanet to the C setenv function.");

    anna_type_t *unix_i_env_set_argv[] = {string_type, string_type};
    wchar_t *unix_i_env_set_argn[] = {L"name", L"value"};
    latest_function = anna_module_function(stack, L"__set__", 0, &unix_i_env_set, int_type, 2, unix_i_env_set_argv, unix_i_env_set_argn, 0, L"Assign a new value to the environment variable with the given name. Equivalanet to the C setenv function.");

    anna_type_t *unix_i_env_remove_argv[] = {string_type};
    wchar_t *unix_i_env_remove_argn[] = {L"name"};
    latest_function = anna_module_function(stack, L"remove", 0, &unix_i_env_remove, int_type, 1, unix_i_env_remove_argv, unix_i_env_remove_argn, 0, L"Clear the specified environment variable. Equivalanet to the C unsetenv function.");

    anna_type_t *unix_i_env_clear_argv[] = {};
    wchar_t *unix_i_env_clear_argn[] = {};
    latest_function = anna_module_function(stack, L"clear", 0, &unix_i_env_clear, int_type, 0, unix_i_env_clear_argv, unix_i_env_clear_argn, 0, L"Removes all environemnt variables. Equivalanet to the C clearenv function.");
    anna_stack_document(stack, L"The unix.env module contains low level wrappers for basic unix functionality revolving around environment variables.");

    anna_type_data_register(anna_env_type_data, stack);
}
const static anna_type_data_t anna_sleep_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_sleep_sleep, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_seconds = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    int tmp_var_75 = sleep(native_param_seconds);
    anna_entry_t *result = anna_from_int(tmp_var_75);

    // Perform cleanup

    // Return result
    return result;
}

void anna_sleep_create(anna_stack_template_t *stack);
void anna_sleep_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_sleep_type_data, stack);        
}
void anna_sleep_load(anna_stack_template_t *stack);
void anna_sleep_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_sleep_sleep_argv[] = {int_type};
    wchar_t *unix_i_sleep_sleep_argn[] = {L"seconds"};
    latest_function = anna_module_function(stack, L"sleep", 0, &unix_i_sleep_sleep, int_type, 1, unix_i_sleep_sleep_argv, unix_i_sleep_sleep_argn, 0, L"Sleep for the specified number of seconds");
    anna_stack_document(stack, L"The unix.sleep module contains low level wrappers for basic unix functionality revolving around pausing the execution of processes.");

    anna_type_data_register(anna_sleep_type_data, stack);
}
const static anna_type_data_t anna_locale_type_data[] = 
{
    { &unix_locale_conv_type, L"LocaleConv" },
};
const static anna_type_data_t anna_locale_mode_type_data[] = 
{
};

void anna_locale_mode_create(anna_stack_template_t *stack);
void anna_locale_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_locale_mode_type_data, stack);        
}
void anna_locale_mode_load(anna_stack_template_t *stack);
void anna_locale_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef LC_ALL
    anna_module_const_int(stack, L"all", LC_ALL, L"All of the locale.");
#else
    anna_module_const(stack, L"all", int_type, null_entry, L"All of the locale.");
#endif

#ifdef LC_COLLATE
    anna_module_const_int(stack, L"collate", LC_COLLATE, L"Regular expression matching (it determines the meaning of range expressions and equivalence classes) and string collation.");
#else
    anna_module_const(stack, L"collate", int_type, null_entry, L"Regular expression matching (it determines the meaning of range expressions and equivalence classes) and string collation.");
#endif

#ifdef LC_CTYPE
    anna_module_const_int(stack, L"cType", LC_CTYPE, L"Regular expression matching, character classification, conversion, case-sensitive comparison, and wide character functions.");
#else
    anna_module_const(stack, L"cType", int_type, null_entry, L"Regular expression matching, character classification, conversion, case-sensitive comparison, and wide character functions.");
#endif

#ifdef LC_MESSAGES
    anna_module_const_int(stack, L"messages", LC_MESSAGES, L"Localizable natural-language messages.");
#else
    anna_module_const(stack, L"messages", int_type, null_entry, L"Localizable natural-language messages.");
#endif

#ifdef LC_MONETARY
    anna_module_const_int(stack, L"monetary", LC_MONETARY, L"Monetary formating.");
#else
    anna_module_const(stack, L"monetary", int_type, null_entry, L"Monetary formating.");
#endif

#ifdef LC_NUMERIC
    anna_module_const_int(stack, L"numeric", LC_NUMERIC, L"Numeric formating, such as decimal point and thousands separator.");
#else
    anna_module_const(stack, L"numeric", int_type, null_entry, L"Numeric formating, such as decimal point and thousands separator.");
#endif

#ifdef LC_TIME
    anna_module_const_int(stack, L"time", LC_TIME, L"Date and time formating.");
#else
    anna_module_const(stack, L"time", int_type, null_entry, L"Date and time formating.");
#endif

    anna_stack_document(stack, L"Different locale parts.");

    anna_type_data_register(anna_locale_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_locale_set_locale, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_cateory = anna_as_int(param[0]);
    char *native_param_locale = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters

    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&lock);
    // Call the function
    char * tmp_var_76 = setlocale(native_param_cateory, native_param_locale);
    anna_entry_t *result = (tmp_var_76) ? anna_from_obj(anna_string_create_narrow(strlen(tmp_var_76), tmp_var_76)) : null_entry;

    // Perform cleanup
    free(native_param_locale);

    pthread_mutex_unlock(&lock);
    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_decimal_point_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->decimal_point) ? anna_from_obj(anna_string_create_narrow(strlen(data->decimal_point), data->decimal_point)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_thousands_separator_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->thousands_sep) ? anna_from_obj(anna_string_create_narrow(strlen(data->thousands_sep), data->thousands_sep)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_grouping_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->grouping) ? anna_from_obj(anna_string_create_narrow(strlen(data->grouping), data->grouping)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_international_currency_symbol_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->int_curr_symbol) ? anna_from_obj(anna_string_create_narrow(strlen(data->int_curr_symbol), data->int_curr_symbol)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_currency_symbol_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->currency_symbol) ? anna_from_obj(anna_string_create_narrow(strlen(data->currency_symbol), data->currency_symbol)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_monetary_decimal_point_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->mon_decimal_point) ? anna_from_obj(anna_string_create_narrow(strlen(data->mon_decimal_point), data->mon_decimal_point)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_monetary_thousands_separator_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->mon_thousands_sep) ? anna_from_obj(anna_string_create_narrow(strlen(data->mon_thousands_sep), data->mon_thousands_sep)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_monetary_grouping_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->mon_grouping) ? anna_from_obj(anna_string_create_narrow(strlen(data->mon_grouping), data->mon_grouping)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_sign_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->positive_sign) ? anna_from_obj(anna_string_create_narrow(strlen(data->positive_sign), data->positive_sign)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_sign_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->negative_sign) ? anna_from_obj(anna_string_create_narrow(strlen(data->negative_sign), data->negative_sign)) : null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_international_frac_digits_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->int_frac_digits);

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_frac_digits_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->frac_digits);

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_currency_symbol_precedes_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->p_cs_precedes)?anna_from_int(1):null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_currency_symbol_precedes_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->n_cs_precedes)?anna_from_int(1):null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_separate_by_space_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->p_sep_by_space)?anna_from_int(1):null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_separate_by_space_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = (data->n_sep_by_space)?anna_from_int(1):null_entry;

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_sign_position_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->p_sign_posn);

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_sign_position_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->n_sign_posn);

    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_init, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct lconv));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_locale_locale_conv, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    struct lconv * tmp_var_77 = localeconv();
anna_entry_t *result = anna_from_obj(anna_object_create(unix_locale_conv_type));
    *((struct lconv **)anna_entry_get_addr(anna_as_obj_fast(result), ANNA_MID_CSTRUCT_PAYLOAD)) = tmp_var_77;
    // Perform cleanup

    // Return result
    return result;
}

void anna_locale_create(anna_stack_template_t *stack);
void anna_locale_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_locale_type_data, stack);        
}
void anna_locale_load(anna_stack_template_t *stack);
void anna_locale_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"localeMode", anna_locale_mode_create, anna_locale_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_locale_set_locale_argv[] = {int_type, string_type};
    wchar_t *unix_i_locale_set_locale_argn[] = {L"cateory", L"locale"};
    latest_function = anna_module_function(stack, L"setLocale", 0, &unix_i_locale_set_locale, string_type, 2, unix_i_locale_set_locale_argv, unix_i_locale_set_locale_argn, 0, L"Set the specified local category to the specified value");

    anna_member_create_blob(unix_locale_conv_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct lconv *));

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"decimalPoint"),
        string_type, unix_i_locale_conv_decimal_point_getter, 0, L"Decimal-point separator used for non-monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"thousandsSeparator"),
        string_type, unix_i_locale_conv_thousands_separator_getter, 0, L"Separators used to delimit groups of digits to the left of the decimal point for non-monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"grouping"),
        string_type, unix_i_locale_conv_grouping_getter, 0, L"The amount of digits that form each of the groups to be separated by thousandsSeparator separator for non-monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"internationalCurrencySymbol"),
        string_type, unix_i_locale_conv_international_currency_symbol_getter, 0, L"International currency symbol.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"currencySymbol"),
        string_type, unix_i_locale_conv_currency_symbol_getter, 0, L"Local currency symbol.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"monetaryDecimalPoint"),
        string_type, unix_i_locale_conv_monetary_decimal_point_getter, 0, L"Decimal-point separator used for monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"monetaryThousandsSeparator"),
        string_type, unix_i_locale_conv_monetary_thousands_separator_getter, 0, L"Separators used to delimit groups of digits to the left of the decimal point for monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"monetaryGrouping"),
        string_type, unix_i_locale_conv_monetary_grouping_getter, 0, L"The amount of digits that form each of the groups to be separated by monetaryThousandsSeparator separator for monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveSign"),
        string_type, unix_i_locale_conv_positive_sign_getter, 0, L"Sign for positive values");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeSign"),
        string_type, unix_i_locale_conv_negative_sign_getter, 0, L"Sign for negative values");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"internationalFracDigits"),
        int_type, unix_i_locale_conv_international_frac_digits_getter, 0, L"International fractional digits.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"fracDigits"),
        int_type, unix_i_locale_conv_frac_digits_getter, 0, L"Local fractional digits.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveCurrencySymbolPrecedes"),
        object_type, unix_i_locale_conv_positive_currency_symbol_precedes_getter, 0, L"1 if currencySymbol precedes a positive value, null if succeeds.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeCurrencySymbolPrecedes"),
        object_type, unix_i_locale_conv_negative_currency_symbol_precedes_getter, 0, L"1 if currencySymbol precedes a negative value, null if succeeds.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveSeparateBySpace"),
        object_type, unix_i_locale_conv_positive_separate_by_space_getter, 0, L"1 if a space separates currency_symbol from a positive value, null otherwise.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeSeparateBySpace"),
        object_type, unix_i_locale_conv_negative_separate_by_space_getter, 0, L"1 if a space separates currency_symbol from a negative value, null otherwise.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveSignPosition"),
        int_type, unix_i_locale_conv_positive_sign_position_getter, 0, L"\nPositive and negative sign positions:\n<ul>\n<li>0: Parentheses surround the quantity and currency_symbol.</li>\n<li>1: The sign string precedes the quantity and currency_symbol.</li>\n<li>2: The sign string succeeds the quantity and currency_symbol.</li>\n<li>3: The sign string immediately precedes the currency_symbol.</li>\n<li>4: The sign string immediately succeeds the currency_symbol.</li>\n</ul>\n");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeSignPosition"),
        int_type, unix_i_locale_conv_negative_sign_position_getter, 0, L"\nPositive and negative sign positions:\n<ul>\n<li>0: Parentheses surround the quantity and currency_symbol.</li>\n<li>1: The sign string precedes the quantity and currency_symbol.</li>\n<li>2: The sign string succeeds the quantity and currency_symbol.</li>\n<li>3: The sign string immediately precedes the currency_symbol.</li>\n<li>4: The sign string immediately succeeds the currency_symbol.</li>\n</ul>\n");
    anna_member_create_native_method(
	unix_locale_conv_type, anna_mid_get(L"__init__"), 0,
	&unix_i_locale_conv_init, object_type, 1, &unix_locale_conv_type, this_argn, 0, 0);    
    anna_type_document(
            unix_locale_conv_type, L"Detailed local information regarding numeric formating.");

    anna_type_t *unix_i_locale_locale_conv_argv[] = {};
    wchar_t *unix_i_locale_locale_conv_argn[] = {};
    latest_function = anna_module_function(stack, L"localeConv", 0, &unix_i_locale_locale_conv, unix_locale_conv_type, 0, unix_i_locale_locale_conv_argv, unix_i_locale_locale_conv_argn, 0, L"Get current numeric formatting information.");
    anna_stack_document(stack, L"The unix.locale module contains low level wrappers for basic unix functionality revolving around localization.");

    anna_type_data_register(anna_locale_type_data, stack);
}
const static anna_type_data_t anna_term_type_data[] = 
{
    { &unix_termios_type, L"Termios" },
};
const static anna_type_data_t anna_flag_type_data[] = 
{
};

void anna_flag_create(anna_stack_template_t *stack);
void anna_flag_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_flag_type_data, stack);        
}
void anna_flag_load(anna_stack_template_t *stack);
void anna_flag_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef ICANON
    anna_module_const_int(stack, L"canonical", ICANON, L"Read one character at a time.");
#else
    anna_module_const(stack, L"canonical", int_type, null_entry, L"Read one character at a time.");
#endif

#ifdef ECHO
    anna_module_const_int(stack, L"echo", ECHO, L"Echo characters to the screen.");
#else
    anna_module_const(stack, L"echo", int_type, null_entry, L"Echo characters to the screen.");
#endif

    anna_stack_document(stack, L"The different modes of a Termios structure.");

    anna_type_data_register(anna_flag_type_data, stack);
}
const static anna_type_data_t anna_action_type_data[] = 
{
};

void anna_action_create(anna_stack_template_t *stack);
void anna_action_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_action_type_data, stack);        
}
void anna_action_load(anna_stack_template_t *stack);
void anna_action_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef TCSANOW
    anna_module_const_int(stack, L"now", TCSANOW, L"Take the specified action now,");
#else
    anna_module_const(stack, L"now", int_type, null_entry, L"Take the specified action now,");
#endif

#ifdef TCSADRAIN
    anna_module_const_int(stack, L"drain", TCSADRAIN, L"Empty output buffer and apply specified action.");
#else
    anna_module_const(stack, L"drain", int_type, null_entry, L"Empty output buffer and apply specified action.");
#endif

#ifdef TCSAFLUSH
    anna_module_const_int(stack, L"flush", TCSAFLUSH, L"Apply specified action once outout in buffer has been written.");
#else
    anna_module_const(stack, L"flush", int_type, null_entry, L"Apply specified action once outout in buffer has been written.");
#endif

    anna_stack_document(stack, L"The different action modes used by unix.term.setAttr.");

    anna_type_data_register(anna_action_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_termios_iflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->c_iflag);

    return result;
}

ANNA_VM_NATIVE(unix_i_termios_iflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        int tmp = anna_as_int(param[1]);

    data->c_iflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_oflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->c_oflag);

    return result;
}

ANNA_VM_NATIVE(unix_i_termios_oflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        int tmp = anna_as_int(param[1]);

    data->c_oflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_cflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->c_cflag);

    return result;
}

ANNA_VM_NATIVE(unix_i_termios_cflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        int tmp = anna_as_int(param[1]);

    data->c_cflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_lflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        anna_entry_t *result = anna_from_int(data->c_lflag);

    return result;
}

ANNA_VM_NATIVE(unix_i_termios_lflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
        int tmp = anna_as_int(param[1]);

    data->c_lflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_init, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct termios));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_term_get_attr, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
struct termios *native_param_ios;
    native_param_ios = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_78 = tcgetattr(native_param_fd, native_param_ios);
    anna_entry_t *result = (tmp_var_78)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_term_set_attr, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
    if(param[1] == null_entry){return null_entry;}
    if(param[2] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_actions = anna_as_int(param[1]);
struct termios *native_param_ios;
    native_param_ios = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);
    // Validate parameters

    // Call the function
    int tmp_var_79 = tcsetattr(native_param_fd, native_param_actions, native_param_ios);
    anna_entry_t *result = (tmp_var_79)?anna_from_int(1):null_entry;

    // Perform cleanup

    // Return result
    return result;
}

void anna_term_create(anna_stack_template_t *stack);
void anna_term_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_term_type_data, stack);        
}
void anna_term_load(anna_stack_template_t *stack);
void anna_term_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"flag", anna_flag_create, anna_flag_load},
            { L"action", anna_action_create, anna_action_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_termios_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct termios));

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"iflag"),
        int_type, unix_i_termios_iflag_getter, unix_i_termios_iflag_setter, L"Input modes");

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"oflag"),
        int_type, unix_i_termios_oflag_getter, unix_i_termios_oflag_setter, L"Output modes");

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"cflag"),
        int_type, unix_i_termios_cflag_getter, unix_i_termios_cflag_setter, L"Control modes");

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"lflag"),
        int_type, unix_i_termios_lflag_getter, unix_i_termios_lflag_setter, L"Local modes");
    anna_member_create_native_method(
	unix_termios_type, anna_mid_get(L"__init__"), 0,
	&unix_i_termios_init, object_type, 1, &unix_termios_type, this_argn, 0, 0);    
    anna_type_document(
            unix_termios_type, L"A structure representing the state of a terminal.");

    anna_type_t *unix_i_term_get_attr_argv[] = {int_type, unix_termios_type};
    wchar_t *unix_i_term_get_attr_argn[] = {L"fd", L"ios"};
    latest_function = anna_module_function(stack, L"getAttr", 0, &unix_i_term_get_attr, object_type, 2, unix_i_term_get_attr_argv, unix_i_term_get_attr_argn, 0, L"Get the current state of a terminal.");

    anna_type_t *unix_i_term_set_attr_argv[] = {int_type, int_type, unix_termios_type};
    wchar_t *unix_i_term_set_attr_argn[] = {L"fd", L"actions", L"ios"};
    latest_function = anna_module_function(stack, L"setAttr", 0, &unix_i_term_set_attr, object_type, 3, unix_i_term_set_attr_argv, unix_i_term_set_attr_argn, 0, L"Set the current state of the terminal.");
    anna_stack_document(stack, L"The unix.term module contains low level wrappers for basic unix functionality revolving around terminal handling.");

    anna_type_data_register(anna_term_type_data, stack);
}
const static anna_type_data_t anna_error_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_error_error_string, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    int native_param_error = anna_as_int(param[0]);

    // Validate parameters

    // Call the function
    char * tmp_var_80 = strerror(native_param_error);
    anna_entry_t *result = (tmp_var_80) ? anna_from_obj(anna_string_create_narrow(strlen(tmp_var_80), tmp_var_80)) : null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(anna_unix_errno_getter, 1)
{
        anna_entry_t *result = anna_from_int(errno);

    return result;
}

ANNA_VM_NATIVE(anna_unix_errno_setter, 2)
{
    if(param[1] != null_entry)
    {
            int value = anna_as_int(param[1]);

        errno = value;
    }
    return param[1];
}
const static anna_type_data_t anna_status_type_data[] = 
{
};

void anna_status_create(anna_stack_template_t *stack);
void anna_status_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_status_type_data, stack);        
}
void anna_status_load(anna_stack_template_t *stack);
void anna_status_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

#ifdef E2BIG
    anna_module_const_int(stack, L"tooBig", E2BIG, L"Argument list too long.");
#else
    anna_module_const(stack, L"tooBig", int_type, null_entry, L"Argument list too long.");
#endif

#ifdef EACCES
    anna_module_const_int(stack, L"access", EACCES, L"Permission denied.");
#else
    anna_module_const(stack, L"access", int_type, null_entry, L"Permission denied.");
#endif

#ifdef EADDRINUSE
    anna_module_const_int(stack, L"addressInUse", EADDRINUSE, L"Address already in use.");
#else
    anna_module_const(stack, L"addressInUse", int_type, null_entry, L"Address already in use.");
#endif

#ifdef EADDRNOTAVAIL
    anna_module_const_int(stack, L"addressNotAvailable", EADDRNOTAVAIL, L"Address not available.");
#else
    anna_module_const(stack, L"addressNotAvailable", int_type, null_entry, L"Address not available.");
#endif

#ifdef EAFNOSUPPORT
    anna_module_const_int(stack, L"addressFamilyNotSupported", EAFNOSUPPORT, L"Address family not supported.");
#else
    anna_module_const(stack, L"addressFamilyNotSupported", int_type, null_entry, L"Address family not supported.");
#endif

#ifdef EAGAIN
    anna_module_const_int(stack, L"again", EAGAIN, L"Resource temporarily unavailable (may be the same value as wouldBlock).");
#else
    anna_module_const(stack, L"again", int_type, null_entry, L"Resource temporarily unavailable (may be the same value as wouldBlock).");
#endif

#ifdef EALREADY
    anna_module_const_int(stack, L"alreadyInProgress", EALREADY, L"Connection already in progress.");
#else
    anna_module_const(stack, L"alreadyInProgress", int_type, null_entry, L"Connection already in progress.");
#endif

#ifdef EBADE
    anna_module_const_int(stack, L"badExchange", EBADE, L"Invalid exchange.");
#else
    anna_module_const(stack, L"badExchange", int_type, null_entry, L"Invalid exchange.");
#endif

#ifdef EBADF
    anna_module_const_int(stack, L"badFileDescriptor", EBADF, L"Bad file descriptor.");
#else
    anna_module_const(stack, L"badFileDescriptor", int_type, null_entry, L"Bad file descriptor.");
#endif

#ifdef EBADFD
    anna_module_const_int(stack, L"badFileDescriptorState", EBADFD, L"File descriptor in bad state.");
#else
    anna_module_const(stack, L"badFileDescriptorState", int_type, null_entry, L"File descriptor in bad state.");
#endif

#ifdef EBADR
    anna_module_const_int(stack, L"badRequest", EBADR, L"Invalid request descriptor.");
#else
    anna_module_const(stack, L"badRequest", int_type, null_entry, L"Invalid request descriptor.");
#endif

#ifdef EBADRQC
    anna_module_const_int(stack, L"badRequestCode", EBADRQC, L"Invalid request code.");
#else
    anna_module_const(stack, L"badRequestCode", int_type, null_entry, L"Invalid request code.");
#endif

#ifdef EBADSLT
    anna_module_const_int(stack, L"badSlot", EBADSLT, L"Invalid slot.");
#else
    anna_module_const(stack, L"badSlot", int_type, null_entry, L"Invalid slot.");
#endif

#ifdef EBUSY
    anna_module_const_int(stack, L"deviceBusy", EBUSY, L"Device or resource busy.");
#else
    anna_module_const(stack, L"deviceBusy", int_type, null_entry, L"Device or resource busy.");
#endif

#ifdef ECANCELED
    anna_module_const_int(stack, L"canceled", ECANCELED, L"Operation canceled.");
#else
    anna_module_const(stack, L"canceled", int_type, null_entry, L"Operation canceled.");
#endif

#ifdef ECHILD
    anna_module_const_int(stack, L"noChild", ECHILD, L"No child processes.");
#else
    anna_module_const(stack, L"noChild", int_type, null_entry, L"No child processes.");
#endif

#ifdef ECHRNG
    anna_module_const_int(stack, L"channelRange", ECHRNG, L"Channel number out of range.");
#else
    anna_module_const(stack, L"channelRange", int_type, null_entry, L"Channel number out of range.");
#endif

#ifdef ECOMM
    anna_module_const_int(stack, L"communicationError", ECOMM, L"Communication error on send.");
#else
    anna_module_const(stack, L"communicationError", int_type, null_entry, L"Communication error on send.");
#endif

#ifdef ECONNABORTED
    anna_module_const_int(stack, L"connectionAborted", ECONNABORTED, L"Connection aborted.");
#else
    anna_module_const(stack, L"connectionAborted", int_type, null_entry, L"Connection aborted.");
#endif

#ifdef ECONNREFUSED
    anna_module_const_int(stack, L"connectionRefused", ECONNREFUSED, L"Connection refused.");
#else
    anna_module_const(stack, L"connectionRefused", int_type, null_entry, L"Connection refused.");
#endif

#ifdef ECONNRESET
    anna_module_const_int(stack, L"connectionReset", ECONNRESET, L"Connection reset.");
#else
    anna_module_const(stack, L"connectionReset", int_type, null_entry, L"Connection reset.");
#endif

#ifdef EDEADLK
    anna_module_const_int(stack, L"deadlock", EDEADLK, L"Resource deadlock avoided.");
#else
    anna_module_const(stack, L"deadlock", int_type, null_entry, L"Resource deadlock avoided.");
#endif

#ifdef EDESTADDRREQ
    anna_module_const_int(stack, L"destinationRequired", EDESTADDRREQ, L"Destination address required.");
#else
    anna_module_const(stack, L"destinationRequired", int_type, null_entry, L"Destination address required.");
#endif

#ifdef EDOM
    anna_module_const_int(stack, L"domain", EDOM, L"Mathematics argument out of domain of function.");
#else
    anna_module_const(stack, L"domain", int_type, null_entry, L"Mathematics argument out of domain of function.");
#endif

#ifdef EDQUOT
    anna_module_const_int(stack, L"diskQuota", EDQUOT, L"Disk quota exceeded.");
#else
    anna_module_const(stack, L"diskQuota", int_type, null_entry, L"Disk quota exceeded.");
#endif

#ifdef EEXIST
    anna_module_const_int(stack, L"exist", EEXIST, L"File exists.");
#else
    anna_module_const(stack, L"exist", int_type, null_entry, L"File exists.");
#endif

#ifdef EFAULT
    anna_module_const_int(stack, L"fault", EFAULT, L"Bad address.");
#else
    anna_module_const(stack, L"fault", int_type, null_entry, L"Bad address.");
#endif

#ifdef EFBIG
    anna_module_const_int(stack, L"fileTooBig", EFBIG, L"File too large.");
#else
    anna_module_const(stack, L"fileTooBig", int_type, null_entry, L"File too large.");
#endif

#ifdef EHOSTDOWN
    anna_module_const_int(stack, L"hostDown", EHOSTDOWN, L"Host is down.");
#else
    anna_module_const(stack, L"hostDown", int_type, null_entry, L"Host is down.");
#endif

#ifdef EHOSTUNREACH
    anna_module_const_int(stack, L"hostUnreachable", EHOSTUNREACH, L"Host is unreachable.");
#else
    anna_module_const(stack, L"hostUnreachable", int_type, null_entry, L"Host is unreachable.");
#endif

#ifdef EIDRM
    anna_module_const_int(stack, L"identifierRemoved", EIDRM, L"Identifier removed.");
#else
    anna_module_const(stack, L"identifierRemoved", int_type, null_entry, L"Identifier removed.");
#endif

#ifdef EILSEQ
    anna_module_const_int(stack, L"illegalByteSequence", EILSEQ, L"Illegal byte sequence.");
#else
    anna_module_const(stack, L"illegalByteSequence", int_type, null_entry, L"Illegal byte sequence.");
#endif

#ifdef EINPROGRESS
    anna_module_const_int(stack, L"inProgress", EINPROGRESS, L"Operation in progress.");
#else
    anna_module_const(stack, L"inProgress", int_type, null_entry, L"Operation in progress.");
#endif

#ifdef EINTR
    anna_module_const_int(stack, L"interrupted", EINTR, L"Interrupted function call.");
#else
    anna_module_const(stack, L"interrupted", int_type, null_entry, L"Interrupted function call.");
#endif

#ifdef EINVAL
    anna_module_const_int(stack, L"invalid", EINVAL, L"Invalid argument.");
#else
    anna_module_const(stack, L"invalid", int_type, null_entry, L"Invalid argument.");
#endif

#ifdef EIO
    anna_module_const_int(stack, L"ioError", EIO, L"Input/output error.");
#else
    anna_module_const(stack, L"ioError", int_type, null_entry, L"Input/output error.");
#endif

#ifdef EISCONN
    anna_module_const_int(stack, L"connected?", EISCONN, L"Socket is connected.");
#else
    anna_module_const(stack, L"connected?", int_type, null_entry, L"Socket is connected.");
#endif

#ifdef EISDIR
    anna_module_const_int(stack, L"directory?", EISDIR, L"Is a directory.");
#else
    anna_module_const(stack, L"directory?", int_type, null_entry, L"Is a directory.");
#endif

#ifdef EISNAM
    anna_module_const_int(stack, L"named?", EISNAM, L"Is a named type file.");
#else
    anna_module_const(stack, L"named?", int_type, null_entry, L"Is a named type file.");
#endif

#ifdef EKEYEXPIRED
    anna_module_const_int(stack, L"keyExpired", EKEYEXPIRED, L"Key has expired.");
#else
    anna_module_const(stack, L"keyExpired", int_type, null_entry, L"Key has expired.");
#endif

#ifdef EKEYREJECTED
    anna_module_const_int(stack, L"keyRejected", EKEYREJECTED, L"Key was rejected by service.");
#else
    anna_module_const(stack, L"keyRejected", int_type, null_entry, L"Key was rejected by service.");
#endif

#ifdef EKEYREVOKED
    anna_module_const_int(stack, L"keyRevoked", EKEYREVOKED, L"Key has been revoked.");
#else
    anna_module_const(stack, L"keyRevoked", int_type, null_entry, L"Key has been revoked.");
#endif

#ifdef EL2HLT
    anna_module_const_int(stack, L"level2Halted", EL2HLT, L"Level 2 halted.");
#else
    anna_module_const(stack, L"level2Halted", int_type, null_entry, L"Level 2 halted.");
#endif

#ifdef EL2NSYNC
    anna_module_const_int(stack, L"level2NotSynced", EL2NSYNC, L"Level 2 not synchronized.");
#else
    anna_module_const(stack, L"level2NotSynced", int_type, null_entry, L"Level 2 not synchronized.");
#endif

#ifdef EL3HLT
    anna_module_const_int(stack, L"level3Halted", EL3HLT, L"Level 3 halted.");
#else
    anna_module_const(stack, L"level3Halted", int_type, null_entry, L"Level 3 halted.");
#endif

#ifdef EL3RST
    anna_module_const_int(stack, L"level3Reset", EL3RST, L"Level 3 reset.");
#else
    anna_module_const(stack, L"level3Reset", int_type, null_entry, L"Level 3 reset.");
#endif

#ifdef ELIBACC
    anna_module_const_int(stack, L"libraryAccess", ELIBACC, L"Cannot access a needed shared library.");
#else
    anna_module_const(stack, L"libraryAccess", int_type, null_entry, L"Cannot access a needed shared library.");
#endif

#ifdef ELIBBAD
    anna_module_const_int(stack, L"libraryBad", ELIBBAD, L"Accessing a corrupted shared library.");
#else
    anna_module_const(stack, L"libraryBad", int_type, null_entry, L"Accessing a corrupted shared library.");
#endif

#ifdef ELIBMAX
    anna_module_const_int(stack, L"libraryMax", ELIBMAX, L"Attempting to link in too many shared libraries.");
#else
    anna_module_const(stack, L"libraryMax", int_type, null_entry, L"Attempting to link in too many shared libraries.");
#endif

#ifdef ELIBSCN
    anna_module_const_int(stack, L"libraryCorrupt", ELIBSCN, L"lib section in a.out corrupted.");
#else
    anna_module_const(stack, L"libraryCorrupt", int_type, null_entry, L"lib section in a.out corrupted.");
#endif

#ifdef ELIBEXEC
    anna_module_const_int(stack, L"libraryExec", ELIBEXEC, L"Cannot exec a shared library directly.");
#else
    anna_module_const(stack, L"libraryExec", int_type, null_entry, L"Cannot exec a shared library directly.");
#endif

#ifdef ELOOP
    anna_module_const_int(stack, L"loop", ELOOP, L"Too many levels of symbolic links");
#else
    anna_module_const(stack, L"loop", int_type, null_entry, L"Too many levels of symbolic links");
#endif

#ifdef EMEDIUMTYPE
    anna_module_const_int(stack, L"mediumType", EMEDIUMTYPE, L"Wrong medium type.");
#else
    anna_module_const(stack, L"mediumType", int_type, null_entry, L"Wrong medium type.");
#endif

#ifdef EMFILE
    anna_module_const_int(stack, L"maxFile", EMFILE, L"Too many open files.");
#else
    anna_module_const(stack, L"maxFile", int_type, null_entry, L"Too many open files.");
#endif

#ifdef EMLINK
    anna_module_const_int(stack, L"maxLink", EMLINK, L"Too many links.");
#else
    anna_module_const(stack, L"maxLink", int_type, null_entry, L"Too many links.");
#endif

#ifdef EMSGSIZE
    anna_module_const_int(stack, L"messageSize", EMSGSIZE, L"Message too long.");
#else
    anna_module_const(stack, L"messageSize", int_type, null_entry, L"Message too long.");
#endif

#ifdef EMULTIHOP
    anna_module_const_int(stack, L"multihop", EMULTIHOP, L"Multihop attempted.");
#else
    anna_module_const(stack, L"multihop", int_type, null_entry, L"Multihop attempted.");
#endif

#ifdef ENAMETOOLONG
    anna_module_const_int(stack, L"nameTooLong", ENAMETOOLONG, L"Filename too long.");
#else
    anna_module_const(stack, L"nameTooLong", int_type, null_entry, L"Filename too long.");
#endif

#ifdef ENETDOWN
    anna_module_const_int(stack, L"netDown", ENETDOWN, L"Network is down.");
#else
    anna_module_const(stack, L"netDown", int_type, null_entry, L"Network is down.");
#endif

#ifdef ENETRESET
    anna_module_const_int(stack, L"netReset", ENETRESET, L"Connection aborted by network.");
#else
    anna_module_const(stack, L"netReset", int_type, null_entry, L"Connection aborted by network.");
#endif

#ifdef ENETUNREACH
    anna_module_const_int(stack, L"netUnreachable", ENETUNREACH, L"Network unreachable.");
#else
    anna_module_const(stack, L"netUnreachable", int_type, null_entry, L"Network unreachable.");
#endif

#ifdef ENFILE
    anna_module_const_int(stack, L"maxFileInSystem", ENFILE, L"Too many open files in system.");
#else
    anna_module_const(stack, L"maxFileInSystem", int_type, null_entry, L"Too many open files in system.");
#endif

#ifdef ENOBUFS
    anna_module_const_int(stack, L"noBufferSpace", ENOBUFS, L"No buffer space available.");
#else
    anna_module_const(stack, L"noBufferSpace", int_type, null_entry, L"No buffer space available.");
#endif

#ifdef ENODATA
    anna_module_const_int(stack, L"noData", ENODATA, L"No message is available on the STREAM head read queue.");
#else
    anna_module_const(stack, L"noData", int_type, null_entry, L"No message is available on the STREAM head read queue.");
#endif

#ifdef ENODEV
    anna_module_const_int(stack, L"noDevice", ENODEV, L"No such device.");
#else
    anna_module_const(stack, L"noDevice", int_type, null_entry, L"No such device.");
#endif

#ifdef ENOENT
    anna_module_const_int(stack, L"noEntry", ENOENT, L"No such file or directory.");
#else
    anna_module_const(stack, L"noEntry", int_type, null_entry, L"No such file or directory.");
#endif

#ifdef ENOEXEC
    anna_module_const_int(stack, L"noExec", ENOEXEC, L"Exec format error.");
#else
    anna_module_const(stack, L"noExec", int_type, null_entry, L"Exec format error.");
#endif

#ifdef ENOKEY
    anna_module_const_int(stack, L"noKey", ENOKEY, L"Required key not available.");
#else
    anna_module_const(stack, L"noKey", int_type, null_entry, L"Required key not available.");
#endif

#ifdef ENOLCK
    anna_module_const_int(stack, L"noLock", ENOLCK, L"No locks available.");
#else
    anna_module_const(stack, L"noLock", int_type, null_entry, L"No locks available.");
#endif

#ifdef ENOLINK
    anna_module_const_int(stack, L"noLink", ENOLINK, L"Link has been severed.");
#else
    anna_module_const(stack, L"noLink", int_type, null_entry, L"Link has been severed.");
#endif

#ifdef ENOMEDIUM
    anna_module_const_int(stack, L"noMedium", ENOMEDIUM, L"No medium found.");
#else
    anna_module_const(stack, L"noMedium", int_type, null_entry, L"No medium found.");
#endif

#ifdef ENOMEM
    anna_module_const_int(stack, L"noMemory", ENOMEM, L"Not enough space.");
#else
    anna_module_const(stack, L"noMemory", int_type, null_entry, L"Not enough space.");
#endif

#ifdef ENOMSG
    anna_module_const_int(stack, L"noMessage", ENOMSG, L"No message of the desired type.");
#else
    anna_module_const(stack, L"noMessage", int_type, null_entry, L"No message of the desired type.");
#endif

#ifdef ENONET
    anna_module_const_int(stack, L"noNet", ENONET, L"Machine is not on the network.");
#else
    anna_module_const(stack, L"noNet", int_type, null_entry, L"Machine is not on the network.");
#endif

#ifdef ENOPKG
    anna_module_const_int(stack, L"noPackage", ENOPKG, L"Package not installed.");
#else
    anna_module_const(stack, L"noPackage", int_type, null_entry, L"Package not installed.");
#endif

#ifdef ENOPROTOOPT
    anna_module_const_int(stack, L"noProtocol", ENOPROTOOPT, L"Protocol not available.");
#else
    anna_module_const(stack, L"noProtocol", int_type, null_entry, L"Protocol not available.");
#endif

#ifdef ENOSPC
    anna_module_const_int(stack, L"noSpace", ENOSPC, L"No space left on device.");
#else
    anna_module_const(stack, L"noSpace", int_type, null_entry, L"No space left on device.");
#endif

#ifdef ENOSR
    anna_module_const_int(stack, L"noStream", ENOSR, L"No STREAM resources.");
#else
    anna_module_const(stack, L"noStream", int_type, null_entry, L"No STREAM resources.");
#endif

#ifdef ENOSTR
    anna_module_const_int(stack, L"notStream", ENOSTR, L"Not a STREAM.");
#else
    anna_module_const(stack, L"notStream", int_type, null_entry, L"Not a STREAM.");
#endif

#ifdef ENOSYS
    anna_module_const_int(stack, L"notImplemented", ENOSYS, L"Function not implemented.");
#else
    anna_module_const(stack, L"notImplemented", int_type, null_entry, L"Function not implemented.");
#endif

#ifdef ENOTBLK
    anna_module_const_int(stack, L"notBlock", ENOTBLK, L"Block device required.");
#else
    anna_module_const(stack, L"notBlock", int_type, null_entry, L"Block device required.");
#endif

#ifdef ENOTCONN
    anna_module_const_int(stack, L"notConnected", ENOTCONN, L"The socket is not connected.");
#else
    anna_module_const(stack, L"notConnected", int_type, null_entry, L"The socket is not connected.");
#endif

#ifdef ENOTDIR
    anna_module_const_int(stack, L"notDirectory", ENOTDIR, L"Not a directory.");
#else
    anna_module_const(stack, L"notDirectory", int_type, null_entry, L"Not a directory.");
#endif

#ifdef ENOTEMPTY
    anna_module_const_int(stack, L"notEmpty", ENOTEMPTY, L"Directory not empty.");
#else
    anna_module_const(stack, L"notEmpty", int_type, null_entry, L"Directory not empty.");
#endif

#ifdef ENOTSOCK
    anna_module_const_int(stack, L"notSocket", ENOTSOCK, L"Not a socket.");
#else
    anna_module_const(stack, L"notSocket", int_type, null_entry, L"Not a socket.");
#endif

#ifdef ENOTSUP
    anna_module_const_int(stack, L"notSupported", ENOTSUP, L"Operation not supported.");
#else
    anna_module_const(stack, L"notSupported", int_type, null_entry, L"Operation not supported.");
#endif

#ifdef ENOTTY
    anna_module_const_int(stack, L"notTty", ENOTTY, L"Inappropriate I/O control operation.");
#else
    anna_module_const(stack, L"notTty", int_type, null_entry, L"Inappropriate I/O control operation.");
#endif

#ifdef ENOTUNIQ
    anna_module_const_int(stack, L"notUnique", ENOTUNIQ, L"Name not unique on network.");
#else
    anna_module_const(stack, L"notUnique", int_type, null_entry, L"Name not unique on network.");
#endif

#ifdef ENXIO
    anna_module_const_int(stack, L"noDeviceOrAddress", ENXIO, L"No such device or address.");
#else
    anna_module_const(stack, L"noDeviceOrAddress", int_type, null_entry, L"No such device or address.");
#endif

#ifdef EOPNOTSUPP
    anna_module_const_int(stack, L"operationNotSupported", EOPNOTSUPP, L"Operation not supported on socket.");
#else
    anna_module_const(stack, L"operationNotSupported", int_type, null_entry, L"Operation not supported on socket.");
#endif

#ifdef EOVERFLOW
    anna_module_const_int(stack, L"overflow", EOVERFLOW, L"Value too large to be stored in data type.");
#else
    anna_module_const(stack, L"overflow", int_type, null_entry, L"Value too large to be stored in data type.");
#endif

#ifdef EPERM
    anna_module_const_int(stack, L"permission", EPERM, L"Operation not permitted.");
#else
    anna_module_const(stack, L"permission", int_type, null_entry, L"Operation not permitted.");
#endif

#ifdef EPFNOSUPPORT
    anna_module_const_int(stack, L"protocolFamilyNotSupported", EPFNOSUPPORT, L"Protocol family not supported.");
#else
    anna_module_const(stack, L"protocolFamilyNotSupported", int_type, null_entry, L"Protocol family not supported.");
#endif

#ifdef EPIPE
    anna_module_const_int(stack, L"pipe", EPIPE, L"Broken pipe.");
#else
    anna_module_const(stack, L"pipe", int_type, null_entry, L"Broken pipe.");
#endif

#ifdef EPROTO
    anna_module_const_int(stack, L"protocolError", EPROTO, L"Protocol error.");
#else
    anna_module_const(stack, L"protocolError", int_type, null_entry, L"Protocol error.");
#endif

#ifdef EPROTONOSUPPORT
    anna_module_const_int(stack, L"protocolNotSupported", EPROTONOSUPPORT, L"Protocol not supported.");
#else
    anna_module_const(stack, L"protocolNotSupported", int_type, null_entry, L"Protocol not supported.");
#endif

#ifdef EPROTOTYPE
    anna_module_const_int(stack, L"protocolType", EPROTOTYPE, L"Protocol wrong type for socket.");
#else
    anna_module_const(stack, L"protocolType", int_type, null_entry, L"Protocol wrong type for socket.");
#endif

#ifdef ERANGE
    anna_module_const_int(stack, L"range", ERANGE, L"Result too large.");
#else
    anna_module_const(stack, L"range", int_type, null_entry, L"Result too large.");
#endif

#ifdef EREMCHG
    anna_module_const_int(stack, L"remoteAddressChanged", EREMCHG, L"Remote address changed.");
#else
    anna_module_const(stack, L"remoteAddressChanged", int_type, null_entry, L"Remote address changed.");
#endif

#ifdef EREMOTE
    anna_module_const_int(stack, L"remote", EREMOTE, L"Object is remote.");
#else
    anna_module_const(stack, L"remote", int_type, null_entry, L"Object is remote.");
#endif

#ifdef EREMOTEIO
    anna_module_const_int(stack, L"remoteIo", EREMOTEIO, L"Remote I/O error.");
#else
    anna_module_const(stack, L"remoteIo", int_type, null_entry, L"Remote I/O error.");
#endif

#ifdef ERESTART
    anna_module_const_int(stack, L"restart", ERESTART, L"Interrupted system call should be restarted.");
#else
    anna_module_const(stack, L"restart", int_type, null_entry, L"Interrupted system call should be restarted.");
#endif

#ifdef EROFS
    anna_module_const_int(stack, L"readOnly", EROFS, L"Read-only file system.");
#else
    anna_module_const(stack, L"readOnly", int_type, null_entry, L"Read-only file system.");
#endif

#ifdef ESHUTDOWN
    anna_module_const_int(stack, L"shutdown", ESHUTDOWN, L"Cannot send after transport endpoint shutdown.");
#else
    anna_module_const(stack, L"shutdown", int_type, null_entry, L"Cannot send after transport endpoint shutdown.");
#endif

#ifdef ESPIPE
    anna_module_const_int(stack, L"seekPipe", ESPIPE, L"Invalid seek.");
#else
    anna_module_const(stack, L"seekPipe", int_type, null_entry, L"Invalid seek.");
#endif

#ifdef ESOCKTNOSUPPORT
    anna_module_const_int(stack, L"socketNotSupported", ESOCKTNOSUPPORT, L"Socket type not supported.");
#else
    anna_module_const(stack, L"socketNotSupported", int_type, null_entry, L"Socket type not supported.");
#endif

#ifdef ESRCH
    anna_module_const_int(stack, L"noSuchProcess", ESRCH, L"No such process.");
#else
    anna_module_const(stack, L"noSuchProcess", int_type, null_entry, L"No such process.");
#endif

#ifdef ESTALE
    anna_module_const_int(stack, L"stale", ESTALE, L"Stale file handle. This error can occur for NFS and for other file systems.");
#else
    anna_module_const(stack, L"stale", int_type, null_entry, L"Stale file handle. This error can occur for NFS and for other file systems.");
#endif

#ifdef ESTRPIPE
    anna_module_const_int(stack, L"streamPipe", ESTRPIPE, L"Streams pipe error.");
#else
    anna_module_const(stack, L"streamPipe", int_type, null_entry, L"Streams pipe error.");
#endif

#ifdef ETIME
    anna_module_const_int(stack, L"timer", ETIME, L"Timer expired.");
#else
    anna_module_const(stack, L"timer", int_type, null_entry, L"Timer expired.");
#endif

#ifdef ETIMEDOUT
    anna_module_const_int(stack, L"timeout", ETIMEDOUT, L"Connection timed out.");
#else
    anna_module_const(stack, L"timeout", int_type, null_entry, L"Connection timed out.");
#endif

#ifdef ETXTBSY
    anna_module_const_int(stack, L"textBusy", ETXTBSY, L"Text file busy.");
#else
    anna_module_const(stack, L"textBusy", int_type, null_entry, L"Text file busy.");
#endif

#ifdef EUCLEAN
    anna_module_const_int(stack, L"unclean", EUCLEAN, L"Structure needs cleaning.");
#else
    anna_module_const(stack, L"unclean", int_type, null_entry, L"Structure needs cleaning.");
#endif

#ifdef EUNATCH
    anna_module_const_int(stack, L"unattached", EUNATCH, L"Protocol driver not attached.");
#else
    anna_module_const(stack, L"unattached", int_type, null_entry, L"Protocol driver not attached.");
#endif

#ifdef EUSERS
    anna_module_const_int(stack, L"users", EUSERS, L"Too many users.");
#else
    anna_module_const(stack, L"users", int_type, null_entry, L"Too many users.");
#endif

#ifdef EWOULDBLOCK
    anna_module_const_int(stack, L"wouldBlock", EWOULDBLOCK, L"Operation would block (may be same value as again).");
#else
    anna_module_const(stack, L"wouldBlock", int_type, null_entry, L"Operation would block (may be same value as again).");
#endif

#ifdef EXDEV
    anna_module_const_int(stack, L"improperLink", EXDEV, L"Improper link.");
#else
    anna_module_const(stack, L"improperLink", int_type, null_entry, L"Improper link.");
#endif

#ifdef EXFULL
    anna_module_const_int(stack, L"exchangeFull", EXFULL, L"Exchange full.");
#else
    anna_module_const(stack, L"exchangeFull", int_type, null_entry, L"Exchange full.");
#endif

    anna_stack_document(stack, L"All known error statuses");

    anna_type_data_register(anna_status_type_data, stack);
}

void anna_error_create(anna_stack_template_t *stack);
void anna_error_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_error_type_data, stack);        
}
void anna_error_load(anna_stack_template_t *stack);
void anna_error_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"status", anna_status_create, anna_status_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_error_error_string_argv[] = {int_type};
    wchar_t *unix_i_error_error_string_argn[] = {L"error"};
    latest_function = anna_module_function(stack, L"errorString", 0, &unix_i_error_error_string, string_type, 1, unix_i_error_error_string_argv, unix_i_error_error_string_argn, 0, L"Returns a string that describes the error code passed in the argument. Equivalent to the C strerror function.");
    anna_member_create_native_property(
        stack_type, anna_mid_get(L"errno"),
        int_type, anna_unix_errno_getter, anna_unix_errno_setter, L"The latest C library error to occur");
    anna_stack_document(stack, L"The unix.error module contains low level wrappers around C functions that revolve around error handling.");

    anna_type_data_register(anna_error_type_data, stack);
}


// This function is called to create all types defined in this module

void anna_unix_create(anna_stack_template_t *stack);
void anna_unix_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_unix_type_data, stack);        
}

// This function is called to load all functions and other declarations into the module

void anna_unix_load(anna_stack_template_t *stack);
void anna_unix_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"time", anna_time_create, anna_time_load},
            { L"io", anna_io_create, anna_io_load},
            { L"proc", anna_proc_create, anna_proc_load},
            { L"user", anna_user_create, anna_user_load},
            { L"rLimit", anna_r_limit_create, anna_r_limit_load},
            { L"env", anna_env_create, anna_env_load},
            { L"sleep", anna_sleep_create, anna_sleep_load},
            { L"locale", anna_locale_create, anna_locale_load},
            { L"term", anna_term_create, anna_term_load},
            { L"error", anna_error_create, anna_error_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_stack_document(stack, L"The unix module is the parent module for various low level wrappers\nfor basic Unix functionality.");
    anna_stack_document(stack, L"Anna currently has a very sparse standard library, which often\nnecessitates the use of these low level libraries, but when available,\na more programmer friendly high level library should be used. In\naddition, the documentation for these modules is rather sparse - for a\nfull reference of the various members of the unix.* submodules, read\nthe original man pages.");
    anna_stack_document(stack, L"The unix.* submodules are still rater incomplete. There are many, many\nfunctions that are currently missing. The ones that are there have\ninconsistent naming conventions with regard to capitalization,\nabbreviations, etc. The convention for naming, etc. in this module\nwill evolve over time, which can result in future incompatibilities.");

    anna_type_data_register(anna_unix_type_data, stack);
}



/*
    DO NOT MANUALLY EDIT THIS FILE.

    This file has been automaticaly generated by the anna bind
    utility. If you manually edit it, your changes will eventually be
    lost. Not to mention the fact that staring at machine generated
    code rots your brain. If this file is incorrect, either update the
    bind utility or update the binding source, which is located in the
    file:

    internalBindings/unix.bind

 */

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>
#include <sys/wait.h>
#include <grp.h>
#include <stdint.h>
#include <poll.h>
#include <sys/select.h>
#include <locale.h>
#include <termios.h>
#include <sys/signalfd.h>

#include "anna/anna.h"

// Declare internal variables for all types defined in this module
anna_type_t *unix_time_val_type;
anna_type_t *unix_time_zone_type;
anna_type_t *unix_stat_type;
anna_type_t *unix_f_lock_type;
anna_type_t *unix_fd_set_type;
anna_type_t *unix_signal_set_type;
anna_type_t *unix_signal_info_fd_type;
anna_type_t *unix_r_limit_type;
anna_type_t *unix_locale_conv_type;
anna_type_t *unix_termios_type;


// Data used to initialize all types defined in this module
const static anna_type_data_t anna_unix_type_data[] = 
{
};

// This is the source code of the various wrapper functions
const static anna_type_data_t anna_time_type_data[] = 
{
    { &unix_time_val_type, L"TimeVal" },
    { &unix_time_zone_type, L"TimeZone" },
};

ANNA_VM_NATIVE(unix_i_time_val_sec_getter, 1)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->tv_sec);
    return result;
}

ANNA_VM_NATIVE(unix_i_time_val_sec_setter, 2)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->tv_sec = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_time_val_usec_getter, 1)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->tv_usec);
    return result;
}

ANNA_VM_NATIVE(unix_i_time_val_usec_setter, 2)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->tv_usec = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_time_val_init, 1)
{
    struct timeval *data;
    data = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct timeval));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_time_zone_init, 1)
{
    struct timezone *data;
    data = (struct timezone *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct timezone));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_time_gettimeofday, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    struct timeval *native_param_tv;
    native_param_tv = (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    struct timezone *native_param_tz;
    native_param_tz = (struct timezone *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_1 = gettimeofday(native_param_tv, native_param_tz);
    anna_entry_t *result = (tmp_var_1)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

void anna_time_create(anna_stack_template_t *stack);
void anna_time_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_time_type_data, stack);        
}
void anna_time_load(anna_stack_template_t *stack);
void anna_time_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_time_val_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct timeval));

    anna_member_create_native_property(
        unix_time_val_type, anna_mid_get(L"sec"),
        int_type, unix_i_time_val_sec_getter, unix_i_time_val_sec_setter, L"Seconds");

    anna_member_create_native_property(
        unix_time_val_type, anna_mid_get(L"usec"),
        int_type, unix_i_time_val_usec_getter, unix_i_time_val_usec_setter, L"Microseconds.");
    anna_member_create_native_method(
	unix_time_val_type, anna_mid_get(L"__init__"), 0,
	&unix_i_time_val_init, object_type, 1, &unix_time_val_type, this_argn, 0, 0);    
    anna_type_document(
            unix_time_val_type, L"A data structure representing a point in time as the amount of time that has elapsed since the epoch.");

    anna_member_create_blob(unix_time_zone_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct timezone));
    anna_member_create_native_method(
	unix_time_zone_type, anna_mid_get(L"__init__"), 0,
	&unix_i_time_zone_init, object_type, 1, &unix_time_zone_type, this_argn, 0, 0);    
    anna_type_document(
            unix_time_zone_type, L"A deprecated data structure that used to be used for representing a time zone.");

    anna_type_t *unix_i_time_gettimeofday_argv[] = {unix_time_val_type, unix_time_zone_type};
    wchar_t *unix_i_time_gettimeofday_argn[] = {L"tv", L"tz"};
    latest_function = anna_module_function(stack, L"gettimeofday", 0, &unix_i_time_gettimeofday, object_type, 2, unix_i_time_gettimeofday_argv, unix_i_time_gettimeofday_argn, 0, L"Gets the current system time. Equivalanet to the C gettimeofday function.");
    anna_stack_document(stack, L"The unix.time module contains low level wrappers for basic unix functionality revolving around timekeeping.");

    anna_type_data_register(anna_time_type_data, stack);
}
const static anna_type_data_t anna_io_type_data[] = 
{
    { &unix_stat_type, L"Stat" },
    { &unix_f_lock_type, L"FLock" },
    { &unix_fd_set_type, L"FdSet" },
};
const static anna_type_data_t anna_open_mode_type_data[] = 
{
};

void anna_open_mode_create(anna_stack_template_t *stack);
void anna_open_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_open_mode_type_data, stack);        
}
void anna_open_mode_load(anna_stack_template_t *stack);
void anna_open_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"readOnly", O_RDONLY, L"Open file in read-only mode.");
    anna_module_const_int(stack, L"writeOnly", O_WRONLY, L"Open file in write-only mode.");
    anna_module_const_int(stack, L"readWrite", O_RDWR, L"Open file in read-write mode.");
    anna_module_const_int(stack, L"append", O_APPEND, L"The file is opened in append mode.");
    anna_module_const_int(stack, L"async", O_ASYNC, L"Enable signal-driven I/O.");
    anna_module_const_int(stack, L"create", O_CREAT, L"If the file does not exist it will be created.");
    anna_module_const_int(stack, L"closeOnExec", O_CLOEXEC, L"Enable the close-on-exec flag for the new file descriptor.");
    anna_module_const_int(stack, L"direct", O_DIRECT, L"Try to minimize cache effects of the I/O to and from this file.");
    anna_module_const_int(stack, L"directory", O_DIRECTORY, L"If pathname is not a directory, cause the open to fail.");
    anna_module_const_int(stack, L"exclusive", O_EXCL, L"Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail.");
    anna_module_const_int(stack, L"largeFile", O_LARGEFILE, L"(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.");
    anna_module_const_int(stack, L"noAccessTime", O_NOATIME, L"Do not update the file last access time (st_atime in the inode) when the file is read().");
    anna_module_const_int(stack, L"noControllingTTY", O_NOCTTY, L"If pathname refers to a terminal device - it will not become the process's controlling terminal even if the process does not have one.");
    anna_module_const_int(stack, L"noFollow", O_NOFOLLOW, L"If pathname is a symbolic link, then the open fails.");
    anna_module_const_int(stack, L"nonBlock", O_NONBLOCK, L"When possible, the file is opened in nonblocking mode.");
    anna_module_const_int(stack, L"synchronous", O_SYNC, L"The file is opened for synchronous I/O.");
    anna_module_const_int(stack, L"truncate", O_TRUNC, L"f the file already exists and is a regular file and the open mode allows writing (i.e., is writeOnly or readWrite) it will be truncated to length 0.");
    anna_stack_document(stack, L"Flags determining the mode for unix.io.open");

    anna_type_data_register(anna_open_mode_type_data, stack);
}
const static anna_type_data_t anna_stat_mode_type_data[] = 
{
};

void anna_stat_mode_create(anna_stack_template_t *stack);
void anna_stat_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_stat_mode_type_data, stack);        
}
void anna_stat_mode_load(anna_stack_template_t *stack);
void anna_stat_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"regular", S_IFREG, L"Regular file");
    anna_module_const_int(stack, L"socket", S_IFSOCK, L"Socket");
    anna_module_const_int(stack, L"link", S_IFLNK, L"Symbolic link.");
    anna_module_const_int(stack, L"block", S_IFBLK, L"Block device.");
    anna_module_const_int(stack, L"directory", S_IFDIR, L"Directory.");
    anna_module_const_int(stack, L"character", S_IFCHR, L"Character device.");
    anna_module_const_int(stack, L"fifo", S_IFIFO, L"FIFO.");
    anna_module_const_int(stack, L"suid", S_ISUID, L"Set UID bit.");
    anna_module_const_int(stack, L"sgid", S_ISGID, L"Set-group-ID bit.");
    anna_module_const_int(stack, L"sticky", S_ISVTX, L"Sticky bit.");
    anna_module_const_int(stack, L"userAll", S_IRWXU, L"Mask for all file owner permissions.");
    anna_module_const_int(stack, L"userRead", S_IRUSR, L"File owner read permission.");
    anna_module_const_int(stack, L"userwrite", S_IWUSR, L"File owner write permission.");
    anna_module_const_int(stack, L"userExecute", S_IXUSR, L"File owner execute permission.");
    anna_module_const_int(stack, L"groupAll", S_IRWXG, L"Mask for all group permissions.");
    anna_module_const_int(stack, L"groupRead", S_IRGRP, L"Group has read permission.");
    anna_module_const_int(stack, L"groupwrite", S_IWGRP, L"Group has write permission.");
    anna_module_const_int(stack, L"groupExecute", S_IXGRP, L"Group has execute permission.");
    anna_module_const_int(stack, L"otherAll", S_IRWXO, L"Mask for permissions for others (not in group).");
    anna_module_const_int(stack, L"otherRead", S_IROTH, L"Others have read permission.");
    anna_module_const_int(stack, L"otherwrite", S_IWOTH, L"Others have write permission.");
    anna_module_const_int(stack, L"otherExecute", S_IXOTH, L"Others have execute permission.");
    anna_stack_document(stack, L"Flags used for identifying file status together with a unix.io.Stat object.");

    anna_type_data_register(anna_stat_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_io_open, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_flags = anna_as_int(param[1]);
    int native_param_mode = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_2 = open(native_param_name, native_param_flags, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_2);
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_creat, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_3 = creat(native_param_name, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_3);
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_read, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    unsigned char *native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    int native_param_count = anna_as_int(param[2]);

    // Validate parameters
    
    if(anna_buffer_ensure_capacity(anna_as_obj(param[1]), native_param_count)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    }
    

    // Call the function
    int tmp_var_4 = read(native_param_fd, native_param_buffer, native_param_count);
    anna_entry_t *result = anna_from_int(tmp_var_4);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_write, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    unsigned char *native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    int native_param_count = anna_as_int(param[2]);

    // Validate parameters
    
    if(anna_buffer_ensure_capacity(anna_as_obj(param[1]), native_param_count)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buffer = anna_buffer_get_payload(anna_as_obj(param[1]));
    }
    

    // Call the function
    int tmp_var_5 = write(native_param_fd, native_param_buffer, native_param_count);
    anna_entry_t *result = anna_from_int(tmp_var_5);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_close, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_6 = close(native_param_fd);
    anna_entry_t *result = (tmp_var_6)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_dev_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_dev);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_ino_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_ino);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_mode_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_mode);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_nlink_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_nlink);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_uid_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_uid);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_gid_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_gid);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_rdev_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_rdev);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_size_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_size);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_blksize_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_blksize);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_blocks_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_blocks);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_atime_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_atime);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_mtime_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_mtime);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_ctime_getter, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->st_ctime);
    return result;
}

ANNA_VM_NATIVE(unix_i_stat_init, 1)
{
    struct stat *data;
    data = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct stat));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_io_stat, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    struct stat *native_param_buf;
    native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_7 = stat(native_param_path, native_param_buf);
    anna_entry_t *result = (tmp_var_7)?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lstat, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    struct stat *native_param_buf;
    native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_8 = lstat(native_param_path, native_param_buf);
    anna_entry_t *result = (tmp_var_8)?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fstat, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    struct stat *native_param_buf;
    native_param_buf = (struct stat *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_9 = fstat(native_param_fd, native_param_buf);
    anna_entry_t *result = (tmp_var_9)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_mkdir, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_10 = mkdir(native_param_path, native_param_mode);
    anna_entry_t *result = (tmp_var_10)?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_getcwd, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

    // Mangle input parameters
    unsigned char *native_param_buf = anna_buffer_get_payload(anna_as_obj(param[0]));
    int native_param_size = anna_as_int(param[1]);

    // Validate parameters
    if(anna_buffer_ensure_capacity(anna_as_obj(param[0]), native_param_size)) 
    {
        return null_entry;
    }
    else
    {
        native_param_buf = anna_buffer_get_payload(anna_as_obj(param[0]));
    }
    

    // Call the function
    int tmp_var_11 = getcwd(native_param_buf, native_param_size);
    anna_entry_t *result = (tmp_var_11)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chdir, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    int tmp_var_12 = chdir(native_param_path);
    anna_entry_t *result = (tmp_var_12)?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chroot, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    int tmp_var_13 = chroot(native_param_path);
    anna_entry_t *result = (tmp_var_13)?anna_from_int(1):null_entry;
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchdir, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_14 = fchdir(native_param_fd);
    anna_entry_t *result = (tmp_var_14)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_type_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_type);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_whence_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_whence);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_start_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_start);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_len_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_len);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_pid_getter, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->l_pid);
    return result;
}

ANNA_VM_NATIVE(unix_i_f_lock_init, 1)
{
    struct flock *data;
    data = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct flock));
    return param[0];
}
const static anna_type_data_t anna_fcntl_mode_type_data[] = 
{
};

void anna_fcntl_mode_create(anna_stack_template_t *stack);
void anna_fcntl_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_fcntl_mode_type_data, stack);        
}
void anna_fcntl_mode_load(anna_stack_template_t *stack);
void anna_fcntl_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"dupFd", F_DUPFD, L"Duplicate file descriptor.");
    anna_stack_document(stack, L"Flags specifying file descriptor manipulations for unix.io.fcntl");

    anna_type_data_register(anna_fcntl_mode_type_data, stack);
}
const static anna_type_data_t anna_seek_mode_type_data[] = 
{
};

void anna_seek_mode_create(anna_stack_template_t *stack);
void anna_seek_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_seek_mode_type_data, stack);        
}
void anna_seek_mode_load(anna_stack_template_t *stack);
void anna_seek_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"set", SEEK_SET, L"Seek to absolute file offset.");
    anna_module_const_int(stack, L"cur", SEEK_CUR, L"Seek to file offset relative current position.");
    anna_module_const_int(stack, L"end", SEEK_END, L"Seek to file offset relative to end of file.");
    anna_stack_document(stack, L"Different seek modes for use with the unix.io.seek function");

    anna_type_data_register(anna_seek_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_io_fcntl_void, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_15 = fcntl(native_param_fd, native_param_cmd);
    anna_entry_t *result = anna_from_int(tmp_var_15);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fcntl_int, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);
    int native_param_arg = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_16 = fcntl(native_param_fd, native_param_cmd, native_param_arg);
    anna_entry_t *result = anna_from_int(tmp_var_16);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fcntl_f_lock, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_cmd = anna_as_int(param[1]);
    struct flock *native_param_arg;
    native_param_arg = (struct flock *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_17 = fcntl(native_param_fd, native_param_cmd, native_param_arg);
    anna_entry_t *result = anna_from_int(tmp_var_17);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_dup, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_18 = dup(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_18);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_dup2, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_oldfd = anna_as_int(param[0]);
    int native_param_newfd = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_19 = dup2(native_param_oldfd, native_param_newfd);
    anna_entry_t *result = anna_from_int(tmp_var_19);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chown, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_20 = chown(native_param_path, native_param_owner, native_param_group);
    anna_entry_t *result = anna_from_int(tmp_var_20);
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchown, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_21 = fchown(native_param_fd, native_param_owner, native_param_group);
    anna_entry_t *result = anna_from_int(tmp_var_21);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lchown, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_owner = anna_as_int(param[1]);
    int native_param_group = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_22 = lchown(native_param_path, native_param_owner, native_param_group);
    anna_entry_t *result = anna_from_int(tmp_var_22);
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_chmod, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_23 = chmod(native_param_path, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_23);
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fchmod, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_mode = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_24 = fchmod(native_param_fd, native_param_mode);
    anna_entry_t *result = anna_from_int(tmp_var_24);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_symlink, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_oldpath = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    int tmp_var_25 = symlink(native_param_oldpath, native_param_newpath);
    anna_entry_t *result = anna_from_int(tmp_var_25);
    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_link, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_oldpath = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    int tmp_var_26 = link(native_param_oldpath, native_param_newpath);
    anna_entry_t *result = anna_from_int(tmp_var_26);
    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_unlink, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    int tmp_var_27 = unlink(native_param_path);
    anna_entry_t *result = anna_from_int(tmp_var_27);
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_rmdir, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_path = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    int tmp_var_28 = rmdir(native_param_path);
    anna_entry_t *result = anna_from_int(tmp_var_28);
    // Perform cleanup
    free(native_param_path);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_rename, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_oldpath = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_newpath = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    int tmp_var_29 = rename(native_param_oldpath, native_param_newpath);
    anna_entry_t *result = anna_from_int(tmp_var_29);
    // Perform cleanup
    free(native_param_oldpath);
    free(native_param_newpath);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_pipe, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    if(anna_list_ensure_capacity(anna_as_obj(param[0]), 2))
    {
        return null_entry;
    }
    size_t native_param_fd_count = anna_list_get_count(anna_as_obj(param[0]));
    int* native_param_fd = malloc(sizeof(int) * native_param_fd_count);
    if(!native_param_fd){ return null_entry; }
    int native_param_fd_idx;
    for(native_param_fd_idx=0; native_param_fd_idx < native_param_fd_count; native_param_fd_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[0]), native_param_fd_idx);
        if(tmp == null_entry)
        {
            native_param_fd[native_param_fd_idx] = 0;
        }
        else
        {
            int native_param_fd_val = anna_as_int(tmp);
            native_param_fd[native_param_fd_idx] = native_param_fd_val;
        }
    }


    // Validate parameters
    

    // Call the function
    int tmp_var_30 = pipe(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_30);
    // Perform cleanup
    
    for(native_param_fd_idx=0; native_param_fd_idx < native_param_fd_count; native_param_fd_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_fd[native_param_fd_idx]);
        anna_list_set(anna_as_obj(param[0]), native_param_fd_idx, tmp);
        
    }
    free(native_param_fd);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_lseek, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    uint64_t native_param_offset = anna_as_int(param[1]);
    int native_param_whence = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    uint64_t tmp_var_31 = lseek(native_param_fd, native_param_offset, native_param_whence);
    anna_entry_t *result = anna_from_uint64(tmp_var_31);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_sync, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    sync();
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fsync, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_32 = fsync(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_32);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_fdatasync, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_33 = fdatasync(native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_33);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_umask, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_mask = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_34 = umask(native_param_mask);
    anna_entry_t *result = anna_from_int(tmp_var_34);
    // Perform cleanup

    // Return result
    return result;
}

#define ANNA_FD_CLR(set, fd) FD_CLR(fd, set)
#define ANNA_FD_ISSET(set, fd) FD_ISSET(fd, set)
#define ANNA_FD_SET(set, fd) FD_SET(fd, set)

static int anna_fd_set_value(fd_set *set, int fd, int val)
{
    if(val)
    {
        FD_SET(fd, set);
    }
    else
    {
        FD_CLR(fd, set);
    }
    return val;
}

ANNA_VM_NATIVE(unix_i_fd_set_init, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    FD_ZERO(native_param_this);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return param[0];
}

ANNA_VM_NATIVE(unix_i_fd_set_remove, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    ANNA_FD_CLR(native_param_this, native_param_fd);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_in, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    int tmp_var_35 = ANNA_FD_ISSET(native_param_this, native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_35);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_get, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    int tmp_var_36 = ANNA_FD_ISSET(native_param_this, native_param_fd);
    anna_entry_t *result = anna_from_int(tmp_var_36);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_set, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}

    

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);
    int native_param_value = (param[2] != null_entry);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_37 = anna_fd_set_value(native_param_this, native_param_fd, native_param_value);
    anna_entry_t *result = (tmp_var_37)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_add, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_fd = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    ANNA_FD_SET(native_param_this, native_param_fd);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_fd_set_clear, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    fd_set *native_param_this;
    native_param_this = (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    FD_ZERO(native_param_this);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_io_select, 5)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_nfds = anna_as_int(param[0]);
    fd_set *native_param_readfds;
    native_param_readfds = ((param[1]) == null_entry) ? 0 : (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    fd_set *native_param_writefds;
    native_param_writefds = ((param[2]) == null_entry) ? 0 : (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);
    fd_set *native_param_exceptfds;
    native_param_exceptfds = ((param[3]) == null_entry) ? 0 : (fd_set *)anna_entry_get_addr(anna_as_obj_fast(param[3]), ANNA_MID_CSTRUCT_PAYLOAD);
    struct timeval *native_param_timeout;
    native_param_timeout = ((param[4]) == null_entry) ? 0 : (struct timeval *)anna_entry_get_addr(anna_as_obj_fast(param[4]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    
    
    
    

    // Call the function
    int tmp_var_38 = select(native_param_nfds, native_param_readfds, native_param_writefds, native_param_exceptfds, native_param_timeout);
    anna_entry_t *result = anna_from_int(tmp_var_38);
    // Perform cleanup

    // Return result
    return result;
}

void anna_io_create(anna_stack_template_t *stack);
void anna_io_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_io_type_data, stack);        
}
void anna_io_load(anna_stack_template_t *stack);
void anna_io_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"openMode", anna_open_mode_create, anna_open_mode_load},
            { L"statMode", anna_stat_mode_create, anna_stat_mode_load},
            { L"fcntlMode", anna_fcntl_mode_create, anna_fcntl_mode_load},
            { L"seekMode", anna_seek_mode_create, anna_seek_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_io_open_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_open_argn[] = {L"name", L"flags", L"mode"};
    latest_function = anna_module_function(stack, L"open", 0, &unix_i_io_open, int_type, 3, unix_i_io_open_argv, unix_i_io_open_argn, 0, L"Open a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C open function."));

    anna_type_t *unix_i_io_creat_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_creat_argn[] = {L"name", L"mode"};
    latest_function = anna_module_function(stack, L"creat", 0, &unix_i_io_creat, int_type, 2, unix_i_io_creat_argv, unix_i_io_creat_argn, 0, L"Open a file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"creat"), L"create");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C creat function."));

    anna_type_t *unix_i_io_read_argv[] = {int_type, buffer_type, int_type};
    wchar_t *unix_i_io_read_argn[] = {L"fd", L"buffer", L"count"};
    latest_function = anna_module_function(stack, L"read", 0, &unix_i_io_read, int_type, 3, unix_i_io_read_argv, unix_i_io_read_argn, 0, L"Read from a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C read function."));

    anna_type_t *unix_i_io_write_argv[] = {int_type, buffer_type, int_type};
    wchar_t *unix_i_io_write_argn[] = {L"fd", L"buffer", L"count"};
    latest_function = anna_module_function(stack, L"write", 0, &unix_i_io_write, int_type, 3, unix_i_io_write_argv, unix_i_io_write_argn, 0, L"Write to a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C write function."));

    anna_type_t *unix_i_io_close_argv[] = {int_type};
    wchar_t *unix_i_io_close_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"close", 0, &unix_i_io_close, object_type, 1, unix_i_io_close_argv, unix_i_io_close_argn, 0, L"Close a file descriptor.");
   anna_function_document(latest_function,anna_intern_static(L"Equivalent to the C close function."));

    anna_member_create_blob(unix_stat_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct stat));

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"dev"),
        int_type, unix_i_stat_dev_getter, 0, L"ID of device containing file");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"ino"),
        int_type, unix_i_stat_ino_getter, 0, L"Inode number");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"mode"),
        int_type, unix_i_stat_mode_getter, 0, L"File protection mask");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"nlink"),
        int_type, unix_i_stat_nlink_getter, 0, L"Number of hard links.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"uid"),
        int_type, unix_i_stat_uid_getter, 0, L"User ID of owner.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"gid"),
        int_type, unix_i_stat_gid_getter, 0, L"Group ID of owner.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"rdev"),
        int_type, unix_i_stat_rdev_getter, 0, L"Device ID.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"size"),
        int_type, unix_i_stat_size_getter, 0, L"Total size in bytes.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"blksize"),
        int_type, unix_i_stat_blksize_getter, 0, L"Block size for file system IO.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"blocks"),
        int_type, unix_i_stat_blocks_getter, 0, L"Number of 512 byte blocks allocated.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"atime"),
        int_type, unix_i_stat_atime_getter, 0, L"Time of latest acccess.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"mtime"),
        int_type, unix_i_stat_mtime_getter, 0, L"Time of latest modification.");

    anna_member_create_native_property(
        unix_stat_type, anna_mid_get(L"ctime"),
        int_type, unix_i_stat_ctime_getter, 0, L"Time of latest change.");
    anna_member_create_native_method(
	unix_stat_type, anna_mid_get(L"__init__"), 0,
	&unix_i_stat_init, object_type, 1, &unix_stat_type, this_argn, 0, 0);    
    anna_type_document(
            unix_stat_type, L"A structure representing the status of a file.");
    anna_type_document(
            unix_stat_type, L"This is a straight conversion of the C struct stat.");

    anna_type_t *unix_i_io_stat_argv[] = {string_type, unix_stat_type};
    wchar_t *unix_i_io_stat_argn[] = {L"path", L"buf"};
    latest_function = anna_module_function(stack, L"stat", 0, &unix_i_io_stat, object_type, 2, unix_i_io_stat_argv, unix_i_io_stat_argn, 0, L"Check the status of file with the specified path. Equivalanet to the C stat function.");

    anna_type_t *unix_i_io_lstat_argv[] = {string_type, unix_stat_type};
    wchar_t *unix_i_io_lstat_argn[] = {L"path", L"buf"};
    latest_function = anna_module_function(stack, L"lstat", 0, &unix_i_io_lstat, object_type, 2, unix_i_io_lstat_argv, unix_i_io_lstat_argn, 0, L"Check the status of file with the specified path, without following symlinks. Equivalanet to the C lstat function.");

    anna_type_t *unix_i_io_fstat_argv[] = {int_type, unix_stat_type};
    wchar_t *unix_i_io_fstat_argn[] = {L"fd", L"buf"};
    latest_function = anna_module_function(stack, L"fstat", 0, &unix_i_io_fstat, object_type, 2, unix_i_io_fstat_argv, unix_i_io_fstat_argn, 0, L"Check the status of file with the specified file descriptor. Equivalanet to the C fstat function.");

    anna_type_t *unix_i_io_mkdir_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_mkdir_argn[] = {L"path", L"mode"};
    latest_function = anna_module_function(stack, L"mkdir", 0, &unix_i_io_mkdir, object_type, 2, unix_i_io_mkdir_argv, unix_i_io_mkdir_argn, 0, L"Create a new driectory with the specified path. Equivalanet to the C mkdir function.");
    anna_module_const_int(stack, L"standardInput", 0, L"File descriptor for standard input.");
    anna_module_const_int(stack, L"standardOutput", 1, L"File descriptor for standard output.");
    anna_module_const_int(stack, L"standardError", 2, L"File descriptor for error output");

    anna_type_t *unix_i_io_getcwd_argv[] = {buffer_type, int_type};
    wchar_t *unix_i_io_getcwd_argn[] = {L"buf", L"size"};
    latest_function = anna_module_function(stack, L"getcwd", 0, &unix_i_io_getcwd, object_type, 2, unix_i_io_getcwd_argv, unix_i_io_getcwd_argn, 0, L"Get current working directory.");

    anna_type_t *unix_i_io_chdir_argv[] = {string_type};
    wchar_t *unix_i_io_chdir_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"chdir", 0, &unix_i_io_chdir, object_type, 1, unix_i_io_chdir_argv, unix_i_io_chdir_argn, 0, L"Change working directory.");

    anna_type_t *unix_i_io_chroot_argv[] = {string_type};
    wchar_t *unix_i_io_chroot_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"chroot", 0, &unix_i_io_chroot, object_type, 1, unix_i_io_chroot_argv, unix_i_io_chroot_argn, 0, L"Change root directory.");

    anna_type_t *unix_i_io_fchdir_argv[] = {int_type};
    wchar_t *unix_i_io_fchdir_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"fchdir", 0, &unix_i_io_fchdir, object_type, 1, unix_i_io_fchdir_argv, unix_i_io_fchdir_argn, 0, L"Change working directory.");

    anna_member_create_blob(unix_f_lock_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct flock));

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"type"),
        int_type, unix_i_f_lock_type_getter, 0, L"Type of lock: F_RDLCK, F_WRLCK, F_UNLCK.");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"whence"),
        int_type, unix_i_f_lock_whence_getter, 0, L"How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END.");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"start"),
        int_type, unix_i_f_lock_start_getter, 0, L"Starting offset for lock");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"len"),
        int_type, unix_i_f_lock_len_getter, 0, L"Number of bytes to lock");

    anna_member_create_native_property(
        unix_f_lock_type, anna_mid_get(L"pid"),
        int_type, unix_i_f_lock_pid_getter, 0, L"PID of process blocking our lock (F_GETLK only)");
    anna_member_create_native_method(
	unix_f_lock_type, anna_mid_get(L"__init__"), 0,
	&unix_i_f_lock_init, object_type, 1, &unix_f_lock_type, this_argn, 0, 0);    
    anna_type_document(
            unix_f_lock_type, L"File lock information");

    anna_type_t *unix_i_io_fcntl_void_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_fcntl_void_argn[] = {L"fd", L"cmd"};
    latest_function = anna_module_function(stack, L"fcntlVoid", 0, &unix_i_io_fcntl_void, int_type, 2, unix_i_io_fcntl_void_argv, unix_i_io_fcntl_void_argn, 0, L"Manipulate file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"fcntlVoid"), L"fcntl");

    anna_type_t *unix_i_io_fcntl_int_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_fcntl_int_argn[] = {L"fd", L"cmd", L"arg"};
    latest_function = anna_module_function(stack, L"fcntlInt", 0, &unix_i_io_fcntl_int, int_type, 3, unix_i_io_fcntl_int_argv, unix_i_io_fcntl_int_argn, 0, L"Manipulate file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"fcntlInt"), L"fcntl");

    anna_type_t *unix_i_io_fcntl_f_lock_argv[] = {int_type, int_type, unix_f_lock_type};
    wchar_t *unix_i_io_fcntl_f_lock_argn[] = {L"fd", L"cmd", L"arg"};
    latest_function = anna_module_function(stack, L"fcntlFLock", 0, &unix_i_io_fcntl_f_lock, int_type, 3, unix_i_io_fcntl_f_lock_argv, unix_i_io_fcntl_f_lock_argn, 0, L"Manipulate file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"fcntlFLock"), L"fcntl");

    anna_type_t *unix_i_io_dup_argv[] = {int_type};
    wchar_t *unix_i_io_dup_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"dup", 0, &unix_i_io_dup, int_type, 1, unix_i_io_dup_argv, unix_i_io_dup_argn, 0, L"Duplicate a file descriptor.");

    anna_type_t *unix_i_io_dup2_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_dup2_argn[] = {L"oldfd", L"newfd"};
    latest_function = anna_module_function(stack, L"dup2", 0, &unix_i_io_dup2, int_type, 2, unix_i_io_dup2_argv, unix_i_io_dup2_argn, 0, L"Duplicate a file descriptor.");
    anna_member_alias(stack_type, anna_mid_get(L"dup2"), L"dup");

    anna_type_t *unix_i_io_chown_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_chown_argn[] = {L"path", L"owner", L"group"};
    latest_function = anna_module_function(stack, L"chown", 0, &unix_i_io_chown, int_type, 3, unix_i_io_chown_argv, unix_i_io_chown_argn, 0, L"Change file owner and group.");

    anna_type_t *unix_i_io_fchown_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_fchown_argn[] = {L"fd", L"owner", L"group"};
    latest_function = anna_module_function(stack, L"fchown", 0, &unix_i_io_fchown, int_type, 3, unix_i_io_fchown_argv, unix_i_io_fchown_argn, 0, L"Change file owner and group.");

    anna_type_t *unix_i_io_lchown_argv[] = {string_type, int_type, int_type};
    wchar_t *unix_i_io_lchown_argn[] = {L"path", L"owner", L"group"};
    latest_function = anna_module_function(stack, L"lchown", 0, &unix_i_io_lchown, int_type, 3, unix_i_io_lchown_argv, unix_i_io_lchown_argn, 0, L"Change file owner and group.");

    anna_type_t *unix_i_io_chmod_argv[] = {string_type, int_type};
    wchar_t *unix_i_io_chmod_argn[] = {L"path", L"mode"};
    latest_function = anna_module_function(stack, L"chmod", 0, &unix_i_io_chmod, int_type, 2, unix_i_io_chmod_argv, unix_i_io_chmod_argn, 0, L"Change permissions of a file.");

    anna_type_t *unix_i_io_fchmod_argv[] = {int_type, int_type};
    wchar_t *unix_i_io_fchmod_argn[] = {L"fd", L"mode"};
    latest_function = anna_module_function(stack, L"fchmod", 0, &unix_i_io_fchmod, int_type, 2, unix_i_io_fchmod_argv, unix_i_io_fchmod_argn, 0, L"Change permissions of a file.");

    anna_type_t *unix_i_io_symlink_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_symlink_argn[] = {L"oldpath", L"newpath"};
    latest_function = anna_module_function(stack, L"symlink", 0, &unix_i_io_symlink, int_type, 2, unix_i_io_symlink_argv, unix_i_io_symlink_argn, 0, L"Create a symbolic link to a file.");

    anna_type_t *unix_i_io_link_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_link_argn[] = {L"oldpath", L"newpath"};
    latest_function = anna_module_function(stack, L"link", 0, &unix_i_io_link, int_type, 2, unix_i_io_link_argv, unix_i_io_link_argn, 0, L"Create anew name for a file.");

    anna_type_t *unix_i_io_unlink_argv[] = {string_type};
    wchar_t *unix_i_io_unlink_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"unlink", 0, &unix_i_io_unlink, int_type, 1, unix_i_io_unlink_argv, unix_i_io_unlink_argn, 0, L"Remove a name and possibly a file.");

    anna_type_t *unix_i_io_rmdir_argv[] = {string_type};
    wchar_t *unix_i_io_rmdir_argn[] = {L"path"};
    latest_function = anna_module_function(stack, L"rmdir", 0, &unix_i_io_rmdir, int_type, 1, unix_i_io_rmdir_argv, unix_i_io_rmdir_argn, 0, L"Remove a directory.");

    anna_type_t *unix_i_io_rename_argv[] = {string_type, string_type};
    wchar_t *unix_i_io_rename_argn[] = {L"oldpath", L"newpath"};
    latest_function = anna_module_function(stack, L"rename", 0, &unix_i_io_rename, int_type, 2, unix_i_io_rename_argv, unix_i_io_rename_argn, 0, L"Rename a file.");

    anna_type_t *unix_i_io_pipe_argv[] = {anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_io_pipe_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"pipe", 0, &unix_i_io_pipe, int_type, 1, unix_i_io_pipe_argv, unix_i_io_pipe_argn, 0, L"Create a pipe.");
   anna_function_document(latest_function,anna_intern_static(L"The input and output ends of the pipe are stored in the first two elements of the list fd. If fd is not large enough to hold two elements, it will be enlarged."));

    anna_type_t *unix_i_io_lseek_argv[] = {int_type, int_type, int_type};
    wchar_t *unix_i_io_lseek_argn[] = {L"fd", L"offset", L"whence"};
    latest_function = anna_module_function(stack, L"lseek", 0, &unix_i_io_lseek, int_type, 3, unix_i_io_lseek_argv, unix_i_io_lseek_argn, 0, L"Reposition read/write file offset.");

    anna_type_t *unix_i_io_sync_argv[] = {};
    wchar_t *unix_i_io_sync_argn[] = {};
    latest_function = anna_module_function(stack, L"sync", 0, &unix_i_io_sync, object_type, 0, unix_i_io_sync_argv, unix_i_io_sync_argn, 0, L"Flush file system buffers.");

    anna_type_t *unix_i_io_fsync_argv[] = {int_type};
    wchar_t *unix_i_io_fsync_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"fsync", 0, &unix_i_io_fsync, int_type, 1, unix_i_io_fsync_argv, unix_i_io_fsync_argn, 0, L"Synchronize a file's in-core state with storage device.");

    anna_type_t *unix_i_io_fdatasync_argv[] = {int_type};
    wchar_t *unix_i_io_fdatasync_argn[] = {L"fd"};
    latest_function = anna_module_function(stack, L"fdatasync", 0, &unix_i_io_fdatasync, int_type, 1, unix_i_io_fdatasync_argv, unix_i_io_fdatasync_argn, 0, L"Synchronize a file's in-core state with storage device.");

    anna_type_t *unix_i_io_umask_argv[] = {int_type};
    wchar_t *unix_i_io_umask_argn[] = {L"mask"};
    latest_function = anna_module_function(stack, L"umask", 0, &unix_i_io_umask, int_type, 1, unix_i_io_umask_argv, unix_i_io_umask_argn, 0, L"Set a new value for file mode creation mask and return the old value.");

    anna_member_create_blob(unix_fd_set_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(fd_set));

    anna_type_t *unix_i_fd_set_init_argv[] = {unix_fd_set_type};
    wchar_t *unix_i_fd_set_init_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__init__"), 0, 
        &unix_i_fd_set_init, object_type, 1, unix_i_fd_set_init_argv, unix_i_fd_set_init_argn, 0, L"Create an empty new file descriptor set.");

    anna_type_t *unix_i_fd_set_remove_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_remove_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"remove"), 0, 
        &unix_i_fd_set_remove, object_type, 2, unix_i_fd_set_remove_argv, unix_i_fd_set_remove_argn, 0, L"Remove the specified file descriptor from the set.");

    anna_type_t *unix_i_fd_set_in_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_in_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__in__"), 0, 
        &unix_i_fd_set_in, int_type, 2, unix_i_fd_set_in_argv, unix_i_fd_set_in_argn, 0, L"Check if the specified file descriptor is in the set.");

    anna_type_t *unix_i_fd_set_get_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_get_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__get__"), 0, 
        &unix_i_fd_set_get, int_type, 2, unix_i_fd_set_get_argv, unix_i_fd_set_get_argn, 0, L"Check if the specified file descriptor is in the set.");

    anna_type_t *unix_i_fd_set_set_argv[] = {unix_fd_set_type, int_type, object_type};
    wchar_t *unix_i_fd_set_set_argn[] = {L"this", L"fd", L"value"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"__set__"), 0, 
        &unix_i_fd_set_set, object_type, 3, unix_i_fd_set_set_argv, unix_i_fd_set_set_argn, 0, L"If value is non-null, add the specified file descriptor to the set. Otherwise, remove it.");

    anna_type_t *unix_i_fd_set_add_argv[] = {unix_fd_set_type, int_type};
    wchar_t *unix_i_fd_set_add_argn[] = {L"this", L"fd"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"add"), 0, 
        &unix_i_fd_set_add, object_type, 2, unix_i_fd_set_add_argv, unix_i_fd_set_add_argn, 0, L"Add the specified file descriptor to the set.");

    anna_type_t *unix_i_fd_set_clear_argv[] = {unix_fd_set_type};
    wchar_t *unix_i_fd_set_clear_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_fd_set_type, anna_mid_get(L"clear"), 0, 
        &unix_i_fd_set_clear, object_type, 1, unix_i_fd_set_clear_argv, unix_i_fd_set_clear_argn, 0, L"Remove all file descriptors from this set.");
    anna_type_document(
            unix_fd_set_type, L"A set of file descriptors. Used by unix.io.select.");

    anna_type_t *unix_i_io_select_argv[] = {int_type, unix_fd_set_type, unix_fd_set_type, unix_fd_set_type, unix_time_val_type};
    wchar_t *unix_i_io_select_argn[] = {L"nfds", L"readfds", L"writefds", L"exceptfds", L"timeout"};
    latest_function = anna_module_function(stack, L"select", 0, &unix_i_io_select, int_type, 5, unix_i_io_select_argv, unix_i_io_select_argn, 0, L"Select allows a program to monitor multiple file descriptors");
   anna_function_document(latest_function,anna_intern_static(L"Calling select will cause the process to wait until one \nor more of the file descriptors become ready for some class of I/O operation, \nor optionally, until the specified amount of time has passed."));
    anna_stack_document(stack, L"The unix.io module contains low level wrappers for basic unix functionality revolving around input and output.");
    anna_stack_document(stack, L"Unix input/output centers around file descriptors. File descriptors are small, positive integers that can represent open files, directories, pipes or even network sockets.");

    anna_type_data_register(anna_io_type_data, stack);
}
const static anna_type_data_t anna_proc_type_data[] = 
{
    { &unix_signal_set_type, L"SignalSet" },
    { &unix_signal_info_fd_type, L"SignalInfoFd" },
};
const static anna_type_data_t anna_signal_type_data[] = 
{
};

void anna_signal_create(anna_stack_template_t *stack);
void anna_signal_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_signal_type_data, stack);        
}
void anna_signal_load(anna_stack_template_t *stack);
void anna_signal_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"hup", SIGHUP, L"The HUP signal");
    anna_module_const_int(stack, L"int", SIGINT, L"The INT signal");
    anna_module_const_int(stack, L"quit", SIGQUIT, L"The QUIT signal");
    anna_module_const_int(stack, L"ill", SIGILL, L"The ILL signal");
    anna_module_const_int(stack, L"abrt", SIGABRT, L"The ABRT signal");
    anna_module_const_int(stack, L"fpe", SIGFPE, L"The FPE signal");
    anna_module_const_int(stack, L"kill", SIGKILL, L"The KILL signal");
    anna_module_const_int(stack, L"segv", SIGSEGV, L"The SEGV signal");
    anna_module_const_int(stack, L"pipe", SIGPIPE, L"The PIPE signal");
    anna_module_const_int(stack, L"alrm", SIGALRM, L"The ALRM signal");
    anna_module_const_int(stack, L"term", SIGTERM, L"The TERM signal");
    anna_module_const_int(stack, L"usr1", SIGUSR1, L"The USR1 signal");
    anna_module_const_int(stack, L"usr2", SIGUSR2, L"The USR2 signal");
    anna_module_const_int(stack, L"chld", SIGCHLD, L"The CHLD signal");
    anna_module_const_int(stack, L"cont", SIGCONT, L"The CONT signal");
    anna_module_const_int(stack, L"stop", SIGSTOP, L"The STOP signal");
    anna_module_const_int(stack, L"tstp", SIGTSTP, L"The TSTP signal");
    anna_module_const_int(stack, L"ttin", SIGTTIN, L"The TTIN signal");
    anna_module_const_int(stack, L"ttou", SIGTTOU, L"The TTOU signal");
    anna_module_const_int(stack, L"bus", SIGBUS, L"The BUS signal");
    anna_module_const_int(stack, L"poll", SIGPOLL, L"The POLL signal");
    anna_module_const_int(stack, L"prof", SIGPROF, L"The PROF signal");
    anna_module_const_int(stack, L"sys", SIGSYS, L"The SYS signal");
    anna_module_const_int(stack, L"trap", SIGTRAP, L"The TRAP signal");
    anna_module_const_int(stack, L"urg", SIGURG, L"The URG signal");
    anna_module_const_int(stack, L"vtalrm", SIGVTALRM, L"The VTALRM signal");
    anna_module_const_int(stack, L"xcpu", SIGXCPU, L"The XCPU signal");
    anna_module_const_int(stack, L"xfsz", SIGXFSZ, L"The XFSZ signal");
    anna_module_const_int(stack, L"iot", SIGIOT, L"The IOT signal");
    anna_module_const_int(stack, L"stkflt", SIGSTKFLT, L"The STKFLT signal");
    anna_module_const_int(stack, L"io", SIGIO, L"The IO signal");
    anna_module_const_int(stack, L"cld", SIGCLD, L"The CLD signal");
    anna_module_const_int(stack, L"pwr", SIGPWR, L"The PWR signal");
    anna_module_const_int(stack, L"winch", SIGWINCH, L"The WINCH signal");
    anna_module_const_int(stack, L"unused", SIGUNUSED, L"The UNUSED signal");
    anna_stack_document(stack, L"All known signals");

    anna_type_data_register(anna_signal_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_proc_exec, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_filename = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    size_t native_param_argv_count = anna_list_get_count(anna_as_obj(param[1]));
    char ** native_param_argv = malloc(sizeof(char *) * native_param_argv_count);
    if(!native_param_argv){ return null_entry; }
    int native_param_argv_idx;
    for(native_param_argv_idx=0; native_param_argv_idx < native_param_argv_count; native_param_argv_idx++)
    {
        char *native_param_argv_val = (anna_list_get(anna_as_obj(param[1]), native_param_argv_idx) == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(anna_list_get(anna_as_obj(param[1]), native_param_argv_idx)));
        native_param_argv[native_param_argv_idx] = native_param_argv_val;
    }

    size_t native_param_envp_count = anna_list_get_count(anna_as_obj(param[2]));
    char ** native_param_envp = malloc(sizeof(char *) * native_param_envp_count);
    if(!native_param_envp){ return null_entry; }
    int native_param_envp_idx;
    for(native_param_envp_idx=0; native_param_envp_idx < native_param_envp_count; native_param_envp_idx++)
    {
        char *native_param_envp_val = (anna_list_get(anna_as_obj(param[2]), native_param_envp_idx) == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(anna_list_get(anna_as_obj(param[2]), native_param_envp_idx)));
        native_param_envp[native_param_envp_idx] = native_param_envp_val;
    }


    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_39 = execve(native_param_filename, native_param_argv, native_param_envp);
    anna_entry_t *result = anna_from_int(tmp_var_39);
    // Perform cleanup
    free(native_param_filename);
    
    for(native_param_argv_idx=0; native_param_argv_idx < native_param_argv_count; native_param_argv_idx++)
    {
        free(native_param_argv[native_param_argv_idx]);
    }
    free(native_param_argv);

    
    for(native_param_envp_idx=0; native_param_envp_idx < native_param_envp_count; native_param_envp_idx++)
    {
        free(native_param_envp[native_param_envp_idx]);
    }
    free(native_param_envp);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_exit, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_status = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    exit(native_param_status);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_fork, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_40 = fork();
    anna_entry_t *result = anna_from_int(tmp_var_40);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_kill, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    int native_param_sig = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_41 = kill(native_param_pid, native_param_sig);
    anna_entry_t *result = anna_from_int(tmp_var_41);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getsid, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_42 = getsid(native_param_pid);
    anna_entry_t *result = anna_from_int(tmp_var_42);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_setsid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_43 = setsid();
    anna_entry_t *result = anna_from_int(tmp_var_43);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getpid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_44 = getpid();
    anna_entry_t *result = anna_from_int(tmp_var_44);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_getppid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_45 = getppid();
    anna_entry_t *result = anna_from_int(tmp_var_45);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_wait, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    if(anna_list_ensure_capacity(anna_as_obj(param[0]), 1))
    {
        return null_entry;
    }
    size_t native_param_status_count = anna_list_get_count(anna_as_obj(param[0]));
    int* native_param_status = malloc(sizeof(int) * native_param_status_count);
    if(!native_param_status){ return null_entry; }
    int native_param_status_idx;
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[0]), native_param_status_idx);
        if(tmp == null_entry)
        {
            native_param_status[native_param_status_idx] = 0;
        }
        else
        {
            int native_param_status_val = anna_as_int(tmp);
            native_param_status[native_param_status_idx] = native_param_status_val;
        }
    }


    // Validate parameters
    

    // Call the function
    int tmp_var_46 = wait(native_param_status);
    anna_entry_t *result = anna_from_int(tmp_var_46);
    // Perform cleanup
    
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_status[native_param_status_idx]);
        anna_list_set(anna_as_obj(param[0]), native_param_status_idx, tmp);
        
    }
    free(native_param_status);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_waitpid, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), 1))
    {
        return null_entry;
    }
    size_t native_param_status_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_status = malloc(sizeof(int) * native_param_status_count);
    if(!native_param_status){ return null_entry; }
    int native_param_status_idx;
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_status_idx);
        if(tmp == null_entry)
        {
            native_param_status[native_param_status_idx] = 0;
        }
        else
        {
            int native_param_status_val = anna_as_int(tmp);
            native_param_status[native_param_status_idx] = native_param_status_val;
        }
    }

    int native_param_options = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_47 = waitpid(native_param_pid, native_param_status, native_param_options);
    anna_entry_t *result = anna_from_int(tmp_var_47);
    // Perform cleanup
    
    for(native_param_status_idx=0; native_param_status_idx < native_param_status_count; native_param_status_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_status[native_param_status_idx]);
        anna_list_set(anna_as_obj(param[1]), native_param_status_idx, tmp);
        
    }
    free(native_param_status);


    // Return result
    return result;
}

static int anna_signalset_set(sigset_t *set, int signal, int value)
{
    if(value)
    {
        sigaddset(set, signal);
    }
    else
    {
        sigdelset(set, signal);
    }
    return value;
}

ANNA_VM_NATIVE(unix_i_signal_set_init, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    sigemptyset(native_param_this);
    anna_entry_t *result = null_entry;

    // Perform cleanup

    // Return result
    return param[0];
}

ANNA_VM_NATIVE(unix_i_signal_set_clear, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    int tmp_var_48 = sigemptyset(native_param_this);
    anna_entry_t *result = anna_from_int(tmp_var_48);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_all, 1)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters

    // Call the function
    int tmp_var_49 = sigfillset(native_param_this);
    anna_entry_t *result = anna_from_int(tmp_var_49);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_add, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    int tmp_var_50 = sigaddset(native_param_this, native_param_signal);
    anna_entry_t *result = anna_from_int(tmp_var_50);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_remove, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    int tmp_var_51 = sigdelset(native_param_this, native_param_signal);
    anna_entry_t *result = anna_from_int(tmp_var_51);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_in, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    int tmp_var_52 = sigismember(native_param_this, native_param_signal);
    anna_entry_t *result = (tmp_var_52)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_get, 2)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);

    // Validate parameters
    

    // Call the function
    int tmp_var_53 = sigismember(native_param_this, native_param_signal);
    anna_entry_t *result = (tmp_var_53)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_set_set, 3)
{
    // Validate parameters
    if(param[0] == null_entry){return null_entry;}
        if(param[1] == null_entry){return null_entry;}

    

    // Mangle input parameters
    sigset_t *native_param_this;
    native_param_this = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_signal = anna_as_int(param[1]);
    int native_param_value = (param[2] != null_entry);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_54 = anna_signalset_set(native_param_this, native_param_signal, native_param_value);
    anna_entry_t *result = (tmp_var_54)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_proc_signalfd, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    sigset_t *native_param_mask;
    native_param_mask = (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    int native_param_flags = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_55 = signalfd(native_param_fd, native_param_mask, native_param_flags);
    anna_entry_t *result = anna_from_int(tmp_var_55);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_signal_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_signo);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_signal_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_signo = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_code_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_code);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_code_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_code = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_pid_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_pid);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_pid_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_pid = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_uid_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_uid);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_uid_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_uid = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_fd_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_fd);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_fd_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_fd = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_tid_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_tid);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_tid_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_tid = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_band_getter, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->ssi_band);
    return result;
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_band_setter, 2)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->ssi_band = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_signal_info_fd_init, 1)
{
    struct signalfd_siginfo *data;
    data = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct signalfd_siginfo));
    return param[0];
}
const static anna_type_data_t anna_signalfd_flag_type_data[] = 
{
};

void anna_signalfd_flag_create(anna_stack_template_t *stack);
void anna_signalfd_flag_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_signalfd_flag_type_data, stack);        
}
void anna_signalfd_flag_load(anna_stack_template_t *stack);
void anna_signalfd_flag_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"nonBlock", SFD_NONBLOCK, L"The resulting file descriptor is non-blocking");
    anna_module_const_int(stack, L"closeOnExec", SFD_CLOEXEC, 0);
    anna_stack_document(stack, L"Flags determining the mode for unix.proc.signalfd");

    anna_type_data_register(anna_signalfd_flag_type_data, stack);
}
const static anna_type_data_t anna_sigprocmask_flag_type_data[] = 
{
};

void anna_sigprocmask_flag_create(anna_stack_template_t *stack);
void anna_sigprocmask_flag_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_sigprocmask_flag_type_data, stack);        
}
void anna_sigprocmask_flag_load(anna_stack_template_t *stack);
void anna_sigprocmask_flag_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"block", SIG_BLOCK, L"Block all the specified signals in addition to signals currently blocked.");
    anna_module_const_int(stack, L"unblock", SIG_UNBLOCK, L"Stop blocking the specified signals.");
    anna_module_const_int(stack, L"setMask", SIG_SETMASK, L"Set the exact new signal block mask.");
    anna_stack_document(stack, L"Flags determining the mode for unix.iosigprocmask");

    anna_type_data_register(anna_sigprocmask_flag_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_proc_sigprocmask, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_how = anna_as_int(param[0]);
    sigset_t *native_param_set;
    native_param_set = ((param[1]) == null_entry) ? 0 : (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);
    sigset_t *native_param_old;
    native_param_old = ((param[2]) == null_entry) ? 0 : (sigset_t *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_56 = sigprocmask(native_param_how, native_param_set, native_param_old);
    anna_entry_t *result = anna_from_int(tmp_var_56);
    // Perform cleanup

    // Return result
    return result;
}

int anna_read_signal(int fd, struct signalfd_siginfo *info)
{
    return read(fd, info, sizeof(struct signalfd_siginfo)) <= 0;
}

ANNA_VM_NATIVE(unix_i_proc_read_signal, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    struct signalfd_siginfo *native_param_info;
    native_param_info = (struct signalfd_siginfo *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_57 = anna_read_signal(native_param_fd, native_param_info);
    anna_entry_t *result = (tmp_var_57)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

void anna_proc_create(anna_stack_template_t *stack);
void anna_proc_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_proc_type_data, stack);        
}
void anna_proc_load(anna_stack_template_t *stack);
void anna_proc_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"signal", anna_signal_create, anna_signal_load},
            { L"signalfdFlag", anna_signalfd_flag_create, anna_signalfd_flag_load},
            { L"sigprocmaskFlag", anna_sigprocmask_flag_create, anna_sigprocmask_flag_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_proc_exec_argv[] = {string_type, anna_list_type_get_any(string_type), anna_list_type_get_any(string_type)};
    wchar_t *unix_i_proc_exec_argn[] = {L"filename", L"argv", L"envp"};
    latest_function = anna_module_function(stack, L"exec", 0, &unix_i_proc_exec, int_type, 3, unix_i_proc_exec_argv, unix_i_proc_exec_argn, 0, L"Execute the specified program.");

    anna_type_t *unix_i_proc_exit_argv[] = {int_type};
    wchar_t *unix_i_proc_exit_argn[] = {L"status"};
    latest_function = anna_module_function(stack, L"exit", 0, &unix_i_proc_exit, object_type, 1, unix_i_proc_exit_argv, unix_i_proc_exit_argn, 0, L"Terminate the calling process.");

    anna_type_t *unix_i_proc_fork_argv[] = {};
    wchar_t *unix_i_proc_fork_argn[] = {};
    latest_function = anna_module_function(stack, L"fork", 0, &unix_i_proc_fork, int_type, 0, unix_i_proc_fork_argv, unix_i_proc_fork_argn, 0, L"Create a child process.");

    anna_type_t *unix_i_proc_kill_argv[] = {int_type, int_type};
    wchar_t *unix_i_proc_kill_argn[] = {L"pid", L"sig"};
    latest_function = anna_module_function(stack, L"kill", 0, &unix_i_proc_kill, int_type, 2, unix_i_proc_kill_argv, unix_i_proc_kill_argn, 0, L"Send a signal to a process.");

    anna_type_t *unix_i_proc_getsid_argv[] = {int_type};
    wchar_t *unix_i_proc_getsid_argn[] = {L"pid"};
    latest_function = anna_module_function(stack, L"getsid", 0, &unix_i_proc_getsid, int_type, 1, unix_i_proc_getsid_argv, unix_i_proc_getsid_argn, 0, L"Get session ID.");

    anna_type_t *unix_i_proc_setsid_argv[] = {};
    wchar_t *unix_i_proc_setsid_argn[] = {};
    latest_function = anna_module_function(stack, L"setsid", 0, &unix_i_proc_setsid, int_type, 0, unix_i_proc_setsid_argv, unix_i_proc_setsid_argn, 0, L"Set session ID.");

    anna_type_t *unix_i_proc_getpid_argv[] = {};
    wchar_t *unix_i_proc_getpid_argn[] = {};
    latest_function = anna_module_function(stack, L"getpid", 0, &unix_i_proc_getpid, int_type, 0, unix_i_proc_getpid_argv, unix_i_proc_getpid_argn, 0, L"Get process ID.");

    anna_type_t *unix_i_proc_getppid_argv[] = {};
    wchar_t *unix_i_proc_getppid_argn[] = {};
    latest_function = anna_module_function(stack, L"getppid", 0, &unix_i_proc_getppid, int_type, 0, unix_i_proc_getppid_argv, unix_i_proc_getppid_argn, 0, L"Get parent process ID.");

    anna_type_t *unix_i_proc_wait_argv[] = {anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_proc_wait_argn[] = {L"status"};
    latest_function = anna_module_function(stack, L"wait", 0, &unix_i_proc_wait, int_type, 1, unix_i_proc_wait_argv, unix_i_proc_wait_argn, 0, L"Wait for a process to change state.");

    anna_type_t *unix_i_proc_waitpid_argv[] = {int_type, anna_list_type_get_mutable(int_type), int_type};
    wchar_t *unix_i_proc_waitpid_argn[] = {L"pid", L"status", L"options"};
    latest_function = anna_module_function(stack, L"waitpid", 0, &unix_i_proc_waitpid, int_type, 3, unix_i_proc_waitpid_argv, unix_i_proc_waitpid_argn, 0, L"Wait for a process to change state.");

    anna_member_create_blob(unix_signal_set_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(sigset_t));

    anna_type_t *unix_i_signal_set_init_argv[] = {unix_signal_set_type};
    wchar_t *unix_i_signal_set_init_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__init__"), 0, 
        &unix_i_signal_set_init, object_type, 1, unix_i_signal_set_init_argv, unix_i_signal_set_init_argn, 0, L"Create an empty new set");

    anna_type_t *unix_i_signal_set_clear_argv[] = {unix_signal_set_type};
    wchar_t *unix_i_signal_set_clear_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"clear"), 0, 
        &unix_i_signal_set_clear, int_type, 1, unix_i_signal_set_clear_argv, unix_i_signal_set_clear_argn, 0, L"Remove all signals from the set");

    anna_type_t *unix_i_signal_set_all_argv[] = {unix_signal_set_type};
    wchar_t *unix_i_signal_set_all_argn[] = {L"this"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"all"), 0, 
        &unix_i_signal_set_all, int_type, 1, unix_i_signal_set_all_argv, unix_i_signal_set_all_argn, 0, L"Add all signals to the set");

    anna_type_t *unix_i_signal_set_add_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_add_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"add"), 0, 
        &unix_i_signal_set_add, int_type, 2, unix_i_signal_set_add_argv, unix_i_signal_set_add_argn, 0, L"Add the specified signal to the set");

    anna_type_t *unix_i_signal_set_remove_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_remove_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"remove"), 0, 
        &unix_i_signal_set_remove, int_type, 2, unix_i_signal_set_remove_argv, unix_i_signal_set_remove_argn, 0, L"Remove the specified signal from the set.");

    anna_type_t *unix_i_signal_set_in_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_in_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__in__"), 0, 
        &unix_i_signal_set_in, object_type, 2, unix_i_signal_set_in_argv, unix_i_signal_set_in_argn, 0, L"Check if the specified signal is in the set");

    anna_type_t *unix_i_signal_set_get_argv[] = {unix_signal_set_type, int_type};
    wchar_t *unix_i_signal_set_get_argn[] = {L"this", L"signal"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__get__"), 0, 
        &unix_i_signal_set_get, object_type, 2, unix_i_signal_set_get_argv, unix_i_signal_set_get_argn, 0, L"Check if the specified signal is in the set");

    anna_type_t *unix_i_signal_set_set_argv[] = {unix_signal_set_type, int_type, object_type};
    wchar_t *unix_i_signal_set_set_argn[] = {L"this", L"signal", L"value"};
    anna_member_create_native_method(
        unix_signal_set_type, anna_mid_get(L"__set__"), 0, 
        &unix_i_signal_set_set, object_type, 3, unix_i_signal_set_set_argv, unix_i_signal_set_set_argn, 0, L"If value is non-null, add the specified signal to the set. Otherwise, remove it.");
    anna_type_document(
            unix_signal_set_type, L"A set of signals. Used by the unix.proc.signalfd and unix.proc.sigprocmask functions.");

    anna_type_t *unix_i_proc_signalfd_argv[] = {int_type, unix_signal_set_type, int_type};
    wchar_t *unix_i_proc_signalfd_argn[] = {L"fd", L"mask", L"flags"};
    latest_function = anna_module_function(stack, L"signalfd", 0, &unix_i_proc_signalfd, int_type, 3, unix_i_proc_signalfd_argv, unix_i_proc_signalfd_argn, 0, L"Create a file descriptor for accepting signals.");

    anna_member_create_blob(unix_signal_info_fd_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct signalfd_siginfo));

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"signal"),
        int_type, unix_i_signal_info_fd_signal_getter, unix_i_signal_info_fd_signal_setter, L"Signal number.");

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"code"),
        int_type, unix_i_signal_info_fd_code_getter, unix_i_signal_info_fd_code_setter, L"Signal code.");

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"pid"),
        int_type, unix_i_signal_info_fd_pid_getter, unix_i_signal_info_fd_pid_setter, L"PID of sender");

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"uid"),
        int_type, unix_i_signal_info_fd_uid_getter, unix_i_signal_info_fd_uid_setter, L"Real UID of sender");

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"fd"),
        int_type, unix_i_signal_info_fd_fd_getter, unix_i_signal_info_fd_fd_setter, L"File descriptor for io signal.");

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"tid"),
        int_type, unix_i_signal_info_fd_tid_getter, unix_i_signal_info_fd_tid_setter, L"Kernel timer id for signals relating to Posix timers");

    anna_member_create_native_property(
        unix_signal_info_fd_type, anna_mid_get(L"band"),
        int_type, unix_i_signal_info_fd_band_getter, unix_i_signal_info_fd_band_setter, L"Band event for io signal");
    anna_member_create_native_method(
	unix_signal_info_fd_type, anna_mid_get(L"__init__"), 0,
	&unix_i_signal_info_fd_init, object_type, 1, &unix_signal_info_fd_type, this_argn, 0, 0);    
    anna_type_document(
            unix_signal_info_fd_type, L"A structure describing a recieved signal.");

    anna_type_t *unix_i_proc_sigprocmask_argv[] = {int_type, unix_signal_set_type, unix_signal_set_type};
    wchar_t *unix_i_proc_sigprocmask_argn[] = {L"how", L"set", L"old"};
    latest_function = anna_module_function(stack, L"sigprocmask", 0, &unix_i_proc_sigprocmask, int_type, 3, unix_i_proc_sigprocmask_argv, unix_i_proc_sigprocmask_argn, 0, L"Examine and change what signals are currently blocked by this process.");

    anna_type_t *unix_i_proc_read_signal_argv[] = {int_type, unix_signal_info_fd_type};
    wchar_t *unix_i_proc_read_signal_argn[] = {L"fd", L"info"};
    latest_function = anna_module_function(stack, L"readSignal", 0, &unix_i_proc_read_signal, object_type, 2, unix_i_proc_read_signal_argv, unix_i_proc_read_signal_argn, 0, L"Read one signal information structure form the specified file descriptor.");
    anna_stack_document(stack, L"The unix.proc module contains low level wrappers for basic unix functionality revolving around processes and signals.");

    anna_type_data_register(anna_proc_type_data, stack);
}
const static anna_type_data_t anna_user_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_user_getuid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_58 = getuid();
    anna_entry_t *result = anna_from_int(tmp_var_58);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_geteuid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_59 = geteuid();
    anna_entry_t *result = anna_from_int(tmp_var_59);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getgid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_60 = getgid();
    anna_entry_t *result = anna_from_int(tmp_var_60);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getegid, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_61 = getegid();
    anna_entry_t *result = anna_from_int(tmp_var_61);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setuid, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_62 = setuid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_62);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_seteuid, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_63 = seteuid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_63);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setegid, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_64 = setegid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_64);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setgid, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_uid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_65 = setgid(native_param_uid);
    anna_entry_t *result = anna_from_int(tmp_var_65);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setpgid, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);
    int native_param_pgid = anna_as_int(param[1]);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_66 = setpgid(native_param_pid, native_param_pgid);
    anna_entry_t *result = anna_from_int(tmp_var_66);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getpgid, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_pid = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_67 = getpgid(native_param_pid);
    anna_entry_t *result = anna_from_int(tmp_var_67);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_getgroups, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_size = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), native_param_size))
    {
        return null_entry;
    }
    size_t native_param_list_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_list = malloc(sizeof(int) * native_param_list_count);
    if(!native_param_list){ return null_entry; }
    int native_param_list_idx;
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_list_idx);
        if(tmp == null_entry)
        {
            native_param_list[native_param_list_idx] = 0;
        }
        else
        {
            int native_param_list_val = anna_as_int(tmp);
            native_param_list[native_param_list_idx] = native_param_list_val;
        }
    }


    // Validate parameters
    
    

    // Call the function
    int tmp_var_68 = getgroups(native_param_size, native_param_list);
    anna_entry_t *result = anna_from_int(tmp_var_68);
    // Perform cleanup
    
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_list[native_param_list_idx]);
        anna_list_set(anna_as_obj(param[1]), native_param_list_idx, tmp);
        
    }
    free(native_param_list);


    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_user_setgroups, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_size = anna_as_int(param[0]);
    if(anna_list_ensure_capacity(anna_as_obj(param[1]), native_param_size))
    {
        return null_entry;
    }
    size_t native_param_list_count = anna_list_get_count(anna_as_obj(param[1]));
    int* native_param_list = malloc(sizeof(int) * native_param_list_count);
    if(!native_param_list){ return null_entry; }
    int native_param_list_idx;
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_list_get(anna_as_obj(param[1]), native_param_list_idx);
        if(tmp == null_entry)
        {
            native_param_list[native_param_list_idx] = 0;
        }
        else
        {
            int native_param_list_val = anna_as_int(tmp);
            native_param_list[native_param_list_idx] = native_param_list_val;
        }
    }


    // Validate parameters
    
    

    // Call the function
    int tmp_var_69 = setgroups(native_param_size, native_param_list);
    anna_entry_t *result = anna_from_int(tmp_var_69);
    // Perform cleanup
    
    for(native_param_list_idx=0; native_param_list_idx < native_param_list_count; native_param_list_idx++)
    {
        anna_entry_t *tmp = anna_from_int(native_param_list[native_param_list_idx]);
        anna_list_set(anna_as_obj(param[1]), native_param_list_idx, tmp);
        
    }
    free(native_param_list);


    // Return result
    return result;
}

void anna_user_create(anna_stack_template_t *stack);
void anna_user_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_user_type_data, stack);        
}
void anna_user_load(anna_stack_template_t *stack);
void anna_user_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_user_getuid_argv[] = {};
    wchar_t *unix_i_user_getuid_argn[] = {};
    latest_function = anna_module_function(stack, L"getuid", 0, &unix_i_user_getuid, int_type, 0, unix_i_user_getuid_argv, unix_i_user_getuid_argn, 0, L"Get the real user ID of the calling process.");

    anna_type_t *unix_i_user_geteuid_argv[] = {};
    wchar_t *unix_i_user_geteuid_argn[] = {};
    latest_function = anna_module_function(stack, L"geteuid", 0, &unix_i_user_geteuid, int_type, 0, unix_i_user_geteuid_argv, unix_i_user_geteuid_argn, 0, L"Get the effective user ID of the calling process.");

    anna_type_t *unix_i_user_getgid_argv[] = {};
    wchar_t *unix_i_user_getgid_argn[] = {};
    latest_function = anna_module_function(stack, L"getgid", 0, &unix_i_user_getgid, int_type, 0, unix_i_user_getgid_argv, unix_i_user_getgid_argn, 0, L"Get the real group ID of the calling process.");

    anna_type_t *unix_i_user_getegid_argv[] = {};
    wchar_t *unix_i_user_getegid_argn[] = {};
    latest_function = anna_module_function(stack, L"getegid", 0, &unix_i_user_getegid, int_type, 0, unix_i_user_getegid_argv, unix_i_user_getegid_argn, 0, L"Get the effective group ID of the calling process.");

    anna_type_t *unix_i_user_setuid_argv[] = {int_type};
    wchar_t *unix_i_user_setuid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"setuid", 0, &unix_i_user_setuid, int_type, 1, unix_i_user_setuid_argv, unix_i_user_setuid_argn, 0, L"Set the effective user ID of the calling process. If the calling user is root, the real user ID is also set.");

    anna_type_t *unix_i_user_seteuid_argv[] = {int_type};
    wchar_t *unix_i_user_seteuid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"seteuid", 0, &unix_i_user_seteuid, int_type, 1, unix_i_user_seteuid_argv, unix_i_user_seteuid_argn, 0, L"Set the effective user ID of the calling process.");

    anna_type_t *unix_i_user_setegid_argv[] = {int_type};
    wchar_t *unix_i_user_setegid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"setegid", 0, &unix_i_user_setegid, int_type, 1, unix_i_user_setegid_argv, unix_i_user_setegid_argn, 0, L"Set the effective group ID of the calling process.");

    anna_type_t *unix_i_user_setgid_argv[] = {int_type};
    wchar_t *unix_i_user_setgid_argn[] = {L"uid"};
    latest_function = anna_module_function(stack, L"setgid", 0, &unix_i_user_setgid, int_type, 1, unix_i_user_setgid_argv, unix_i_user_setgid_argn, 0, L"Set the effective group ID of the calling process. If the calling user is root, the real group ID is also set.");

    anna_type_t *unix_i_user_setpgid_argv[] = {int_type, int_type};
    wchar_t *unix_i_user_setpgid_argn[] = {L"pid", L"pgid"};
    latest_function = anna_module_function(stack, L"setpgid", 0, &unix_i_user_setpgid, int_type, 2, unix_i_user_setpgid_argv, unix_i_user_setpgid_argn, 0, L"Set process group.");

    anna_type_t *unix_i_user_getpgid_argv[] = {int_type};
    wchar_t *unix_i_user_getpgid_argn[] = {L"pid"};
    latest_function = anna_module_function(stack, L"getpgid", 0, &unix_i_user_getpgid, int_type, 1, unix_i_user_getpgid_argv, unix_i_user_getpgid_argn, 0, L"Get process group.");

    anna_type_t *unix_i_user_getgroups_argv[] = {int_type, anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_user_getgroups_argn[] = {L"size", L"list"};
    latest_function = anna_module_function(stack, L"getgroups", 0, &unix_i_user_getgroups, int_type, 2, unix_i_user_getgroups_argv, unix_i_user_getgroups_argn, 0, L"Get list of supplamentary group IDs.");

    anna_type_t *unix_i_user_setgroups_argv[] = {int_type, anna_list_type_get_mutable(int_type)};
    wchar_t *unix_i_user_setgroups_argn[] = {L"size", L"list"};
    latest_function = anna_module_function(stack, L"setgroups", 0, &unix_i_user_setgroups, int_type, 2, unix_i_user_setgroups_argv, unix_i_user_setgroups_argn, 0, L"Set list of supplamentary group IDs.");
    anna_stack_document(stack, L"The unix.user module contains low level wrappers for basic unix functionality revolving around users and groups.");

    anna_type_data_register(anna_user_type_data, stack);
}
const static anna_type_data_t anna_r_limit_type_data[] = 
{
    { &unix_r_limit_type, L"RLimit" },
};
const static anna_type_data_t anna_r_limit_mode_type_data[] = 
{
};

void anna_r_limit_mode_create(anna_stack_template_t *stack);
void anna_r_limit_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_r_limit_mode_type_data, stack);        
}
void anna_r_limit_mode_load(anna_stack_template_t *stack);
void anna_r_limit_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"as", RLIMIT_AS, L"The AS limit");
    anna_module_const_int(stack, L"core", RLIMIT_CORE, L"The CORE limit");
    anna_module_const_int(stack, L"cpu", RLIMIT_CPU, L"The CPU limit");
    anna_module_const_int(stack, L"data", RLIMIT_DATA, L"The DATA limit");
    anna_module_const_int(stack, L"fsize", RLIMIT_FSIZE, L"The FSIZE limit");
    anna_module_const_int(stack, L"memlock", RLIMIT_MEMLOCK, L"The MEMLOCK limit");
    anna_module_const_int(stack, L"msgqueue", RLIMIT_MSGQUEUE, L"The MSGQUEUE limit");
    anna_module_const_int(stack, L"nice", RLIMIT_NICE, L"The NICE limit");
    anna_module_const_int(stack, L"nofile", RLIMIT_NOFILE, L"The NOFILE limit");
    anna_module_const_int(stack, L"nproc", RLIMIT_NPROC, L"The NPROC limit");
    anna_module_const_int(stack, L"rss", RLIMIT_RSS, L"The RSS limit");
    anna_module_const_int(stack, L"rtprio", RLIMIT_RTPRIO, L"The RTPRIO limit");
    anna_module_const_int(stack, L"sigpending", RLIMIT_SIGPENDING, L"The SIGPENDING limit");
    anna_module_const_int(stack, L"stack", RLIMIT_STACK, L"The STACK limit");
    anna_stack_document(stack, L"The different limits that can be queried with getRLimit and stRLimit.");

    anna_type_data_register(anna_r_limit_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_r_limit_cur_getter, 1)
{
    struct rlimit *data;
    data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->rlim_cur);
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_max_getter, 1)
{
    struct rlimit *data;
    data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->rlim_max);
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_init, 1)
{
    struct rlimit *data;
    data = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct rlimit));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_r_limit_get_r_limit, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_resource = anna_as_int(param[0]);
    struct rlimit *native_param_rlim;
    native_param_rlim = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_70 = getrlimit(native_param_resource, native_param_rlim);
    anna_entry_t *result = anna_from_int(tmp_var_70);
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_r_limit_set_r_limit, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_resource = anna_as_int(param[0]);
    struct rlimit *native_param_rlim;
    native_param_rlim = (struct rlimit *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_71 = setrlimit(native_param_resource, native_param_rlim);
    anna_entry_t *result = anna_from_int(tmp_var_71);
    // Perform cleanup

    // Return result
    return result;
}

void anna_r_limit_create(anna_stack_template_t *stack);
void anna_r_limit_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_r_limit_type_data, stack);        
}
void anna_r_limit_load(anna_stack_template_t *stack);
void anna_r_limit_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"rLimitMode", anna_r_limit_mode_create, anna_r_limit_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_r_limit_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct rlimit));

    anna_member_create_native_property(
        unix_r_limit_type, anna_mid_get(L"cur"),
        int_type, unix_i_r_limit_cur_getter, 0, L"Currently enforced limit (soft limit)");

    anna_member_create_native_property(
        unix_r_limit_type, anna_mid_get(L"max"),
        int_type, unix_i_r_limit_max_getter, 0, L"Maximum value of limit (hard limit)");
    anna_member_create_native_method(
	unix_r_limit_type, anna_mid_get(L"__init__"), 0,
	&unix_i_r_limit_init, object_type, 1, &unix_r_limit_type, this_argn, 0, 0);    
    anna_type_document(
            unix_r_limit_type, L"A structure representing the current and maximum value of a system resource usage limit.");

    anna_type_t *unix_i_r_limit_get_r_limit_argv[] = {int_type, unix_r_limit_type};
    wchar_t *unix_i_r_limit_get_r_limit_argn[] = {L"resource", L"rlim"};
    latest_function = anna_module_function(stack, L"getRLimit", 0, &unix_i_r_limit_get_r_limit, int_type, 2, unix_i_r_limit_get_r_limit_argv, unix_i_r_limit_get_r_limit_argn, 0, L"Get resource limit.");

    anna_type_t *unix_i_r_limit_set_r_limit_argv[] = {int_type, unix_r_limit_type};
    wchar_t *unix_i_r_limit_set_r_limit_argn[] = {L"resource", L"rlim"};
    latest_function = anna_module_function(stack, L"setRLimit", 0, &unix_i_r_limit_set_r_limit, int_type, 2, unix_i_r_limit_set_r_limit_argv, unix_i_r_limit_set_r_limit_argn, 0, L"Set resource limit.");
    anna_stack_document(stack, L"The unix.rLimit module contains low level wrappers for basic unix functionality revolving around system resource limits.");

    anna_type_data_register(anna_r_limit_type_data, stack);
}
const static anna_type_data_t anna_env_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_env_getenv, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    char * tmp_var_72 = getenv(native_param_name);
    anna_entry_t *result = (tmp_var_72) ? anna_from_obj(anna_string_create_narrow(strlen(tmp_var_72), tmp_var_72)) : null_entry;
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_setenv, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));
    char *native_param_value = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));
    int native_param_overwrite = anna_as_int(param[2]);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_73 = setenv(native_param_name, native_param_value, native_param_overwrite);
    anna_entry_t *result = anna_from_int(tmp_var_73);
    // Perform cleanup
    free(native_param_name);
    free(native_param_value);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_unsetenv, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    char *native_param_name = (param[0] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[0]));

    // Validate parameters
    

    // Call the function
    int tmp_var_74 = unsetenv(native_param_name);
    anna_entry_t *result = anna_from_int(tmp_var_74);
    // Perform cleanup
    free(native_param_name);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_env_clearenv, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    int tmp_var_75 = clearenv();
    anna_entry_t *result = anna_from_int(tmp_var_75);
    // Perform cleanup

    // Return result
    return result;
}

void anna_env_create(anna_stack_template_t *stack);
void anna_env_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_env_type_data, stack);        
}
void anna_env_load(anna_stack_template_t *stack);
void anna_env_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_env_getenv_argv[] = {string_type};
    wchar_t *unix_i_env_getenv_argn[] = {L"name"};
    latest_function = anna_module_function(stack, L"getenv", 0, &unix_i_env_getenv, string_type, 1, unix_i_env_getenv_argv, unix_i_env_getenv_argn, 0, L"Return the current value of the given environment variable. Equivalanet to the C getenv function.");

    anna_type_t *unix_i_env_setenv_argv[] = {string_type, string_type, int_type};
    wchar_t *unix_i_env_setenv_argn[] = {L"name", L"value", L"overwrite"};
    latest_function = anna_module_function(stack, L"setenv", 0, &unix_i_env_setenv, int_type, 3, unix_i_env_setenv_argv, unix_i_env_setenv_argn, 0, L"Assign a new value to the environment variable with the given name. Equivalanet to the C setenv function.");

    anna_type_t *unix_i_env_unsetenv_argv[] = {string_type};
    wchar_t *unix_i_env_unsetenv_argn[] = {L"name"};
    latest_function = anna_module_function(stack, L"unsetenv", 0, &unix_i_env_unsetenv, int_type, 1, unix_i_env_unsetenv_argv, unix_i_env_unsetenv_argn, 0, L"Delete the specified environment variable. Equivalanet to the C unsetenv function.");

    anna_type_t *unix_i_env_clearenv_argv[] = {};
    wchar_t *unix_i_env_clearenv_argn[] = {};
    latest_function = anna_module_function(stack, L"clearenv", 0, &unix_i_env_clearenv, int_type, 0, unix_i_env_clearenv_argv, unix_i_env_clearenv_argn, 0, L"Removes all environemnt variables. Equivalanet to the C clearenv function.");
    anna_stack_document(stack, L"The unix.env module contains low level wrappers for basic unix functionality revolving around environment variables.");

    anna_type_data_register(anna_env_type_data, stack);
}
const static anna_type_data_t anna_sleep_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_sleep_sleep, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_seconds = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    int tmp_var_76 = sleep(native_param_seconds);
    anna_entry_t *result = anna_from_int(tmp_var_76);
    // Perform cleanup

    // Return result
    return result;
}

void anna_sleep_create(anna_stack_template_t *stack);
void anna_sleep_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_sleep_type_data, stack);        
}
void anna_sleep_load(anna_stack_template_t *stack);
void anna_sleep_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_sleep_sleep_argv[] = {int_type};
    wchar_t *unix_i_sleep_sleep_argn[] = {L"seconds"};
    latest_function = anna_module_function(stack, L"sleep", 0, &unix_i_sleep_sleep, int_type, 1, unix_i_sleep_sleep_argv, unix_i_sleep_sleep_argn, 0, L"Sleep for the specified number of seconds");
    anna_stack_document(stack, L"The unix.sleep module contains low level wrappers for basic unix functionality revolving around pausing the execution of processes.");

    anna_type_data_register(anna_sleep_type_data, stack);
}
const static anna_type_data_t anna_locale_type_data[] = 
{
    { &unix_locale_conv_type, L"LocaleConv" },
};
const static anna_type_data_t anna_locale_mode_type_data[] = 
{
};

void anna_locale_mode_create(anna_stack_template_t *stack);
void anna_locale_mode_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_locale_mode_type_data, stack);        
}
void anna_locale_mode_load(anna_stack_template_t *stack);
void anna_locale_mode_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"all", LC_ALL, L"All of the locale.");
    anna_module_const_int(stack, L"collate", LC_COLLATE, L"Regular expression matching (it determines the meaning of range expressions and equivalence classes) and string collation.");
    anna_module_const_int(stack, L"cType", LC_CTYPE, L"Regular expression matching, character classification, conversion, case-sensitive comparison, and wide character functions.");
    anna_module_const_int(stack, L"messages", LC_MESSAGES, L"Localizable natural-language messages.");
    anna_module_const_int(stack, L"monetary", LC_MONETARY, L"Monetary formating.");
    anna_module_const_int(stack, L"numeric", LC_NUMERIC, L"Numeric formating, such as decimal point and thousands separator.");
    anna_module_const_int(stack, L"time", LC_TIME, L"Date and time formating.");
    anna_stack_document(stack, L"Different locale parts.");

    anna_type_data_register(anna_locale_mode_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_locale_set_locale, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_cateory = anna_as_int(param[0]);
    char *native_param_locale = (param[1] == null_entry) ? 0 : anna_string_payload_narrow(anna_as_obj(param[1]));

    // Validate parameters
    
    

    // Call the function
    char * tmp_var_77 = setlocale(native_param_cateory, native_param_locale);
    anna_entry_t *result = (tmp_var_77) ? anna_from_obj(anna_string_create_narrow(strlen(tmp_var_77), tmp_var_77)) : null_entry;
    // Perform cleanup
    free(native_param_locale);

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_decimal_point_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->decimal_point) ? anna_from_obj(anna_string_create_narrow(strlen(data->decimal_point), data->decimal_point)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_thousands_separator_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->thousands_sep) ? anna_from_obj(anna_string_create_narrow(strlen(data->thousands_sep), data->thousands_sep)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_grouping_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->grouping) ? anna_from_obj(anna_string_create_narrow(strlen(data->grouping), data->grouping)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_international_currency_symbol_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->int_curr_symbol) ? anna_from_obj(anna_string_create_narrow(strlen(data->int_curr_symbol), data->int_curr_symbol)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_currency_symbol_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->currency_symbol) ? anna_from_obj(anna_string_create_narrow(strlen(data->currency_symbol), data->currency_symbol)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_monetary_decimal_point_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->mon_decimal_point) ? anna_from_obj(anna_string_create_narrow(strlen(data->mon_decimal_point), data->mon_decimal_point)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_monetary_thousands_separator_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->mon_thousands_sep) ? anna_from_obj(anna_string_create_narrow(strlen(data->mon_thousands_sep), data->mon_thousands_sep)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_monetary_grouping_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->mon_grouping) ? anna_from_obj(anna_string_create_narrow(strlen(data->mon_grouping), data->mon_grouping)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_sign_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->positive_sign) ? anna_from_obj(anna_string_create_narrow(strlen(data->positive_sign), data->positive_sign)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_sign_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->negative_sign) ? anna_from_obj(anna_string_create_narrow(strlen(data->negative_sign), data->negative_sign)) : null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_international_frac_digits_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->int_frac_digits);
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_frac_digits_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->frac_digits);
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_currency_symbol_precedes_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->p_cs_precedes)?anna_from_int(1):null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_currency_symbol_precedes_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->n_cs_precedes)?anna_from_int(1):null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_separate_by_space_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->p_sep_by_space)?anna_from_int(1):null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_separate_by_space_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = (data->n_sep_by_space)?anna_from_int(1):null_entry;
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_positive_sign_position_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->p_sign_posn);
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_negative_sign_position_getter, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->n_sign_posn);
    return result;
}

ANNA_VM_NATIVE(unix_i_locale_conv_init, 1)
{
    struct lconv *data;
    data = *(struct lconv **)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct lconv));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_locale_locale_conv, 0)
{
    // Validate parameters

    // Mangle input parameters

    // Validate parameters

    // Call the function
    struct lconv * tmp_var_78 = localeconv();
    anna_entry_t *result = anna_from_obj(anna_object_create(unix_locale_conv_type));
    *((struct lconv **)anna_entry_get_addr(anna_as_obj_fast(result), ANNA_MID_CSTRUCT_PAYLOAD)) = tmp_var_78;
    // Perform cleanup

    // Return result
    return result;
}

void anna_locale_create(anna_stack_template_t *stack);
void anna_locale_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_locale_type_data, stack);        
}
void anna_locale_load(anna_stack_template_t *stack);
void anna_locale_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"localeMode", anna_locale_mode_create, anna_locale_mode_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_locale_set_locale_argv[] = {int_type, string_type};
    wchar_t *unix_i_locale_set_locale_argn[] = {L"cateory", L"locale"};
    latest_function = anna_module_function(stack, L"setLocale", 0, &unix_i_locale_set_locale, string_type, 2, unix_i_locale_set_locale_argv, unix_i_locale_set_locale_argn, 0, L"Set the specified local category to the specified value");

    anna_member_create_blob(unix_locale_conv_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct lconv *));

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"decimalPoint"),
        string_type, unix_i_locale_conv_decimal_point_getter, 0, L"Decimal-point separator used for non-monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"thousandsSeparator"),
        string_type, unix_i_locale_conv_thousands_separator_getter, 0, L"Separators used to delimit groups of digits to the left of the decimal point for non-monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"grouping"),
        string_type, unix_i_locale_conv_grouping_getter, 0, L"The amount of digits that form each of the groups to be separated by thousandsSeparator separator for non-monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"internationalCurrencySymbol"),
        string_type, unix_i_locale_conv_international_currency_symbol_getter, 0, L"International currency symbol.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"currencySymbol"),
        string_type, unix_i_locale_conv_currency_symbol_getter, 0, L"Local currency symbol.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"monetaryDecimalPoint"),
        string_type, unix_i_locale_conv_monetary_decimal_point_getter, 0, L"Decimal-point separator used for monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"monetaryThousandsSeparator"),
        string_type, unix_i_locale_conv_monetary_thousands_separator_getter, 0, L"Separators used to delimit groups of digits to the left of the decimal point for monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"monetaryGrouping"),
        string_type, unix_i_locale_conv_monetary_grouping_getter, 0, L"The amount of digits that form each of the groups to be separated by monetaryThousandsSeparator separator for monetary quantities.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveSign"),
        string_type, unix_i_locale_conv_positive_sign_getter, 0, L"Sign for positive values");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeSign"),
        string_type, unix_i_locale_conv_negative_sign_getter, 0, L"Sign for negative values");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"internationalFracDigits"),
        int_type, unix_i_locale_conv_international_frac_digits_getter, 0, L"International fractional digits.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"fracDigits"),
        int_type, unix_i_locale_conv_frac_digits_getter, 0, L"Local fractional digits.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveCurrencySymbolPrecedes"),
        object_type, unix_i_locale_conv_positive_currency_symbol_precedes_getter, 0, L"1 if currencySymbol precedes a positive value, null if succeeds.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeCurrencySymbolPrecedes"),
        object_type, unix_i_locale_conv_negative_currency_symbol_precedes_getter, 0, L"1 if currencySymbol precedes a negative value, null if succeeds.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveSeparateBySpace"),
        object_type, unix_i_locale_conv_positive_separate_by_space_getter, 0, L"1 if a space separates currency_symbol from a positive value, null otherwise.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeSeparateBySpace"),
        object_type, unix_i_locale_conv_negative_separate_by_space_getter, 0, L"1 if a space separates currency_symbol from a negative value, null otherwise.");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"positiveSignPosition"),
        int_type, unix_i_locale_conv_positive_sign_position_getter, 0, L"\nPositive and negative sign positions:\n<ul>\n<li>0: Parentheses surround the quantity and currency_symbol.</li>\n<li>1: The sign string precedes the quantity and currency_symbol.</li>\n<li>2: The sign string succeeds the quantity and currency_symbol.</li>\n<li>3: The sign string immediately precedes the currency_symbol.</li>\n<li>4: The sign string immediately succeeds the currency_symbol.</li>\n</ul>\n");

    anna_member_create_native_property(
        unix_locale_conv_type, anna_mid_get(L"negativeSignPosition"),
        int_type, unix_i_locale_conv_negative_sign_position_getter, 0, L"\nPositive and negative sign positions:\n<ul>\n<li>0: Parentheses surround the quantity and currency_symbol.</li>\n<li>1: The sign string precedes the quantity and currency_symbol.</li>\n<li>2: The sign string succeeds the quantity and currency_symbol.</li>\n<li>3: The sign string immediately precedes the currency_symbol.</li>\n<li>4: The sign string immediately succeeds the currency_symbol.</li>\n</ul>\n");
    anna_member_create_native_method(
	unix_locale_conv_type, anna_mid_get(L"__init__"), 0,
	&unix_i_locale_conv_init, object_type, 1, &unix_locale_conv_type, this_argn, 0, 0);    
    anna_type_document(
            unix_locale_conv_type, L"Detailed local information regarding numeric formating.");

    anna_type_t *unix_i_locale_locale_conv_argv[] = {};
    wchar_t *unix_i_locale_locale_conv_argn[] = {};
    latest_function = anna_module_function(stack, L"localeConv", 0, &unix_i_locale_locale_conv, unix_locale_conv_type, 0, unix_i_locale_locale_conv_argv, unix_i_locale_locale_conv_argn, 0, L"Get current numeric formatting information.");
    anna_stack_document(stack, L"The unix.locale module contains low level wrappers for basic unix functionality revolving around localization.");

    anna_type_data_register(anna_locale_type_data, stack);
}
const static anna_type_data_t anna_term_type_data[] = 
{
    { &unix_termios_type, L"Termios" },
};
const static anna_type_data_t anna_flag_type_data[] = 
{
};

void anna_flag_create(anna_stack_template_t *stack);
void anna_flag_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_flag_type_data, stack);        
}
void anna_flag_load(anna_stack_template_t *stack);
void anna_flag_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"canonical", ICANON, L"Read one character at a time.");
    anna_module_const_int(stack, L"echo", ECHO, L"Echo characters to the screen.");
    anna_stack_document(stack, L"The different modes of a Termios structure.");

    anna_type_data_register(anna_flag_type_data, stack);
}
const static anna_type_data_t anna_action_type_data[] = 
{
};

void anna_action_create(anna_stack_template_t *stack);
void anna_action_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_action_type_data, stack);        
}
void anna_action_load(anna_stack_template_t *stack);
void anna_action_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"now", TCSANOW, L"Take the specified action now,");
    anna_module_const_int(stack, L"drain", TCSADRAIN, L"Empty output buffer and apply specified action.");
    anna_module_const_int(stack, L"flush", TCSAFLUSH, L"Apply specified action once outout in buffer has been written.");
    anna_stack_document(stack, L"The different action modes used by unix.term.setAttr.");

    anna_type_data_register(anna_action_type_data, stack);
}

ANNA_VM_NATIVE(unix_i_termios_iflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->c_iflag);
    return result;
}

ANNA_VM_NATIVE(unix_i_termios_iflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->c_iflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_oflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->c_oflag);
    return result;
}

ANNA_VM_NATIVE(unix_i_termios_oflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->c_oflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_cflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->c_cflag);
    return result;
}

ANNA_VM_NATIVE(unix_i_termios_cflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->c_cflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_lflag_getter, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    anna_entry_t *result = anna_from_int(data->c_lflag);
    return result;
}

ANNA_VM_NATIVE(unix_i_termios_lflag_setter, 2)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    int tmp = anna_as_int(param[1]);
    data->c_lflag = tmp;
    return param[1];
}

ANNA_VM_NATIVE(unix_i_termios_init, 1)
{
    struct termios *data;
    data = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[0]), ANNA_MID_CSTRUCT_PAYLOAD);
    memset(data, 0, sizeof(struct termios));
    return param[0];
}

ANNA_VM_NATIVE(unix_i_term_get_attr, 2)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    struct termios *native_param_ios;
    native_param_ios = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[1]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    

    // Call the function
    int tmp_var_79 = tcgetattr(native_param_fd, native_param_ios);
    anna_entry_t *result = (tmp_var_79)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(unix_i_term_set_attr, 3)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}

        if(param[1] == null_entry){return null_entry;}

        if(param[2] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_fd = anna_as_int(param[0]);
    int native_param_actions = anna_as_int(param[1]);
    struct termios *native_param_ios;
    native_param_ios = (struct termios *)anna_entry_get_addr(anna_as_obj_fast(param[2]), ANNA_MID_CSTRUCT_PAYLOAD);

    // Validate parameters
    
    
    

    // Call the function
    int tmp_var_80 = tcsetattr(native_param_fd, native_param_actions, native_param_ios);
    anna_entry_t *result = (tmp_var_80)?anna_from_int(1):null_entry;
    // Perform cleanup

    // Return result
    return result;
}

void anna_term_create(anna_stack_template_t *stack);
void anna_term_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_term_type_data, stack);        
}
void anna_term_load(anna_stack_template_t *stack);
void anna_term_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"flag", anna_flag_create, anna_flag_load},
            { L"action", anna_action_create, anna_action_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_member_create_blob(unix_termios_type, ANNA_MID_CSTRUCT_PAYLOAD, 0, sizeof(struct termios));

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"iflag"),
        int_type, unix_i_termios_iflag_getter, unix_i_termios_iflag_setter, L"Input modes");

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"oflag"),
        int_type, unix_i_termios_oflag_getter, unix_i_termios_oflag_setter, L"Output modes");

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"cflag"),
        int_type, unix_i_termios_cflag_getter, unix_i_termios_cflag_setter, L"Control modes");

    anna_member_create_native_property(
        unix_termios_type, anna_mid_get(L"lflag"),
        int_type, unix_i_termios_lflag_getter, unix_i_termios_lflag_setter, L"Local modes");
    anna_member_create_native_method(
	unix_termios_type, anna_mid_get(L"__init__"), 0,
	&unix_i_termios_init, object_type, 1, &unix_termios_type, this_argn, 0, 0);    
    anna_type_document(
            unix_termios_type, L"A structure representing the state of a terminal.");

    anna_type_t *unix_i_term_get_attr_argv[] = {int_type, unix_termios_type};
    wchar_t *unix_i_term_get_attr_argn[] = {L"fd", L"ios"};
    latest_function = anna_module_function(stack, L"getAttr", 0, &unix_i_term_get_attr, object_type, 2, unix_i_term_get_attr_argv, unix_i_term_get_attr_argn, 0, L"Get the current state of a terminal.");

    anna_type_t *unix_i_term_set_attr_argv[] = {int_type, int_type, unix_termios_type};
    wchar_t *unix_i_term_set_attr_argn[] = {L"fd", L"actions", L"ios"};
    latest_function = anna_module_function(stack, L"setAttr", 0, &unix_i_term_set_attr, object_type, 3, unix_i_term_set_attr_argv, unix_i_term_set_attr_argn, 0, L"Set the current state of the terminal.");
    anna_stack_document(stack, L"The unix.term module contains low level wrappers for basic unix functionality revolving around terminal handling.");

    anna_type_data_register(anna_term_type_data, stack);
}
const static anna_type_data_t anna_error_type_data[] = 
{
};

ANNA_VM_NATIVE(unix_i_error_error_string, 1)
{
    // Validate parameters
        if(param[0] == null_entry){return null_entry;}


    // Mangle input parameters
    int native_param_error = anna_as_int(param[0]);

    // Validate parameters
    

    // Call the function
    char * tmp_var_81 = strerror(native_param_error);
    anna_entry_t *result = (tmp_var_81) ? anna_from_obj(anna_string_create_narrow(strlen(tmp_var_81), tmp_var_81)) : null_entry;
    // Perform cleanup

    // Return result
    return result;
}

ANNA_VM_NATIVE(anna_unix_errno_getter, 1)
{
    anna_entry_t *result = anna_from_int(errno);
    return result;
}

ANNA_VM_NATIVE(anna_unix_errno_setter, 2)
{
    if(param[1] != null_entry)
    {
        int value = anna_as_int(param[1]);
        errno = value;
    }
    return param[1];
}
const static anna_type_data_t anna_status_type_data[] = 
{
};

void anna_status_create(anna_stack_template_t *stack);
void anna_status_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_status_type_data, stack);        
}
void anna_status_load(anna_stack_template_t *stack);
void anna_status_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_module_const_int(stack, L"tooBig", E2BIG, L"Argument list too long.");
    anna_module_const_int(stack, L"access", EACCES, L"Permission denied.");
    anna_module_const_int(stack, L"addressInUse", EADDRINUSE, L"Address already in use.");
    anna_module_const_int(stack, L"addressNotAvailable", EADDRNOTAVAIL, L"Address not available.");
    anna_module_const_int(stack, L"addressFamilyNotSupported", EAFNOSUPPORT, L"Address family not supported.");
    anna_module_const_int(stack, L"again", EAGAIN, L"Resource temporarily unavailable (may be the same value as wouldBlock).");
    anna_module_const_int(stack, L"alreadyInProgress", EALREADY, L"Connection already in progress.");
    anna_module_const_int(stack, L"badExchange", EBADE, L"Invalid exchange.");
    anna_module_const_int(stack, L"badFileDescriptor", EBADF, L"Bad file descriptor.");
    anna_module_const_int(stack, L"badFileDescriptorState", EBADFD, L"File descriptor in bad state.");
    anna_module_const_int(stack, L"badRequest", EBADR, L"Invalid request descriptor.");
    anna_module_const_int(stack, L"badRequestCode", EBADRQC, L"Invalid request code.");
    anna_module_const_int(stack, L"badSlot", EBADSLT, L"Invalid slot.");
    anna_module_const_int(stack, L"deviceBusy", EBUSY, L"Device or resource busy.");
    anna_module_const_int(stack, L"canceled", ECANCELED, L"Operation canceled.");
    anna_module_const_int(stack, L"noChild", ECHILD, L"No child processes.");
    anna_module_const_int(stack, L"channelRange", ECHRNG, L"Channel number out of range.");
    anna_module_const_int(stack, L"communicationError", ECOMM, L"Communication error on send.");
    anna_module_const_int(stack, L"connectionAborted", ECONNABORTED, L"Connection aborted.");
    anna_module_const_int(stack, L"connectionRefused", ECONNREFUSED, L"Connection refused.");
    anna_module_const_int(stack, L"connectionReset", ECONNRESET, L"Connection reset.");
    anna_module_const_int(stack, L"deadlock", EDEADLK, L"Resource deadlock avoided.");
    anna_module_const_int(stack, L"destinationRequired", EDESTADDRREQ, L"Destination address required.");
    anna_module_const_int(stack, L"domain", EDOM, L"Mathematics argument out of domain of function.");
    anna_module_const_int(stack, L"diskQuota", EDQUOT, L"Disk quota exceeded.");
    anna_module_const_int(stack, L"exist", EEXIST, L"File exists.");
    anna_module_const_int(stack, L"fault", EFAULT, L"Bad address.");
    anna_module_const_int(stack, L"fileTooBig", EFBIG, L"File too large.");
    anna_module_const_int(stack, L"hostDown", EHOSTDOWN, L"Host is down.");
    anna_module_const_int(stack, L"hostUnreachable", EHOSTUNREACH, L"Host is unreachable.");
    anna_module_const_int(stack, L"identifierRemoved", EIDRM, L"Identifier removed.");
    anna_module_const_int(stack, L"illegalByteSequence", EILSEQ, L"Illegal byte sequence.");
    anna_module_const_int(stack, L"inProgress", EINPROGRESS, L"Operation in progress.");
    anna_module_const_int(stack, L"interrupted", EINTR, L"Interrupted function call.");
    anna_module_const_int(stack, L"invalid", EINVAL, L"Invalid argument.");
    anna_module_const_int(stack, L"ioError", EIO, L"Input/output error.");
    anna_module_const_int(stack, L"connected?", EISCONN, L"Socket is connected.");
    anna_module_const_int(stack, L"directory?", EISDIR, L"Is a directory.");
    anna_module_const_int(stack, L"named?", EISNAM, L"Is a named type file.");
    anna_module_const_int(stack, L"keyExpired", EKEYEXPIRED, L"Key has expired.");
    anna_module_const_int(stack, L"keyRejected", EKEYREJECTED, L"Key was rejected by service.");
    anna_module_const_int(stack, L"keyRevoked", EKEYREVOKED, L"Key has been revoked.");
    anna_module_const_int(stack, L"level2Halted", EL2HLT, L"Level 2 halted.");
    anna_module_const_int(stack, L"level2NotSynced", EL2NSYNC, L"Level 2 not synchronized.");
    anna_module_const_int(stack, L"level3Halted", EL3HLT, L"Level 3 halted.");
    anna_module_const_int(stack, L"level3Reset", EL3RST, L"Level 3 reset.");
    anna_module_const_int(stack, L"libraryAccess", ELIBACC, L"Cannot access a needed shared library.");
    anna_module_const_int(stack, L"libraryBad", ELIBBAD, L"Accessing a corrupted shared library.");
    anna_module_const_int(stack, L"libraryMax", ELIBMAX, L"Attempting to link in too many shared libraries.");
    anna_module_const_int(stack, L"libraryCorrupt", ELIBSCN, L"lib section in a.out corrupted.");
    anna_module_const_int(stack, L"libraryExec", ELIBEXEC, L"Cannot exec a shared library directly.");
    anna_module_const_int(stack, L"loop", ELOOP, L"Too many levels of symbolic links");
    anna_module_const_int(stack, L"mediumType", EMEDIUMTYPE, L"Wrong medium type.");
    anna_module_const_int(stack, L"maxFile", EMFILE, L"Too many open files.");
    anna_module_const_int(stack, L"maxLink", EMLINK, L"Too many links.");
    anna_module_const_int(stack, L"messageSize", EMSGSIZE, L"Message too long.");
    anna_module_const_int(stack, L"multihop", EMULTIHOP, L"Multihop attempted.");
    anna_module_const_int(stack, L"nameTooLong", ENAMETOOLONG, L"Filename too long.");
    anna_module_const_int(stack, L"netDown", ENETDOWN, L"Network is down.");
    anna_module_const_int(stack, L"netReset", ENETRESET, L"Connection aborted by network.");
    anna_module_const_int(stack, L"netUnreachable", ENETUNREACH, L"Network unreachable.");
    anna_module_const_int(stack, L"maxFileInSystem", ENFILE, L"Too many open files in system.");
    anna_module_const_int(stack, L"noBufferSpace", ENOBUFS, L"No buffer space available.");
    anna_module_const_int(stack, L"noData", ENODATA, L"No message is available on the STREAM head read queue.");
    anna_module_const_int(stack, L"noDevice", ENODEV, L"No such device.");
    anna_module_const_int(stack, L"noEntry", ENOENT, L"No such file or directory.");
    anna_module_const_int(stack, L"noExec", ENOEXEC, L"Exec format error.");
    anna_module_const_int(stack, L"noKey", ENOKEY, L"Required key not available.");
    anna_module_const_int(stack, L"noLock", ENOLCK, L"No locks available.");
    anna_module_const_int(stack, L"noLink", ENOLINK, L"Link has been severed.");
    anna_module_const_int(stack, L"noMedium", ENOMEDIUM, L"No medium found.");
    anna_module_const_int(stack, L"noMemory", ENOMEM, L"Not enough space.");
    anna_module_const_int(stack, L"noMessage", ENOMSG, L"No message of the desired type.");
    anna_module_const_int(stack, L"noNet", ENONET, L"Machine is not on the network.");
    anna_module_const_int(stack, L"noPackage", ENOPKG, L"Package not installed.");
    anna_module_const_int(stack, L"noProtocol", ENOPROTOOPT, L"Protocol not available.");
    anna_module_const_int(stack, L"noSpace", ENOSPC, L"No space left on device.");
    anna_module_const_int(stack, L"noStream", ENOSR, L"No STREAM resources.");
    anna_module_const_int(stack, L"notStream", ENOSTR, L"Not a STREAM.");
    anna_module_const_int(stack, L"notImplemented", ENOSYS, L"Function not implemented.");
    anna_module_const_int(stack, L"notBlock", ENOTBLK, L"Block device required.");
    anna_module_const_int(stack, L"notConnected", ENOTCONN, L"The socket is not connected.");
    anna_module_const_int(stack, L"notDirectory", ENOTDIR, L"Not a directory.");
    anna_module_const_int(stack, L"notEmpty", ENOTEMPTY, L"Directory not empty.");
    anna_module_const_int(stack, L"notSocket", ENOTSOCK, L"Not a socket.");
    anna_module_const_int(stack, L"notSupported", ENOTSUP, L"Operation not supported.");
    anna_module_const_int(stack, L"notTty", ENOTTY, L"Inappropriate I/O control operation.");
    anna_module_const_int(stack, L"notUnique", ENOTUNIQ, L"Name not unique on network.");
    anna_module_const_int(stack, L"noDeviceOrAddress", ENXIO, L"No such device or address.");
    anna_module_const_int(stack, L"operationNotSupported", EOPNOTSUPP, L"Operation not supported on socket.");
    anna_module_const_int(stack, L"overflow", EOVERFLOW, L"Value too large to be stored in data type.");
    anna_module_const_int(stack, L"permission", EPERM, L"Operation not permitted.");
    anna_module_const_int(stack, L"protocolFamilyNotSupported", EPFNOSUPPORT, L"Protocol family not supported.");
    anna_module_const_int(stack, L"pipe", EPIPE, L"Broken pipe.");
    anna_module_const_int(stack, L"protocolError", EPROTO, L"Protocol error.");
    anna_module_const_int(stack, L"protocolNotSupported", EPROTONOSUPPORT, L"Protocol not supported.");
    anna_module_const_int(stack, L"protocolType", EPROTOTYPE, L"Protocol wrong type for socket.");
    anna_module_const_int(stack, L"range", ERANGE, L"Result too large.");
    anna_module_const_int(stack, L"remoteAddressChanged", EREMCHG, L"Remote address changed.");
    anna_module_const_int(stack, L"remote", EREMOTE, L"Object is remote.");
    anna_module_const_int(stack, L"remoteIo", EREMOTEIO, L"Remote I/O error.");
    anna_module_const_int(stack, L"restart", ERESTART, L"Interrupted system call should be restarted.");
    anna_module_const_int(stack, L"readOnly", EROFS, L"Read-only file system.");
    anna_module_const_int(stack, L"shutdown", ESHUTDOWN, L"Cannot send after transport endpoint shutdown.");
    anna_module_const_int(stack, L"seekPipe", ESPIPE, L"Invalid seek.");
    anna_module_const_int(stack, L"socketNotSupported", ESOCKTNOSUPPORT, L"Socket type not supported.");
    anna_module_const_int(stack, L"noSuchProcess", ESRCH, L"No such process.");
    anna_module_const_int(stack, L"stale", ESTALE, L"Stale file handle. This error can occur for NFS and for other file systems.");
    anna_module_const_int(stack, L"streamPipe", ESTRPIPE, L"Streams pipe error.");
    anna_module_const_int(stack, L"timer", ETIME, L"Timer expired.");
    anna_module_const_int(stack, L"timeout", ETIMEDOUT, L"Connection timed out.");
    anna_module_const_int(stack, L"textBusy", ETXTBSY, L"Text file busy.");
    anna_module_const_int(stack, L"unclean", EUCLEAN, L"Structure needs cleaning.");
    anna_module_const_int(stack, L"unattached", EUNATCH, L"Protocol driver not attached.");
    anna_module_const_int(stack, L"users", EUSERS, L"Too many users.");
    anna_module_const_int(stack, L"wouldBlock", EWOULDBLOCK, L"Operation would block (may be same value as again).");
    anna_module_const_int(stack, L"improperLink", EXDEV, L"Improper link.");
    anna_module_const_int(stack, L"exchangeFull", EXFULL, L"Exchange full.");
    anna_stack_document(stack, L"All known error statuses");

    anna_type_data_register(anna_status_type_data, stack);
}

void anna_error_create(anna_stack_template_t *stack);
void anna_error_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_error_type_data, stack);        
}
void anna_error_load(anna_stack_template_t *stack);
void anna_error_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"status", anna_status_create, anna_status_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};


    anna_type_t *unix_i_error_error_string_argv[] = {int_type};
    wchar_t *unix_i_error_error_string_argn[] = {L"error"};
    latest_function = anna_module_function(stack, L"errorString", 0, &unix_i_error_error_string, string_type, 1, unix_i_error_error_string_argv, unix_i_error_error_string_argn, 0, L"Returns a string that describes the error code passed in the argument. Equivalent to the C strerror function.");
    anna_member_create_native_property(
        stack_type, anna_mid_get(L"errno"),
        int_type, anna_unix_errno_getter, anna_unix_errno_setter, L"The latest C library error to occur");
    anna_stack_document(stack, L"The unix.error module contains low level wrappers around C functions that revolve around error handling.");

    anna_type_data_register(anna_error_type_data, stack);
}


// This function is called to create all types defined in this module

void anna_unix_create(anna_stack_template_t *stack);
void anna_unix_create(anna_stack_template_t *stack)
{
    anna_type_data_create(anna_unix_type_data, stack);        
}

// This function is called to load all functions and other declarations into the module

void anna_unix_load(anna_stack_template_t *stack);
void anna_unix_load(anna_stack_template_t *stack)
{
    mid_t latest_mid;    
    anna_function_t *latest_function;
    anna_type_t *stack_type = anna_stack_wrap(stack)->type;
    anna_module_data_t modules[] =
        {
            { L"time", anna_time_create, anna_time_load},
            { L"io", anna_io_create, anna_io_load},
            { L"proc", anna_proc_create, anna_proc_load},
            { L"user", anna_user_create, anna_user_load},
            { L"rLimit", anna_r_limit_create, anna_r_limit_load},
            { L"env", anna_env_create, anna_env_load},
            { L"sleep", anna_sleep_create, anna_sleep_load},
            { L"locale", anna_locale_create, anna_locale_load},
            { L"term", anna_term_create, anna_term_load},
            { L"error", anna_error_create, anna_error_load},
        };
    anna_module_data_create(modules, stack);

    wchar_t *this_argn[] = {L"this"};

    anna_stack_document(stack, L"The unix module is the parent module for various low level wrappers for basic Unix functionality.");
    anna_stack_document(stack, L"Anna currently has a very sparse standard library, which often necessitates the use of these low level libraries, but when available, a more programmer friendly high level library should be used. The documentation for these modules is very sparse - the same documentation is also available e.g. as Unix man pages.");
    anna_stack_document(stack, L"The unix module is still rater incomplete. There are many, many functions that are currently missing. The ones that are there have inconsistent naming policies with regard to capitalization, abbreviations, etc. The exact policy for naming, etc. in this module will evolve over time, which can result in future incompatibilities.");

    anna_type_data_register(anna_unix_type_data, stack);
}


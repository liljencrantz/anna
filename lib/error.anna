
class Error
{
    var reflection.Continuation source(internal);
    var String message;
    def __init__(String message=?)
    {
	this.message = message;
	source = reflection.currentContinuation;
    }
    
    def String toString()
    {
	this.__type__.name;
    }
}

/*
  These four errors should live in the parser module, but some monkey
  patching is needed in order for that to happen.
 */
error CompilationError
{
}

error ParseError (extends(CompilationError))
{
}

error IncompleteError (extends(CompilationError))
{
}

error LexError (extends(CompilationError))
{
}

def raiseError(Error error)
{
    def Object funEach(reflection.Continuation item)
    {
	if(coll := (item["!collect"] as MutableList))
	{
	    
	    if(tp := (item["!collectType"] as List«reflection.Type»))
	    {
		tp.each(collType)
		{
		    if(error.__type__.abides(collType))
		    {
			coll ~= [error];
			return;
		    }
		}
	    }
	    else
	    {
		coll ~= [error];
		return;
	    }
	} 

	if(item.dynamicFrame)
	{
	    funEach(item.dynamicFrame);
	    return;
	}

	print("Uncaught error:", error, sep:"");
    }
    
    funEach(reflection.currentContinuation);
}


/*
  This file contains notes and ideas on how to write library bindings
  in Anna. As of yet, it is not even a work in progress, more like a
  bunch of ideas thrown out there.

  Basically, the code below is pretty much a C header file in Anna
  syntax. The binding software takes the information given below
  and turns it into a proper C library consisting of wrapper functions
  that can be compiled into a library that can then be dlopen'd into
  the Anna interpreter.
  
  It would be nice if the whole build chain could be moved into Anna,
  but that would require that Anna has access to a C compiler. Using
  exec("cc", ...) should be enough, I guess.
  
*/

/*
  The following basic types are built in:

  * Int: maps to the regular Anna Int. Should be used for all integer types of the C 'int' of the platform.
  * UnsignedInt: maps to the regular Anna Int. Should be used for all integer types of the C 'unsigned int' of the platform.
  * Short, UnsignedShort, Long, UnsignedLong, Char, UnsignedChar, Int32, UnsignedInt32, Int64, UnsignedInt64 all work the same as well.
  * Float: maps to the regular Anna Float. Should be used for the C 'float' type.
  * Double: maps to the regular Anna Float. Should be used for the C 'double' type.

  * Void: Only available as a return type. A function which returns nothing. Will be translated into a function of return type Object and return value null.
  * Pointer«X»: Opaque pointer value. Opaque pointers can not be used inside of anny except for sending them as parameters to other functions. Pointers can be recast as any other pointer type. 
  * List«X»: Maps to a list of items. X needs to be another basic type, potentially including another list. When a List is given as an output type, it will need annotations to inform the binder of the vector size, see below.
  * XXXVector, Maps to a list of numbers. When a List is given as an output type, it will need annotations to inform the binder of the vector size, see below.
  
  There should be a mechanism for adding library specific types. 

  */

module (
    name: gl,
    library("gl","glex","glu"), // Name of all libraries that need to be linked when creating the .so for this module
    include("GL/GL.h"), // List of all files that need to be #include:ed. 
    )
{
    
    def Void glBegin(Int mode);
    def Void glEnd();
    
    def Void glVertex4d(Double x, Double y, Double z, Double w) (alias(glVerfex4));
    def Void glVertex4i(Int x, Int y, Int z, Int w) (alias(glVerfex4));
    
    def Void glVertex3d(Double x, Double y, Double z) (alias(glVerfex3));
    def Void glVertex3i(Int x, Int y, Int z) (alias(glVerfex3));
    
    def Void glVertex2d(Double x, Double y) (alias(glVerfex2));
    def Void glVertex2i(Int x, Int y) (alias(glVerfex2));
    
    def Void glVertex3dv(DVector v) (alias(glVerfex3));
    def Void glVertex3fv(FVector v) (alias(glVerfex3));
    def Void glVertex3iv(IVector v) (alias(glVerfex3));
    
    def List«Int» someFun(Int x, Int y, Int z) (outputCount(3)); // The outputCount thingie tells the binding compiler that the size of the returned list is 3.
    def Pointer«Int» someFun2(Int x, Int y, Int z) (name(someFun)); // This is another way to bind the someFun function. It has the drawback that we can't actually use the output inside of Anna.
    
    primitives // This puts all the things below into a separate submodule on the Anna-side.
    {
	const Int points (name(GL_POINTS));
	const Int lines (name(GL_LINES));
    }

    custom
    {
	/* 
	   This is where you can place a bunch of code to perform platform dependant customization, etc.
	*/
	
	if(xxx)
	{
	    include.push("some_header.h");
	}
	
    }
}

include("sys/types.h", "sys/stat.h", "fcntl.h", "errno.h", "unistd.h");


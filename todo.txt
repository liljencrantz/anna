1.0 RELEASE CRITERIA:
* anna-game as a proof that the language works for solving reasonably complex problems
* Documentation coverage of standard API functions and types should be at least 90 %.
* Base documentation:
  - Split into multiple files
  - Check for dead links
  - binding generator doesn't pass on doc attribute
  - By default, attributes should be dropped to conserve memory. Add special switch to retain it for the annadoc program.
* HTML api documentation extractor
  - Hide internal elements by default
  - variadic arguments aren't shown as such
  - argument default values aren't shown
* Check that node compare supports all ast node types

1.0 RELEASE CRITERIA (Done):
* More validation:
  - Can't assign to constants
  - Only static members can be accessed statically
  - Check argument types to function calls better...
* Introductory segment in the documentation
* Working error handling
  - raise function
  - collect function
* List.sort
  - Basic sort function in place
  - Sort function
* Base documentation:
  - Make code links actually work
* HTML api documentation extractor
  - document attribute for modules
  - document attribute for properties
  - Basic iteration working
  - document attribute for memebers and types
  - HTML templates
  - File output working
  - Iterate over global namespace
  - Correct path for links
  - document default values
  - Inherit documentation attribute from base classes
  - Handle regular module functions
  - Sort members
  - Better module templates (pretty)
* Inheritance and method overloading fully working
* Static member access fully working 
* Add memory overhead of Ints and Floats to GC estimates
* Smarter GC timing algorithm
* Mutable and Imutable versions of List and String, switch between them using freeze/thaw properties
* Default argument values
* Check that node each, print supports all ast node types
* Usable File type
* Usable Date type
* Access attributes of variables and properties
* Rename vmstack to context
* Fix if/else snafu. Current solution is hardly elegant and it fails in some edge cases. Hopefully, we can come up with something significantly better...

1.1 RELEASE CRITERIA:
* During startup, cache contents of all directories in ANNA_PATH so that we don't have to do crazy numbers of stat calls
* getopt replacement
  - basic design
  - implementation
  - use it in annabind and annadoc  
* anna should use getopt to provide switches for setting the path, making dry runs, controlling the GC, etc.
* Working error handling
  - option to catch only some error types
* Working error handling
  - catch function?
* Documentation coverage of standard API functions and types should be 100 %.
* Constructors and inheritance _fully_ working
  - multiple constructors through aliases
* Add memory overhead of Hashes, Buffers and Lists to GC estimates
* Function for obtaining the amount of memory used by an object
* Proper iterators? Possibly rethink how map/filter and friends are implemented
* Protected members

1.2 RELEASE CRITERIA:
* HTML api documentation extractor
  - Search functionality
  - Show/hide different elements
  - expand/minimize docs
  - Handle complex documentation attributes, e.g. named stuff
* Regexp library
* Query library (SQL Alchemy/Linq/etc. replacement)
* Live debugger library
* Multithreading support using message passing and a common frozen object store
* Cache for mpz_t numbers? Is this meaningful?
* Set type
* Faster imutable lists/strings, supporting zero copy slicing, substringing, etc.
* Imutable Map/Set? Maybe...
* List.sort
  - List specialization
  - Return ImutableList when calling ImutableList.sort
  - Reverse sorting
  - Sort structure member

MISC:
Don't differentiate between macros and functions anymore. How a function/macro should be invoked only depends on how it is imported, so there really is no point in differentiating between them. 
When no method alias matches a call, output a clearer and more helpful error message. including a list of all candidate methods.
What should be the return value for iterator methods like map and filter when given a null value as a function body?
An error injection tool that randomly turns stack values into null objects would be cool. Need to make sure that the «this» object of method calls aren't flipped, though, which means we must do something clever in order to make it work.
Make api more consistent. Make naming of wrapper types consistent. Make naming of native type methods consistent.
Go over list of built in functions and methods and mark the right ones as pure
Can the list of anna_node_*_t structs be reduced? Can the node type specific code in anna_node*.c be simplified? It currently looks a lot like spagetti with huge numbers of switch statements. One possibility would be to add function pointers to the node types.
Should finalizers be completely dropped? If we drop them, we get a lot more freedom with regards to GC algorithms, but we on the other hand can't e.g. close files on exit, and we'd have to use the GC for a bunch of extra stuff, like list payloads
Should print work like python print, e.g. autoinsert newlines and spaces?
It might be useful to have a function to construct an instance of a specific list type. Should this be generalized to runtime template specialization support? Might be useful. Means a whole bunch of future potential optimizations become way harder, though.
Should Range really be mutable?
How should the argument list for inherited constructors be handled?
It should be possible to declare type members with initial values. 
We need reverse aliases for static methods, something like (aliasReverseStatic(String::convert))
Type member setup needs some dependency resolution in order for type calculations to work properly.
The GC uses recursion, we should switch to a stack instead in order to not smash the call stack on e.g. a huge linked list.

KNOWN BUGS:
List, Pair and Hash types are still included in their specialization list even if GC:ed. This should never ever trigger a bug, since if the type has been GC:ed it can't ever be used again, but it does seem unsightly...
Multiple inheritance clashes aren't handled sanely
A bunch of AST node types are missing equality comparison, etc.
If explicit function return type exists, return type of return expressions aren't abides checked against it
Default argument values and static calls to bound members seem to cause a crash
If you call an input parameter of a type method 'this', the interpreter will crash.

LANGUAGE FEATURES:
Function templates
Submodules
Return value type for continuations

STDLIB FEATURES:
The rest of the hashtable functions (filter, find, properties for key and value lists, etc.)
Set type
hashCode function for Pair
List.milter 
Range.milter
Hash.milter
List and Hash types should be made fail fast

Partial application and saner function argument handling, e.g. it should be possible to write (0..5).map(Int::__add__, 4), which is equivalent to (0..5).map(val){4+val}

RELIABILITY:
Use gcov to make sure the test/regression suite is reasonably close to complete (It's currently not)
Test suite should be at lest 10 % of total code in project. (Currently ~ 8 %)
More tests for complex math
More tests for floating point math
More tests for type checking on invalid specialization
Lots more coverage of using null value as function argument

DOCUMENTATION:
Document all vm ops w.r.t. manipulating the stack, etc.

PERFORMANCE:
Mandel test should be no more than one order of magnitude slower than the corresponding C implementation
Implement more of the language benchmark game tests to compare performance against various other languages. It should be possible to make Anna roughly comparable to Python in performance without too much work.
More builtin integer ops, e.g. mod, shift, etc.
Variable lookup instruction version for looking up in current frame?
Variable lookup instruction version for looking up in first parent frame?
Implement tail recursion
Optimization idea: Avoid creating trampolines when possible - push other stack onto call stack and have special case instruction for call with stack-on-stack. 
Add profiling information to the VM
Make a version of the fold op that takes a count parameter
Lazy loading of modules
Instead of a static using flag in the GC, the value should switch back and forth. That way, we don't need to touch all objects a second time when iterating. Also opens up to the possibility of not bothering to check old objects for GC:ing on every GC run.
Make Char and Float fast when used as HashMap keys

UNUSED OPERATORS:
Currently, the @ symbol is unused. 

PLANS FOR APPS WRITTEN IN ANNA:
live: Debug a running application using command line or web browser.
Compiler front end rewritten in Anna.


1.0 RELEASE CRITERIA:
* Constructors and inheritance fully working
* Working collect function for error handling
* Add memory overhead of Hashes, Buffers and Lists to GC estimates
* Documentation attribute for all standard API functions and types
* HTML api documentation extractor
  - document attribute for modules
  - document attribute for properties
  - Hide internal elements by default
  - Inherit documentation attribute
  - Better module templates
  - Handle complex documentation attributes, e.g. named stuff
* Introduction
* Check that node compare supports all ast node types
* More validation:
  - Only static members can be accessed statically
  - Can't assign to constants
  - Check argument types to function calls better...
* Types, Stacks etc. should be hashable
* Access attributes of variables and properties

1.0 RELEASE CRITERIA (Done):
* HTML api documentation extractor
  - Basic iteration working
  - document attribute for memebers and types
  - HTML templates
  - File output working
  - Iterate over global namespace
  - Correct path for links
* Inheritance and method overloading fully working
* Static member access fully working 
* Add memory overhead of Ints and Floats to GC estimates
* Smarter GC timing algorithm
* Mutable and Imutable versions of List and String, switch between them using freeze/thaw properties
* Default argument values
* Check that node each, print supports all ast node types
* Usable File type
* Usable Date type

2.0 RELEASE CRITERIA:
* HTML api documentation extractor
  - Search functionality
  - Show/hide different elements
  - expand/minimize docs
* Regexp library
* Query library (SQL Alchemy/Linq/etc. replacement)
* Live debugger library
* Multithreading support using message passing and a common frozen object store
* Cache for mpz_t numbers
* Proper iterators? Possibly rethink how map/filter and friends are implemented
* Protected members
* Set type
* Faster imutable lists/strings, supporting zero copy slicing, substringing, etc.
* Imutable Map/Set? Maybe...
* make anna_node_print print out ast nodes with some syntax sugar support
* List.sort

MISC:
Don't differentiate between macros and functions anymore. How a function/macro should be invoked only depends on how it is imported, so there really is no point in differentiating between them. 
When no method alias matches a call, output a clearer and more helpful error message. including a list of all candidate methods.
What should be the return value for iterator methods like map and filter when given a null value as a function body?
An error injection tool that randomly turns stack values into null objects would be cool. Need to make sure that the «this» object of method calls aren't flipped, though, which means we must do something clever in order to make it work.
Make api more consistent. Make naming of wrapper types consistent. Make naming of native type methods consistent.
If we add a bunch of implicit type conversions through aliases, we'll no longer need as many methods in e.g. the Complex type. Is the loss of transparency worth the clearer code?
Can the list of anna_node_*_t structs be reduced? Can the node type specific code in anna_node*.c be simplified? It currently looks a lot like spagetti with huge numbers of switch statements. One possibility would be to add function pointers to the node types.
Static math expression support, e.g. 4*3
Should finalizers be dropped? If we drop them, we get a lot more freedom with regards to GC algorithms, but we on the other hand can't e.g. close files on exit, and we'd have to use the GC for a bunch of extra stuff, like list payloads
Should print work like python print, e.g. autoinsert newlines and spaces?
It would be useful to have a function to construct an instance of a specific list type. Should this be generalized to runtime template specialization support? Might be useful. Means a whole bunch of future potential optimizations become way harder, though.
Should Range really be mutable?
How should the argument list for inherited constructors be handled?
It should be possible to declare type members with initial values. 
Can we drop the Pair type?
We need reverse aliases for static methods, something like (aliasReverseStatic(String.convert))
Add a variable named global in the global namespace, pointing to itself. 
Type member setup needs some dependency resolution in order for type calculations to work properly.

KNOWN BUGS:
List, Pair and Hash types are still included in their specialization list even if GC:ed. This should never ever trigger a bug, since if the type has been GC:ed it can't ever be used again, but it does seem unsightly...
Multiple inheritance clashes aren't handled sanely
A bunch of AST node types are missing some functionality, e.g. equality comparison, hashing, shallow cloning, deep cloning, etc.
If explicit function return type exists, return type of return expressions aren't abides checked against it
Stack types don't abide to Object. Making them do so causes a clash on e.g. __eq__. How do we handle this?
Can't mix named arguments and varargs

LANGUAGE FEATURES:
Function templates
Should modules map to directories, not files?
Submodules
Default function argument values. These also need to be part of the function interface and contained in function keys.
No magic toString method, use attributes to specify methods for implicit conversion
Return value type for continuations

STDLIB FEATURES:
HTML documentation extractor
The rest of the hashtable functions (filter, find, properties for key and value lists, etc)
Set type
hashCode function for Pair, List, Range, Complex, Char
A backtrace function
io module
time module
List.milter 
Range.milter
Hash.milter
List.reduce
Range.reduce
List.sort
List and Hash should be made fail fast

RELIABILITY:
Use gcov to make sure the test/regression suite is reasonably close to complete (It's currently not)
Test suite should be at lest 10 % of total code in project. (Currently ~ 6 %)
Use continuations to make a green thread implementation as a test of continuation functionality
Validate that all functions end with an empty stack frame
Tests for complex math
Tests for floating point math
Tests for type checking on invalid specialization
Test return types of complex expression types, e.g. if(){}+1.
Lots more coverage of using null as argument 

DOCUMENTATION:
Document all vm ops w.r.t. manipulating the stack, etc.

PERFORMANCE:
Mandel test should be no more than one order of magnitude slower than the corresponding C implementation
Start implementing a few of the language benchmark game tests to compare performance against various other languages. It should be possible to make Anna roughly comparable to Python in performance.
More builtin integer ops, e.g. mod, and Float comparisons
Variable lookup instruction version for looking up in current frame
Variable lookup instruction version for looking up in first parent frame
Implement tail recursion
Avoid creating trampolines when possible - push other stack onto call stack and have special case instruction for call with stack-on-stack. 
Add profiling information to the VM
Make a version of the fold op that takes a count parameter
Every member declaration also results in a stack template declaration because all members are also part of the stack. This further adds to the argument that we should nix stack_template_t.
Lazy loading of modules
Can we make string literals faster?
Instead of a static using flag in the GC, the value shouls switch back and forth. That way, we don't need to touch all objects a second time when iterating. Also opens up to the possibility of not bothering to check old objects for GC:ing on every GC run.
Make Char and Float fast as HashMap keys
Add bytecodes for comparisons

UNUSED OPERATORS:
Currently, the @ symbol is unused. 

PLANS FOR APPS WRITTEN IN ANNA:
Documentation generator: Introspect all data types and generate html documentation on them.
live: Debug a running application using command line or web browser.
Compiler front end.
Asynchronous continuation based app/web server
Simple car game using my terrain rendering engine


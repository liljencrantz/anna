Pop unused function returns
Validate that all functions end with an empty stack frame
Implement vm handling of property setters
Implement member setting
Implement autowrapping of methods
Implement node type: Const (Is this needed?)
Implement node type: Type specializations
Garbage collector
Investigate leaking non-GC:ed memory
Invertigate if we can completely drop the stack_template struct and just use types for that purpose
User defined properties
User defined variadic functions
User defined templates with full specialization support
Inheritance
Type annotations
Annotate method overloads with aliases
Always check aliases when resolving method calls during compile time
True type intersections
Continuations
milter/fap
Tests for namespaces
Tests for nested macro members
Tests for integer math
Tests for floating point math
HTML documentation extractor
Built in Complex type
Hash functions
Hashtable implementation
String format function
Cast operator
Escaping and error detection in char literals
Inlining of if/while bodies into main method


Figure out how to handle the map function. We can't make a prototype
function, we actually want the type hinting to go in the other
direction; the return value of the function supplied to map should determine the
return type of the function. I guess we want some kind of magical
syntax for annotating a method that will make the return type depend
on the input type? Or can we simply use a clever macro?

Every module is represented by an object with properties representing
the members. Imutable members, like types, are read-only properties.

There are two types of imports, macro imports and regular imports.

They use different keywords, import and expand.

These are equivalent:

import(io);
def foo(){File();}

def foo(){io.File();}


  Plans for apps written in anna:
  Documentation generator: Introspect all data types and generate html documentation on them.
  live: Debug a running application using command line or web browser.
  Compiler front end.
  Asynchronous continuation based app/web server
  Simple car game using my terrain rendering engine

Type members:
  member
  name
  intersect
  abides
  definition
  filter

Object members:
  asString
  type
  
  Code refactoring plan:
  
  - Move object code to individual .[ch] files.
  - All node types should have a head var which is an anna_node_t, to
    reduce the amount of casting needed.
  
  HashMap type
  Pair type
  Better Function type
  Better Type type  
  Stack type
  Byte type
  Buffer type
  Regexp type
  File type
  StringLiteral type
  FloatLiteral type
  NullLiteral type
  
  attribute lists for types, functions and stack entries
  Module variable inits
  Make abides check properly check method signatures
  Make abides check handle dependency cycles
  Cache abides checks. Do all checks possible at type creation time and store the results
  Split type namespace from type object
  Better code validator
  Type checking on function types
  General purpose currying
  Namespaces
  Non-recursive invoke
  Function default argument values
  Named function arguments
  Garbage collection  
  Proper intersection/union of types
  static member identifier and assignment
  static function calls
  String padding with null chars on «anti-truncate».
  Add toString and a few more basic methods to Object
  Make sure everybody inherits from Object
  
  Implement basic string methods
  Implement string comparison methods
  List arithmetic
  
  cast function (depends on type namespace/type object splittingx)
  
  elif macro
  __extendsAttribute__ macro
  in method
  __returnAssign__ macro
  __list__ macro 
  use macro
  __memberCall__ macro
  __staticMemberGet__ macro
  __staticMemberSet__ macro
  with macro


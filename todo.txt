1.0 RELEASE CRITERIA:
* Static member access fully working
* Constructor and inheritance fully working
* Inheritance and method overloading fully working
* Add memory overhead of Ints and lists to GC estimates
* Smarter GC timing algorithm
* File type
* Date type
* HTML api documentation
* Introduction
* Check that node each, node hash and all other node functions support all ast node types
* Default argument values
* More validation:
  - Only static members can be accessed statically
  - Can't assign to constants
 

2.0 RELEASE CRITERIA:
* Regexp
* Query macro (SQL Alchemy/Linq/etc. replacement)
* Live debugger
* Mutable and Imutable versions of List, String and HashMap, switch between them using freeze/thaw
* Multithreading support using message passing and a common frozen object store
* Cache for mpz_t numbers
* Proper iterators? Possibly rethink how map/filter and friends are implemented
* Protected members

MISC:
Don't differentiate between macros and functions anymore. How a function/macro should be invoked only depends on how it is imported, so there really is no point in differentiating between them. 
When no method alias matches a call, output a clearer and more helpful error message. including a list of all candidate methods.
What should be the return value for iterator methods like map and filter when given a null value as a function body?
An error injection tool that randomly turns stack values into null objects would be cool. Need to make sure that this object of method calls aren't flipped, though, which means we must do something clever in order to make it work.
Make api more consistent. Make naming of wrapper types consistent. Make naming of native type methods consistent.
If we add a bunch of implicit type conversions through aliases, we'll no longer need as many methods in e.g. the Complex type. Is the loss of transparency worth the clearer code?
Can the list of anna_node_*_t structs be reduced? Can the node type specific code in anna_node*.c be simplified? It currently looks a lot like spagetti with huge numbers of switch statements. One possibility would be to add function pointers to the node types.
Static math expression support, e.g. 4*3
Common constants, e.g. pi, e, etc.
Should finalizers be dropped? If we drop them, we get a lot more freedom with regards to GC algorithms, but we on the other hand can't e.g. close files on exit, and we'd have to use the GC for a bunch of extra stuff, like list payloads
Should print work like python print, e.g. autoinsert newlines and spaces?
It would be useful to have a function to construct an instance of a specific list type. Should this be generalized to runtime template specialization support? Might be useful. Means a whole bunch of future potential optimizations become way harder, though.
Should Range really be mutable?
How should inherited constructors be handled?
It should be possible to declare members with initial values. 
How exactly should the api for using the return type of one AST node as the value of another AST node look? What we have in place today seems rather kludgy and special purpose.Can we drop Pair?

KNOWN BUGS:
List, Pair and Hash types are still included in their specialization list even if GC:ed. This should never ever trigger a bug, since if the type has been GC:ed it can't ever be used again, but it does seem unsightly...
Multiple inheritance clashes aren't handled sanely
A bunch of AST node types are missing some functionality, e.g. equality comparison, hashing, shallow cloning, deep cloning, etc.

LANGUAGE FEATURES:
Function templates
Modules should map to directories, not files
Submodules
Default function argument values. These also need to be part of the function interface and contained in function keys.
No magic toString method, use attributes to specify methods for implicit conversion
Static members of a type should be available without an instance of that type. Preferably through TypeName.name
Return value type for continuations
Class methods


STDLIB FEATURES:
HTML documentation extractor
The rest of the hashtable functions (filter, find, properties for key and value lists, etc)
Set type
File type
hashCode function for Pair, List, Range, Complex, Char
A backtrace function
io module
time module
List.milter 
Range.milter
Hash.milter
List.reduce
Range.reduce
List.sort
List and Hash should be made fail fast

RELIABILITY:
Use gcov to make sure the test/regression suite is reasonably close to complete (It's currently not)
Test suite should be at lest 10 % of total code in project. (Currently ~ 5 %)
Use continuations to make a green thread implementation as a test of continuation functionality
Validate that all functions end with an empty stack frame
Tests for complex math
Tests for floating point math
Tests for type checking on invalid specialization
Test return types of complex expression types, e.g. if(){}+1.
Current method for determining map output is a bit fragile. 
Lots more coverage of using null as argument 
Many more null value tests

DOCUMENTATION:
Document all vm ops w.r.t. manipulating the stack, etc.

PERFORMANCE:
Mandel test should be no more than one order of magnitude slower than the corresponding C implementation
Start implementing a few of the language benchmark game tests to compare performance against various other languages. It should be possible to make Anna roughly comparable to Python in performance.
More builtin integer ops, e.g. mod, and Float comparisons
Variable lookup instruction version for looking up in current frame
Variable lookup instruction version for looking up in parent frame
Implement tail recursion
Avoid creating trampolines when possible - push other stack onto call stack and have special case instruction for call with stack-on-stack. This would require that the gc knows that non-objects might be living on the stack...
Add profiling information to the VM
Make a version of the fold op that takes a count parameter
Every member declaration also results in a stack template declaration because all members are also part of the stack. This further adds to the argument that we should nix stack_template_t. 
Lazy loading of modules
Can we make string literals faster?
Instead of a static using flag in the GC, the value shouls switch back and forth. That way, we don't need to touch all objects a second time when iterating. Also opens up to the possibility of not bothering to check old objects for GC:ing on every GC run.
Make Char and Float fast as HashMap keys
Add bytecodes for comparisons

UNUSED OPERATORS:
Currently, the @ symbol is unused. 

PLANS FOR APPS WRITTEN IN ANNA:
Documentation generator: Introspect all data types and generate html documentation on them.
live: Debug a running application using command line or web browser.
Compiler front end.
Asynchronous continuation based app/web server
Simple car game using my terrain rendering engine


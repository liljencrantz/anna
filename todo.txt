KNOWN BUGS:
List and hash types are still included in their specialization list even if GC:ed.
hash type does not support continuations
Call.each is b0rked

LANGUAGE FEATURES:
Default function argumet values. These also need to be part of the function interface and contained in function keys.
Named arguments for function calls.
Implement autowrapping of methods
Implement node type: Const (Is this needed?)
Implement node type: Type specializations (Is this needed?)
User defined properties
User defined variadic functions
User defined templates with full specialization support
Inheritance
True type intersections
milter/fap
Make all types inherit from Object
Int should just be an interface, with two backing implementations

STDLIB FEATURES:
HTML documentation extractor
The rest of the hashtable functions (filter, contains, properties for keys and values, etc)
Set type
String format function
File type
toString methods for Hash, List, Range, Function, Node, Pair, etc
A backtrace function

IDEAS:
Invertigate if we can completely drop the stack_template struct and just use types for that purpose

RELIABILITY:
Validate that all functions end with an empty stack frame
Tests for namespaces
Tests for nested macro members
Tests for complex math
Tests for floating point math
Tests for Pair (Specialization currently known to be broken)
Tests for type checking on invalid specialization
Test return types of complex expression types, e.g. if(){}+1.

DOCUMENTATION:
Document all vm ops w.r.t. manipulating the stack, etc.

PERFORMANCE:
Performance target: It should be possible to do the mandelbrot calculation test in 0.05 seconds on my x301.
variable lookup instruction version for looking up in current frame
variable lookup instruction version for looking up in parent frame
Free AST nodes after compilation
Special purpose bytecode instructions for arithmetic on common artithmetic types (int, float, complex)
Consider doing something about properties, performance-wise. Gprof indicates that member access is a significant performance bottleneck.
Implement tail recursion
Avoid creating trampolines when possible - push other stack onto call stack and have special case instruction for cal with stack-on-stack. This would require that the gc knows that non-objects might be living on the stack...
Perform escape analysis on stack frames and allocate ones who are never referenced in non-GC:ed memory.Jump labels
Add profiling information to the VM
Inlining of if/while bodies into main method
Make a verion of the fold op that takes a count parameter
Every member declaration also results in a stack template declaration because all members are also part of the stack. This further adds to the argument that we should nix stack_template_t. 

UNUSED OPERATORS:
Currently, the ? and @ symbols are unused. 

Figure out how to handle the map function. We can't make a prototype
function, we actually want the type hinting to go in the other
direction; the return value of the function supplied to map should determine the
return type of the function. I guess we want some kind of magical
syntax for annotating a method that will make the return type depend
on the input type? Or can we simply use a clever macro? A template?

Map construction syntax
var map = ["foo"=>3, "bar"=>7]

Named argument syntax
Circle(radius=>3, position=>[2,4,3]);

Every module is represented by an object with properties representing
the members. Imutable members, like types, are read-only properties.

There are two types of imports, macro imports and regular imports.

They use different keywords, import and expand.

These are equivalent:

import(io);
def foo(){File();}

def foo(){io.File();}


  Plans for apps written in anna:
  Documentation generator: Introspect all data types and generate html documentation on them.
  live: Debug a running application using command line or web browser.
  Compiler front end.
  Asynchronous continuation based app/web server
  Simple car game using my terrain rendering engine

Type members:
  member
  name
  intersect
  abides
  definition
  filter

Object members:
  asString
  type
  
  Code refactoring plan:
  
  - Move object code to individual .[ch] files.
  - All node types should have a head var which is an anna_node_t, to
    reduce the amount of casting needed.
  
  HashMap type
  Pair type
  Better Function type
  Better Type type  
  Stack type
  Byte type
  Buffer type
  Regexp type
  File type
  StringLiteral type
  FloatLiteral type
  NullLiteral type
  
  attribute lists for types, functions and stack entries
  Module variable inits
  Make abides check properly check method signatures
  Make abides check handle dependency cycles
  Cache abides checks. Do all checks possible at type creation time and store the results
  Split type namespace from type object
  Better code validator
  Type checking on function types
  General purpose currying
  Namespaces
  Non-recursive invoke
  Function default argument values
  Named function arguments
  Garbage collection  
  Proper intersection/union of types
  static member identifier and assignment
  static function calls
  String padding with null chars on «anti-truncate».
  Add toString and a few more basic methods to Object
  Make sure everybody inherits from Object
  
  Implement basic string methods
  Implement string comparison methods
  List arithmetic
  
  cast function (depends on type namespace/type object splittingx)
  
  elif macro
  __extendsAttribute__ macro
  in method
  __returnAssign__ macro
  __list__ macro 
  use macro
  __memberCall__ macro
  __staticMemberGet__ macro
  __staticMemberSet__ macro
  with macro


MISC:
Don't differentiate between macros and functions anymore. How a function/macro should be invoked only depends on how it is imported, so there really is no point in differentiating between them. 
Should we store most of the stack template data in the namespace class? Should hopefully simplify the code a bit.
Is differentiating between properties and members when looking at interfaces a mistake? It adds a bunch of extra run time checks for null types, which probably negates the performance advantage. Code is a bit more obvious, but but we lose a bit of freedom for no real benefit.
When no method alias matches a call, output a clearer and more helpful error message. including a list of all candidate methods.
What should be the return value for iterator methods like map and filter when given a null value as a function body?
An error injection tool that randomly turns stack values into null objects would be cool. Need to make sure that this object of method calls aren't flipped, though, which means we must do something clever in order to make it work.
Make api more consistent. Make naming of wrapper types consistent. Make naming of native type methods consistent.
If we add a bunch of implicit type conversions through aliases, we'll no longer need as many methods in e.g. the Complex type. Is the loss of transparency worth the clearer code? There are currently no users of the ANNA_NODE_TYPE_LOOKUP AST node type. Will we be using it in the future or can it be safely removed?
Can the list of anna_node_*_t structs be reduced? Can the node type specific code in anna_node*.c be simplified? It currently looks a lot like spagetti with huge numbers of switch statements. One possibility would be to add function pointers to the node types.
Static math expression support, e.g. 4*3
Common constants, e.g. pi, e, etc.
Should finalizers be dropped? If we drop them, we get a lot more freedom with regards to GC algorithms, but we on the other hand can't e.g. close files on exit, and we'd have to use the GC for a bunch of extra stuff, like list payloads
Should print work like python print, e.g. autoinsert newlines and spaces?
Instead of a static using flag in the GC, the value shouls switch back and forth. That way, we don't need to touch all objects a second time when iterating. Also opens up to the possibility of not bothering to check old objects for GC:ing on every GC run.
Make Char and Float fast as HashMap keys
Add bytecodes for comparisons
It would be useful to have a function to construct an instance of a specific list type. Should this be generalized to runtime template specialization support? Might be useful. Means a whole bunch of future potential optimizations become way harder, though.
Should Range really be mutable?
How should inherited constructors be handled?

KNOWN BUGS:
List, Pair and Hash types are still included in their specialization list even if GC:ed. This should never ever trigger a bug, since if the type has been GC:ed it can't ever be used again, but it does seem unsightly...
Implicit specialization doesn't work on user defined types
Multiple inheritance clashes aren't handled correctly

LANGUAGE FEATURES:
Function templates
Modules should map to directories, not files
Submodules
Default function argumet values. These also need to be part of the function interface and contained in function keys.
Int should just be an interface, with two backing implementations
continue/break (continue is easy with a continuation, but implementing break requires some special hacking. A macro could do it, but it would be a bit ugly)
No magic toString method, use attributes to specify methods for implicit conversion
Static members of a type should be available without an instance of that type. Preferably through Type.name
Return value type for continuations

STDLIB FEATURES:
HTML documentation extractor
The rest of the hashtable functions (filter, find, properties for key and value lists, etc)
Set type
String format function
File type
hashCode function for String, Pair, List, Range, Float, Complex, Char
A backtrace function
io module
time module
List.milter 
Range.milter
Hash.milter
List.reduce
Range.reduce
List.sort
List and Hash should be made fail fast

RELIABILITY:
Use gcov to make sure the test/regression suite is reasonably close to complete (It's currently not)
Test suite should be at lest 10 % of total code in project. (Currently ~ 5 %)
Use continuations to make a green thread implementation as a test of continuation functionality
Validate that all functions end with an empty stack frame
Tests for complex math
Tests for floating point math
Tests for type checking on invalid specialization
Test return types of complex expression types, e.g. if(){}+1.
Current method for determining map output is a bit fragile. 
Lots more coverage of using null as argument 

DOCUMENTATION:
Document all vm ops w.r.t. manipulating the stack, etc.

PERFORMANCE:
Mandel test should be no more than one order of magnitude slower than the corresponding C implementation
Start implementing a few of the language benchmark game tests to compare performance against various other languages. It should be possible to make Anna roughly comparable to Python in performance.
More builtin integer ops, e.g. mod, and Float comparisons
Variable lookup instruction version for looking up in current frame
Variable lookup instruction version for looking up in parent frame
Implement tail recursion
Avoid creating trampolines when possible - push other stack onto call stack and have special case instruction for call with stack-on-stack. This would require that the gc knows that non-objects might be living on the stack...
Add profiling information to the VM
Make a version of the fold op that takes a count parameter
Every member declaration also results in a stack template declaration because all members are also part of the stack. This further adds to the argument that we should nix stack_template_t. 
Lazy loading of modules
Can we make string literals faster?

UNUSED OPERATORS:
Currently, the ? and @ symbols are unused. 

PLANS FOR APPS WRITTEN IN ANNA:
Documentation generator: Introspect all data types and generate html documentation on them.
live: Debug a running application using command line or web browser.
Compiler front end.
Asynchronous continuation based app/web server
Simple car game using my terrain rendering engine


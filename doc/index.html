<html>
  <head>
  </head>
  <body>
    
    <h1>Introducing Anna</h1>
    <div class='subheading'>Start here</div>
    <p>
      Who is Anna? Who are you? You can't properly explain something
      like Anna with knowing who you're talking to. Read through the
      list below, and pick the link that suits you best.
    </p>
    
    <ul>
      
      <li>
	<a href='#intro_short'>Anna in a single sentence.</a> Click
	here if you already know everything there is to know about
	other programming languages.
      </li>
      
      <li>
	<a href='#intro_lisp'>Anna for LISP programmers.</a>
	Recommended if you are thouroghly familiar with LISP or a LISP
	like language, like Scheme.
      </li>
      
      <li>
	<a href='#intro_c'>Anna for Java, C, C++, Go and D
	  programmers</a>. Do you enjoy the pleasures of static
	  typing?  Curly braces? Yes? Then this is the link for you.
      </li>
      
      <li>
	<a href='#intro_script'>Anna for Python and Ruby programmers.</a>
	Do you feel most at home when writing code in a modern,
	dynamically typed scripting language?
      </li>
      
      <li>
	<a href='#intro_nemerle'>Anna for Nemerle programmers.</a>  Do
	you feel Ged was unfairly given too much time in the books of
	Earth sea?
      </li>
      
      <li>
	<a href='#intro_long'>Gentle Anna.</a> If you're a programmer,
	but unsure which of the above categories your language of
	choice falls into, or if you are not entirely familiar with
	programming computers, but curious about what makes Anna
	different, then this is the link for you.
      </li>  
      
    </ul>
    
    <h2>Anna in a single sentence</h2>
    <div class='subheading'>Wherein the author demonstrates his his mastery of commatation</div>
    <p>
      Anna is a statically duck typed computer language that supports
      LISP style macros, functions and types as first class citizens,
      closures and continuations; it has a C-style syntax and it's aim
      is to combine the expressiveness and power of LISP and Ruby with
      the type safety and control of Java.
    </p>
    <p>
      Note the use of a semicolon to combine two separate sentences into
      something that works around the originally stated limitations and
      still manages to be perfectly readable. That is the essence of Anna.
    </p>
    <p>
      To learn more about Anna, check out the following sections:
    </p>
    <ul>
      <li><a href='#duck_typing'>Duck typing and Anna</a></li>
      <li><a href='#macros'>Macros redefine our world</a></li>
      <li><a href='#misc'>An odd number of legs for a horse to have</a></li>
      <li><a href='#continuations'>Enough interruptions, let's continuate!</a></li>
    </ul>
    
    <h2>Gentle Anna</h2>
    <div class='subheading'>Wherein strategic use of mood lighting makes
      our lady seem less intimadating.</div>
    <p>
      Anna is a computer programming language. That is, it is a
      language designed to be written and read by humans, and executed
      by computers. There are many programming languages, all with
      their own strengths and weaknesses.
    </p>
    <ul>
      <li>
	Some languages are low level, meaning they force you to go
	into great detail about how you want to perform the actions,
	whereas other are high level, meaning they skim the details
	and force the computer to figure out more by itself. High
	level languages are usually slower, and they almost always
	require much more memory, but they are also usually much
	easier for the programmer to write. Anna is a high level
	language. It is designed in a way that should make it possible
	to make Anna programs significantly faster than most high
	level languages, most programs written in Anna are unlikely to
	match the speed of a well written progrm in a low level
	language.
      </li>
      <li>
	Some languages are statically typed, meaning the programmer
	has to tell the computer what type of data is being processed
	at every step of a program, other are dynamically typed,
	meaning the programmer only tells the computer what steps to
	take, and the computer will find out what type of data to
	operate on when the program is run. Statically typed languages
	avoid some types of bugs because it can figure out that some
	operations won't work on the specific type of data you're
	operating on, and will warn you in advance that your code is
	broken, but dynamically typed languages require less verbosity
	from the programmer. Statically typed languages are usually
	also slightly faster than dynamically typed languages. Anna
	tries to find a middle ground between these two by being
	statically typed, but making the computer figure out the
	actual type for you when possible.
      </li>
      <li>
	Pretty much all computer languages allow you to extend the
	language to new domains. The way this is usually done is
	through software libraries. If we make an analogy to regular
	human languages, like english, a software library is like a
	set of new words. We can add new words to most languages that
	allow us to discuss new subjects, such as the sending of
	emails. What most computer languages do not allow, however, is
	for us to redefine the grammar of the language; that is, the
	basic structure of the language is constant. The LISP
	language, invented over 50 years ago, actually provided a
	means to redefine some parts of the grammar of the
	language. This feature is extremely powerful, and it has
	allowed LISP to stay relevant even today. Many people rever
	LISP as some kind of divine and perfect ideal of a language,
	though few of them actually use it much. The downside of LISP
	is that the most basic level of underlying structure of the
	language - the part of the grammar that can not be changed, is
	extremely simple. LISP code is always a nested list of lists,
	something which is not very easy to read or understand for
	humans. No matter how much you redefine the high level grammar
	of LISP, it will always keep that basic structure of lists of
	lists, and humans tend to find that hard to handle. Anna is
	different from LISP in this regard. To the computer, Anna
	looks like a list of lists, much like LISP, but when writing
	programs for Anna, there is a special translation layer called
	the sugar, that allows you to write your code in a way that is
	much more intuitive (and familiar) to human beings. This way,
	Anna gives you the power to grow and redefine the language,
	just like in LISP, but still lets you keep the intuitive and
	readable syntax of less powerful languages.
      </li>
      <li>
	There are many styles of programming. These include Object
	oriented programming, imperative programming, generic
	programming and functional programming. Some program problems
	are solved better with one approach, others with another, but
	no single approach is optimal for all types of
	problems. Pretty much all languages support all these styles
	to some degree; they rely more on a way of thinking than on
	any specific language feature. However, Anna contains many
	features to make all these styles pleasant to use. Thus you
	can be reasonably confident that no matter what the problem
	is, Anna provides you with the tools to solve it efficiently.
      </li>
    </ul>
    <p>
      That should give you an idea about Anna. If you want more in
      depth information about some aspect of Anna, follow one of the
      links below.
    </p>
    <ul>
      <li></li>
    </ul>
    <h2>Anna for LISP programmers</h2>
    <div class='subheading'>Wherein it is explained that old is the new
      new.</div>
    
    <p>
      Anna is a statically typed (somewhat) LISP-like language with a
      front end that allows you to write your code with a
      C-like structure, e.g. using infix operators, and braces. The Anna
      type system supports duck typing, meaning that if the type of
      variable B contains all members of the type A, with compatible type
      signatures, then B can be freely cast into a variable of type A. It
      supports LISP style macros, continuations and closures.
    </p>
    <p>
      In order to learn more about Anna, check out the following sections:
    </p>
    <ul>
      <li>Sugar and spice - How the front end sugar works and what Anna looks like without makeup.</li>
      <li></li>
    </ul>
    
    <h2>Anna for Java, C, C++, Go and D programmers</h2>
    <div class='subheading'>Wherein a prisoner is offered a golden cage.</div>
    <p>
      Anna is a C-like language with garbage collection and a powerful
      object system. At first glance, Anna feels very familiar to Java
      and C# programmers, and coders of C, C++ and other C-like
      languages should pick up the changes relatively quickly as
      well. But once you look underneath the hood, Anna has some nifty
      features to reduce the number of keypresses you need, including:
    </p>
    <ul>
      <li>
	Say you've written a class A, and it implements all of the
	members of an interface/class B. You do not need to explicitly
	_say_ that A is a B, the interpreter figures out for itself that
	the class A abides by the interface provided by class B. This is
	called duck typing.
      </li>
      <li>
	There are lots of situations in statically typed languages
	where you need to repeat the type of a specific expression
	over and over and over. Anna is pretty clever about figuring
	out what type an expression should have, and not force you to
	write it out multiple times. Most variable declarations and
	cast operations for example do not require you to write out
	the type.
      </li>
      <li>
	You can specify a function inside of another function in Anna,
	and the inner function will have full read and write access to
	the variable scope of the outer function. This has many uses,
	including a quick and easy way to create whole families of
	related functions at runtime in a very simple way.
      </li>
    </ul>
    <p>
      But what really sets Anna apart is the level of metaprogramming
      it allows. Anna allows you to redefine the very building blocks
      of the language. Use/with statements, exceptions and loop
      constructs can all be created or altered in order to extend the
      language in any way you choose. Even better, such extensions are
      written in the language itself, no arcane template
      metaprogramming is needed.
    </p>
    <p>
      There are two basic building blocks of Anna that allow you to
      redefine the language. They are macros and continuations. We'll
      explan them brifely. C and C++ coders may think to themselves
      that they know about macros, and that they really aren't that
      great, and in one sense they'd be correct, because C-style
      macros really aren't that great. Ignore C macros, lets instead
      talk about Anna style macros, because they're actually pretty
      neat. But first, just a little bit of background. 
    </p>
    <h3>Macros, redefined</h3>
    <p>
      Pretty much all compilers will read a source file into some kind
      of tree of nodes called an abstract syntax tree, or AST for
      short. The AST for a simple code snippet
      like <code>print(3)</code> will likely looks something like
      this:
    </p>
    <img src=''>
    <p>
      Every node in the AST tree above is at some point a regular Anna
      object, and the compiler can alter these nodes as it sees
      fit. That's pretty nifty, but how does that tie in with us? Anna
      has two keywords for defining a function,
      namely <code>function</code> and <code>macro</code>. They work
      pretty much the same, they both let you define a pice of code
      with a few input parameters and a few output parameters. There
      are two differences between the two, firstly that macros are run
      at compile time, and secondly that the input and output of the
      macros is an AST. The implications of this may not be obvious
      at once, so we'll consider a few examples. First, look at the
      code snippet below:
    </p>
    <code>
macro replaceObjectWithInt(ast)
{
	ast.replaceChildren(child)
	{
		var id = cast(child,Identifier);
		if(id and id.name=="Object")
		{
			return Identifier(id, "Int");
		}
		return child;
	}
	return ast;
}
</code>
    <p>
      What does the above code do? If you can't guess, the correct
      answer is that it walks the entire AST and replaces all
      identifiers that have the value <code>Object</code> with a new
      identifier with the value <code>Int</code>. Instant
      templating! Of course, the Anna standard library
      already <em>has</em> a very nice templating system, which is (of
      course) implemented using macros, so there is no need to write
      your own, but the possibility to make that type of additions to
      the language is in your hands.
    </p>
    <p>
      The most common reason for using macros is to construct
      sublanguages, also called domain specific languages. The Anna
      front end is pretty loose about what input it will accept -
      pretty much anything that can be reasonably parsed into an AST
      is allowed. That opens up the possibility to create macros that
      parse things using a completely different syntax. For example,
      there is a macro that allows you to create date objects using
      the standard ISO data format:
    </p>
<code>
var birthday = Date(1978-05-20, 12:34:00);
</code>
    <p>
      It is possible to create a list search interface like LINQ in
      Anna, but unlike LINQ, it is not a one time thing, crafted into
      the compiler. Anna provides a general purpose framework that
      allows you to create libraries that do the same thing LINQ does,
      but better. 
    </p>
    <h3>Continuations, continued</h3>
    <p>
      This paragraph is for C (and possible C++) coders that know what
      a longjmp is. If you don't, feel free to skip this
      paragraph. So, you know what a longjmp is. Well, a continuation
      is exactly like a longjmp, except that a few of the restrictions
      placed on longjmps are removed. Specifically, longjmp:s only
      allow you to «rewind» the stack and continue execution further
      down on the function stack, whereas continuations allow you to
      jump up, down or sideways into a whole other branch ot the
      stack. That's it. Nothing more. Simple. Feel free to skip to the
      example.
    </p>
    <p>
      
    </p>

    <h2>Anna for Python and Ruby programmers</h2>
    <div class='subheading'>Wherein...</div>
    
    <p>
      In daily use, Python and Ruby are probably the languages that
      most resemble Anna.  Anna code looks a bit like C, which means
      the code may not look like Python or Ruby, and you have to do
      slightly more typing in Anna sometimes, but the way you go about
      writing your programs is very similar.
    </p>
    <p>
      Unlike Python, Anna does not have statements, only
      expressions. A function declaration is an expression that
      returns a function. Thus, you do not need the silly and
      contrived lambda expression to create anonymous functions:
    </p>
    <code>
FIXME! Add an anonymous function example here
    </code>
    <p>
      Much like in Ruby, there is a very simple shortcut for throwing
      in a block of code as an additional parameter in Anna. If you
      simply append a code block afer a function call, Anna will
      interpret it as a function parameter:
    </p>
    <code>
FIXME! Add code block example here
    </code>
    <p>
      Another way in which Anna is like Python and Ruby is the convenient support for functional programming. Say we haxe EXAMPLE FIXME LALALA.
    </p>
    <code>
FIXME! Functional programming example here
    </code>
    <p>
      Blocks of code, by the way, are anonymous functions that take 0
      parameters and return the last expression in the block.
    </p>
    <h3>Static typing!!!</h3>
    <p>
      So. Enough dodging, lets address what is likely to be the major
      cause of concern for Ruby- and Python lovers. Static typing. In
      Anna, you will sometimes have to do slightly more typing. It's
      true. Anna does its best to figure out types for you, and when
      it can, you don't have to tell her, but there are still
      situations where you have to talk about types. Lets break it down:
    </p>
    <ul>
      <li>
	When declaring a variable, if you supply an initializer, the
	variable will take the type of the initializer. If you don't
	you'll have to give the type.
      </li>
      <li>
      <li>
	When defining a function for the first time, you will have to
	supply the type of each input parameter and sometimes alse the
	return type. When overriding a method in a subclass, you don't
	have to supply any type information at all. You don't even
	have to give the input parameter names.
      </li>
      <li>
	When performing a cast (I know, I know), if you are assigning
	the value of the cast to a variable, you do not have to tell
	Anna what you're casting to. The rest of the time, you do.
      </li>
    </ul>
    <p>
      The upshoot of this is that you have to do significantly less
      type checking when validating your input rguments (and you do
      validate your input arguments, don't you?), regaining you some
      of those lost key strokes. You also get much better ahead of
      time code checking - some silly mistakes can be caught earlier
      in the development process in Anna.
    </p>
    <p>
      Static typing does catch some bugs at compile time that aren't
      tiggered until you happen to run a specific function with a
      specific combination of parameters in dynamic languages. That is
      a fact. Static typing also involves more typing. Another
      fact. It is hoped that the «smart» static typing of Anna is the
      optimal tradeoff - you get most of the safety and a more
      tolerable amount of typing than in other statically typed
      languages.
    </p>
    <h2>Anna for Nemerle programmers</h2>
    <div class='subheading'>Wherein...</div>
    
    <p>
      Nemerle and Anna are similar languages. Both aim to create a
      language that looks C-like on the surface, but let you fundamentally
      redesign the language through macros. Some of the major differences
      between Anna and Nemerle:
    </p>
    <ul>
      <li>Duck typing</li>
      <li>
	Anna has a Ruby-inspired block syntax allows you greater language flexibility
      </li>
      <li>Null handling</li>
      <li>
	Nemerle is a .Net language, meaning it has a vast array of
	.Net libraries available, but this also means that Nemrle has
	a standard library that has not been designed to make the best
	use of the languages most exciting features.
      </li>
    </ul>
    <h1>Duck typing and Anna</h1>
    <p>
      Most languages, including Python and Java, have operations that
      let you check if an object explicitly states that it implements
      some interface. You have, for example,
      the <code>Comparable</code> interface in Java, which defines a
      set of methods that allow you to compare one object to
      another. The realization that it doesn't, or at least shouldn't,
      matter if an object explicitly states that it implements a
      specific interface, so long as it actually does implement it,
      has struck a great number of people over the ages. In python, it
      has become popular to avoid the <code>is</code> operator to
      perform type checking, and instead simply check if the relevant
      fields and methods are present in an object. This idea is called
      duck typing, and while the idea and its usage predates Python,
      the concept of duck typing has been popularized by the Python
      community.
    </p> 
    <p>
      Anna takes the concept of duck typing and runs with it. It is
      not possible in Anna to check if an object inherits from a
      specific type. There is simply no inheritance information
      available. You can _only_ check if an object <code>A</code> is
      compatible with a type <code>B</code> using duck typing. It is
      also trivial to perform operations on types in order to type
      templates dynamically. For example, say you want to test if the
      object <code>someObject</code> has all the members common to
      both the <code>String</code> and <code>Int</code> types. That is
      easily done using this code:
    </p>
    
<code>
if(someObject is String.intersect(Int)) 
{
    ...
}
</code>
    <p>
      Anna makes it similarly easy to filter out a subset of members from
      a type, create the union of two types, etc.
    </p>
    <h2>Dynamic type creation</h2>
    <p>
      In order for duck typing to be viable in a statically typed
      language, it must be easy to create new types on the spot. A very
      simple example of this is the <code>or</code> macro. Take the
      following snippet of Anna code:
    </p>
    <code>
var Foo foo=getFoo();
var Bar bar=getBar();
var baz = foo or bar;
    </code>
    <p>
      The or operator in Anna will return the first value (foo) if it is
      true, otherwise, bar will be returned. This means that the return
      type of <code>foo or bar</code> is the intersection of the types of
      the respective arguments, in this case, the intersection of the
      types <code>Foo</code> and <code>Bar</code>.
    </p>
    
    
    <h1>Minimum impact variable declarations</h1>
    <p>
      Anna is a statically typed language. That means that before a block
      of Anna code is executed by the computer, every variable declaration
      and every object member will have a known type associated with
      it. This does not, however, mean that you as a programmer must tell
      the interpreter about all of those types. Anna goes out of her way
      to find situations where there is no ambiguity as to the type of a
      variable, and to relieve you of the burden of explicit typing in
      such situations. Consider this trivial example:
    </p>
    <code>var Int i = 7;</code>
    <p>
      The above is an Anna style variable declaration, the
      variable <code>i</code> is declared to be of type <code>Int</code>,
      and is given the initial value of 7. Now, the above is a perfectly
      valid Anna expression, but it is not the simplest way possible to
      epress the above. You see, the numeric literal <code>7</code> is
      known by the interpreter to be of the type Int. The interpreter can
      use this information to guess the type of the variable
      declaration. Therefore, we can simply omit the variable type, and
      write the following:
    </p>
    
    <code>var i = 7;</code>
    
    <p>
      This only saves you four key strokes in the example above, but
      consider for example templated types, such as a map with String keys
      and Double values:
    </p>

<code>
var Map&lt;String,Double&gt; map = ["Mon":0.0,"Tue":1.1;
var map = ["Mon":0.0,"Tue":1.1];
</code>

    <p>
      Suddenly, we've cut the number of key strokes nearly in half!
    </p>
    
    <p>
      Variable declarations aren't the only place where the interpreter
      can figure out the variable type for you, some more examples follow
      below.
    </p>
    
    <code>
  /*
   * Function with return type implied by the type of value it is returning
   */
  def next(Int in)
  {
      return in+1;
  }

  /*
   * When overriding a method in a subclass, the entire method signature is 
   * implicit from its name
   */
  class A
  {
      def foo(Int in)
      {
          print in;
      }
  }

  class b extends A
  {
      foo
      {
          print in+1;
      }
  }


  /*
   * The result of the cast is assigned to a variable of type Int, 
   * so we can assume we're casting to Int
   */
  var Object foo = someFunction();
  var Int bar;
  bar = cast(foo);
  
    </code>
    <h1>Macros redefine our world</h1>
    <p>
      Anna, much like LISP, allows you to define functions that accept a
      tree of nodes representing a program code snippet as an input, and
      returning another code snippet as its output. This is in stark
      contrast to regular functions, that accept the
      evaluated <em>results</em> of a code snippet as its input and
      output. For example, consider the following snippet:
    </p>
    <code>
      foo = ...;
    </code>
    
    
    <h1>No exceptions</h1>
    <p>
      Anna does not have exceptions. It would be easy to implement
      exceptions using continuations, but they are considered bad
      coding style in Anna. The perception is that exceptions make
      your programs unpredictable and often causes error handling,
      which is the least well tested part of most application, to use
      completely different code paths that often result in unintended
      bugs. In its stead, Anna allows you to record all errors that
      occured during the execution of a function, and deal with them
      where convenient. Instead of the classic try/except block of
      other languages, Anna has a collect/handle block that in many
      ways behaves the same, but with an important difference. This is
      how a collect/handle block will usually look like:
    </p>
<code>
collect
{
    /* Some code that may cause various error conditions */
    ...
}
handle(err){
    case IOError{
	/* If we encounter an IO error, ignore the rest of the error 
	 * list, but continue running the program */
	print("There was an IO problem. Details:\n", err.message);
	break; 
    }
    case PermissionError{
	/* If we encounter a permission error, exit the program */
	print("Access denied! Shutting down\n");
	exit(1);
    }
    default {
	/* If we encounter any other error,  continue processing the 
	 * error list */
	print("Unknown error. Details:\n", err.message);
    }
}
</code>
    <p>
      The <code>collect</code> call will save any errors that occur
      while executing its body, including any errors occusing in
      functions called by the body at any level of nesting, into a
      list of errors. Once the code has finished, the list of errors
      is iterated over and handled by the <code>handle</code>
      call. Note that handle is a loop, it is executed once for every
      error that occured in the code.
    </p>
    <p>
      How is this different from exceptions? Exceptions can skip over
      parts of your code in very unpredictable ways. Whenever you
      allocate some form of resource, you need to use try/finally to
      make sure it's released, which is very error prone. When an
      error happens in Anna, it is recorded, but the code will keep in
      running. In Anna, you don't need to code defiensively around the
      possibility that some code you called might throw an
      exception. You do't need to be afraid thet there is an
      undocumented exception that might be thrown by some library code
      you're using causing a program flow that you hadn't thought of
      and results in rare and unpredictable bugs. Instead, code that
      errors out be recorded, and will then usually simply return
      null. And because using null objects does nothing in Anna, you
      can usually make your code exit cleanly and automatically on
      errors without even trying. For example, look at this trivial
      example:
    </p>
<code>
var f = File("foo.txt").open();
while(f.readLine())
{
    ...
}
f.close();
</code>
    <p>
      If the file can not be read, either because it doesn't exist or
      because you lack the permissions, the open call will fail and
      return null, and f will be assigned null. Calling readLine on
      the null object will again return null, ending the loop at
      once. Calling close on the null object will also have no
      effect. So because of how null handling works in Anna, the above
      code will handle any error without forcing you to write any
      error handling code.
    </p>
    <h1>An odd number of legs for a horse to have</h1>
    <p>
      This section gives an overview of the various Anna features that,
      while important, did not warrant an entire section of their own.
    </p>
    <h2>What is null? Baby don't hurt me!</h2>
    <p>
      The null object in Anna, which can be accessed through
      the <code>null</code> keyword, is a very odd object. It abides
      to every interface, and calling any method on it will without
      exception have no side effects and will return a null object. In
      other words, it is perfectly ok to call <code>2 + null</code>,
      it will not crash or throw an exception, and the result will be
      null.
    </p>
    <h2>Truth is lie</h2>
    <p>
      There is no separate Boolean type in Anna. There is exactly one
      object that takes on the responsibility of representing the false
      state, and that is the null object. Any other object, including the
      empty list, the number zero and the text string "null" all count as
      true in the eyes of if statements and any other statement that
      expects a yes/no answer. Null is the new no.
    </p>
    <h2>I'll be your operator, baby</h2>
    <p>
      Anna has a small number of special operators that allow you to
      implement some of the most common language operations with a
      slightly terser syntax that most people find easier to parse. These
      operators include comparison, assigment, basic aritmetic, string
      formating, list slicing and a few more. The complete table of
      operators and their precedence is listed in the table below. Most of
      these operators are overloadable. The exceptions are the '!' not
      operator, the '.' member access operator and a few more. The rest
      can be overloaded by defining methods with special names. For
      example, when the '+' operator is used...
    </p>
    <p>
      In addition to overloading +, - and various other operators,
      Anna also allows you define you own generic operators. These
      operators all start with the «@» symbol, followed by an identifier:
    </p>
    <code>
var a = 4;
var b = 7;
print(a @bitand b);
    </code>
    <p>
      The above example shows usage of the @bitand generic operator of
      the Int class, which will perform a bitwise and operation. To
      define your own generic operator, simply define a method named
      like the operator, but enclosed within double underscores. An
      example:
    </p>
    <code>
class Color
{
    function __blend__(Float alpha)
    {
	...
    }
}

var col = Color();
col @blend 0.1;
    </code>
    <p>
      
    </p>
    <h2>No reservations? No problem!</h2>
    <p>
      The Suger layer has a small number of such words, including
      'function', 'var' and 'return'. But the basic Anna language does not
      have any reserved words. But because macros can never be redefined,
      macros more or less take the place of reserved words. It may seem
      scary that modules you import can add reserved words to the language
      - what if a module you rely on suddenly adds a macro named 'pie'?
      Suddenly, you'll have to edit all your source code to remove any
      variables and functions named pie. And given how delicious pie is,
      that is bound to take an insurmountable amount of time.
    </p>
    <p>
      Clearly, allowing a module to add key words without your say so
      is a terrible idea. Anna avoids this disaster in them making
      simply by making the import of macros an explicit act. Macro
      names are never imported automatically when you import a
      module. If the module 'it.is.delicious' contains a macro named
      'pie', it will not be imported by the statement 'import
      it.is.delicious'. You need to write 'import
      it.is.delicious.pie'. That way, every single non-builtin macro
      that you import is explicitly listed at the top of every source
      code file.
    </p>
    <p>
      Of course, given that macros work the way they do, it is
      possible to write a macro that will import additinal macros into
      your namespace, but aside from that being exceptionally bad
      form, you will at least have that single macro import statement
      to investigate.
    </p>
    <h2>Comments nest</h2>
    <p>
      Like C and friends Anna uses /* to start a multiline comment,
      and */ to end it. But unlike C and friends, comments can be
      nested inside each other. This makes it trivial to comment out a
      large chunk of code, even if it happens to contain multiline
      comments.
    </p>
    
    <h1>A simple, annotated example</h1>
    <p>
      Ok, let's start putting Anna through her paces! Fire up the
      interactive Anna console by typing <code>anna</code> in your
      terminal and pressing enter. This is a minimal Anna program that
      you can then cut and paste into the interpreter:
    </p>
    <code>
/*
	Declare a function called mandelbrot, it accepts a complex number 
	(the coordinate) amd a maximum iteration count.
*/
function mandelbrot(Complex p0, Int maxStep)
{
    /*
	Declare two local variables. The first one is p, which is the same 
	type as p0 (a Complex) and has the initial value p0.
	The second one is step, which is the same type as 1 (an Int) and 
	has the initial value 1.
    */
    var p = p0;
    var step = 1;
    /*
	While the absolute value of p is less than two and we haven't run 
	into the maximum iteration count, run the loop block.
    */
    while(p.abs() &lt; 2.0, and step &lt;= maxStep) 
    {
	/*
	    Square p and add p0.
	*/
        p = p^2 + p0;
	step += 1;
    }
    /*
	Return the number of iterations used.
    */
    return step;
}
/*
    x:y..z defines a range of values from x to z using the step y. We set
    up such ranges for both the x and y direction, and call the mandebrot 
    function (defined above) with each input combination, and print either 
    a hash or a space depending on if the point was in the set.
*/
(-1.0:0.1..1.0).each(x){(-1.0:0.1..1.0).each(y){print(if(mandelbrot(Complex(x,y),32)==32){'#'}else{' '}}}}
    </code>
    <p>
      The above code will print a Mandelbrot set on your screen. Try
      reading the comments and check that you understand what the code
      does. There are a few things that are different from many other
      languages in the code above. We'll comment on them below.
    </p>
    <h2>Looping</h2>
    <p>
      Anna does not have a traditional for loop syntax. To print the
      values 0 to 10 in Anna, do the following:
    </p>
<code>
(0..10).each(i){print(i)}
</code>
    <p>
      All collection type objects, such as maps, lists and ranges
      provide an each method. It can be used with a single argument,
      such as above, or it can be used with two arguments, like this:
      </p>
<code>
var temperatures = ["Monday":31.1, "Tuesday":31.7, "Wednesday": 32.5];
temperatures.each(day:value){print("Day: ", day, ", temperature: ", value, "\n")}
</code>
    </p>
    <h1>Microformats</h1>
    <p>
      The Anna parser is written to be as accepting as possible of weird
      elements, and instead offloads as much of the code validation as
      possible to macros. This allows you to write microformat macros. These
      are macros that take an AST subtree and transform then into another
      subtree in order to allow you to define your own compact data formats.
      For example, JSON is a valid subset of Anna, and there is a JSON
      microformat macro to transform an AST containing JSON into the Anna
      equivalent, meaning you can insert JSON data verbatim into the code,
      and make sure the JSON macro parses it to correct Anna code:
    </p> 
<code>
Map m = JSON({data:[1,2,3,7], unit:"seconds", caption:null});
</code>
    <p>
      Another very practical use of this feature is date handling. There are
      macros that make sure anything you send to the Date constructor, or
      anything you add or remove from a date, is parsed using the standard
      ISO date format:
    </p>
    <code>
// Create a new date from a specified date 
var then = Date(2009-1-1, 12:30);

// Move ahead x years and one hour 
date += x-0-0, 1:00;
    </code>
    <h1>Sugar and spice - How the front end sugar works and what Anna looks like without makeup</h1>
    <p>
      The real syntax for Anna is painfully simple. There Anna AST
      contains only three types of nodes:
    </p>
    <ol>
      <li>
	Constant literals, such as <code>3</code>, <code>1.0</code>
	or <code>"foo"</code>.
      </li>
      <li>
	Identifiers, such as <code>foo</code> or <code>String</code>. 
      </li>
      <li>
	Function calls, such as <code>X(Y,Z)</code>, where <code>X</code>, <code>Y</code>
	and <code>Z</code> are arbitrary other AST nodes. In the above
	example, the AST node <code>X</code> is invoked
	with <code>Y</code> and <code>Z</code> as its parameters.
      </li>
    </ol>
    <p>
      That's it. Those are the only things needed to write Anna
      programs. For somebody coming from a C background, that might seem
      anemic for a programming language. Where are the code blocks?  Where
      are the if/while/whenever statements? Function definitions?
      Meanwhile, anybody with a LISP background will start twiddling their
      beards in boredom. They <em>know</em>.
    </p>
    <p>
      The sugar front end of Anna is a simple language front end that
      has a few keywords and special constructs such as operator
      overloading that allow you to use a terser, C-like syntax. The
      dot operator is used for setting and getting member values, we
      have arithmetic operators with the usual precedence, we have
      special language constructs to allow us to define types,
      functions and variables with a little less verbosity, etc..
    </p>
    
  </body>
</html>
